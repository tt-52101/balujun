/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.2.5.0 (NJsonSchema v9.13.37.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/operator/finally';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class ActivityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Web客户端使用，直接将订单创建到activity表中
     * @param body (optional) {
        "sourceId": "54D99CD6-D807-4783-70AA-08D798BCBD02",
        "scheduleId": "829D2F50-D4F8-4D0C-0C2F-08D798BCBD32",
        "payMethodId": "6253E959-5DFD-4CBA-0A7C-08D798BCBC89",
        "activityDetails": [
            {
                "ticketPriceId": "2744AC36-68C4-45E0-1F19-08D798BCBD8A",
                "customerId": "",
            }
        ]
    }
     * @return Success
     */
    createActivity(body: CreateActivityModel | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/CreateActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateActivity(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 创建团体购票订单
     * @param body (optional) {
        "sourceId": 1,
        "payMethodId": 4,
        "discount": 0.8,
        "orderType": "OrderTypeOrg",
        "remark": "",
        "createUserId": 2,
        "totalQuantity": 1,
        "totalAmount": 50,
        "ticketPriceId": 1,
        "activityDetails": [
            {
                "quantity": 1,
                "customerId": 1
            }
        ],
        "groupId": 1,
        "availableStart": "2020-03-23",
        "availableEnd": "2020-03-29"
    }
     * @return Success
     */
    createGroupActivity(body: CreateGroupActivityModel | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/CreateGroupActivity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateGroupActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGroupActivity(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreateGroupActivity(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * Web客户端使用，执行退票操作
     * @param list (optional) 票据Idlist
     * @param rDiscount (optional) 退票折扣
     * @param remark (optional) 
     * @return Success
     */
    refundTicket(list: number[] | undefined, rDiscount: number | undefined, remark: string | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/RefundTicket?";
        if (list === null)
            throw new Error("The parameter 'list' cannot be null.");
        else if (list !== undefined)
            list && list.forEach(item => { url_ += "list=" + encodeURIComponent("" + item) + "&"; });
        if (rDiscount === null)
            throw new Error("The parameter 'rDiscount' cannot be null.");
        else if (rDiscount !== undefined)
            url_ += "rDiscount=" + encodeURIComponent("" + rDiscount) + "&"; 
        if (remark === null)
            throw new Error("The parameter 'remark' cannot be null.");
        else if (remark !== undefined)
            url_ += "remark=" + encodeURIComponent("" + remark) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundTicket(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundTicket(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRefundTicket(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param list (optional) 
     * @param rDiscount (optional) 
     * @return Success
     */
    sumRefund(list: number[] | undefined, rDiscount: number | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/Activity/SumRefund?";
        if (list === null)
            throw new Error("The parameter 'list' cannot be null.");
        else if (list !== undefined)
            list && list.forEach(item => { url_ += "list=" + encodeURIComponent("" + item) + "&"; });
        if (rDiscount === null)
            throw new Error("The parameter 'rDiscount' cannot be null.");
        else if (rDiscount !== undefined)
            url_ += "rDiscount=" + encodeURIComponent("" + rDiscount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSumRefund(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSumRefund(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSumRefund(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 批量删除Activity的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateActivityInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Activity/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ActivityListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityListDto.fromJS(resultData200) : new ActivityListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetActivityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityForEditOutput.fromJS(resultData200) : new GetActivityForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetActivitysInput | undefined): Observable<PagedResultDtoOfActivityListDto> {
        let url_ = this.baseUrl + "/api/services/app/Activity/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityListDto.fromJS(resultData200) : new PagedResultDtoOfActivityListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityListDto>(<any>null);
    }
}

@Injectable()
export class HistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 过闸统计
     * @param queryData (optional) Device.DeviceName 设备名称,TicketClassify 票型, CreatorUserId 操作员ID，CreationTime 检票时间
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param ticketId (optional) 票型ID
     * @return Success
     */
    getPagedStat(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, ticketId: string | undefined): Observable<PagedResultDtoOfGateHistoryResultDto> {
        let url_ = this.baseUrl + "/api/CheckTicket/History/GetPagedStat?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedStat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedStat(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGateHistoryResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGateHistoryResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedStat(response: HttpResponseBase): Observable<PagedResultDtoOfGateHistoryResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGateHistoryResultDto.fromJS(resultData200) : new PagedResultDtoOfGateHistoryResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGateHistoryResultDto>(<any>null);
    }
}

@Injectable()
export class CheckTicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 二维码验票
     * @param gateNumber (optional) 
     * @param jqmpass (optional) 
     * @param rdindex (optional) 
     * @return Success
     */
    scancodeopen(gateNumber: string | undefined, jqmpass: string | undefined, rdindex: string | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/Scancodeopen?";
        if (gateNumber === null)
            throw new Error("The parameter 'gateNumber' cannot be null.");
        else if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass === null)
            throw new Error("The parameter 'jqmpass' cannot be null.");
        else if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex === null)
            throw new Error("The parameter 'rdindex' cannot be null.");
        else if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processScancodeopen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processScancodeopen(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processScancodeopen(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 二维码验票(一人一票)
     * @param gateNumber (optional) 设备号
     * @param jqmpass (optional) 卡号
     * @param rdindex (optional) 串口号
     * @return Success
     */
    testScancodeopenGet(gateNumber: string | undefined, jqmpass: string | undefined, rdindex: string | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/TestScancodeopen?";
        if (gateNumber === null)
            throw new Error("The parameter 'gateNumber' cannot be null.");
        else if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass === null)
            throw new Error("The parameter 'jqmpass' cannot be null.");
        else if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex === null)
            throw new Error("The parameter 'rdindex' cannot be null.");
        else if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestScancodeopenGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestScancodeopenGet(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processTestScancodeopenGet(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 二维码验票(一人一票)
     * @param gateNumber (optional) 设备号
     * @param jqmpass (optional) 卡号
     * @param rdindex (optional) 串口号
     * @return Success
     */
    testScancodeopenPost(gateNumber: string | undefined, jqmpass: string | undefined, rdindex: string | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/TestScancodeopen?";
        if (gateNumber === null)
            throw new Error("The parameter 'gateNumber' cannot be null.");
        else if (gateNumber !== undefined)
            url_ += "gateNumber=" + encodeURIComponent("" + gateNumber) + "&"; 
        if (jqmpass === null)
            throw new Error("The parameter 'jqmpass' cannot be null.");
        else if (jqmpass !== undefined)
            url_ += "jqmpass=" + encodeURIComponent("" + jqmpass) + "&"; 
        if (rdindex === null)
            throw new Error("The parameter 'rdindex' cannot be null.");
        else if (rdindex !== undefined)
            url_ += "rdindex=" + encodeURIComponent("" + rdindex) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestScancodeopenPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestScancodeopenPost(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processTestScancodeopenPost(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }

    /**
     * 根据票据Id验票
     * @param qrcode (optional) 
     * @param ticketNo (optional) 
     * @param ticketdetailId (optional) 
     * @return Success
     */
    ticketDetailIdOpen(qrcode: string | undefined, ticketNo: string | undefined, ticketdetailId: number | undefined): Observable<CheckResult> {
        let url_ = this.baseUrl + "/api/CheckTicket/TicketDetailIdOpen?";
        if (qrcode === null)
            throw new Error("The parameter 'qrcode' cannot be null.");
        else if (qrcode !== undefined)
            url_ += "qrcode=" + encodeURIComponent("" + qrcode) + "&"; 
        if (ticketNo === null)
            throw new Error("The parameter 'ticketNo' cannot be null.");
        else if (ticketNo !== undefined)
            url_ += "ticketNo=" + encodeURIComponent("" + ticketNo) + "&"; 
        if (ticketdetailId === null)
            throw new Error("The parameter 'ticketdetailId' cannot be null.");
        else if (ticketdetailId !== undefined)
            url_ += "ticketdetailId=" + encodeURIComponent("" + ticketdetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTicketDetailIdOpen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTicketDetailIdOpen(<any>response_);
                } catch (e) {
                    return <Observable<CheckResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckResult>><any>_observableThrow(response_);
        }));
    }

    protected processTicketDetailIdOpen(response: HttpResponseBase): Observable<CheckResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckResult.fromJS(resultData200) : new CheckResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckResult>(<any>null);
    }
}

@Injectable()
export class FileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    downloadFilePathFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadFilePathFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadFilePathFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadFilePathFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadFilePathFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    downloadTempFile(fileName: string, fileType: string, fileToken: string): Observable<void> {
        let url_ = this.baseUrl + "/api/File/DownloadTempFile?";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined and cannot be null.");
        else
            url_ += "fileName=" + encodeURIComponent("" + fileName) + "&"; 
        if (fileType === undefined || fileType === null)
            throw new Error("The parameter 'fileType' must be defined and cannot be null.");
        else
            url_ += "fileType=" + encodeURIComponent("" + fileType) + "&"; 
        if (fileToken === undefined || fileToken === null)
            throw new Error("The parameter 'fileToken' must be defined and cannot be null.");
        else
            url_ += "fileToken=" + encodeURIComponent("" + fileToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadTempFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadTempFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadTempFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 上传音频文件
     * @param body (optional) 
     * @return Success
     */
    uploadImage(body: Blob | undefined): Observable<AudioResultDto> {
        let url_ = this.baseUrl + "/api/File/UploadImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(<any>response_);
                } catch (e) {
                    return <Observable<AudioResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AudioResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<AudioResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AudioResultDto.fromJS(resultData200) : new AudioResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AudioResultDto>(<any>null);
    }
}

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonate(body: ImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * 重置密码
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AccountDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除AccountDetail的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateAccountDetailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取AccountDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AccountDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AccountDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AccountDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountDetailListDto.fromJS(resultData200) : new AccountDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountDetailListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetAccountDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetAccountDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAccountDetailForEditOutput.fromJS(resultData200) : new GetAccountDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountDetailForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAccountDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/AccountDetail/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfAccountDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountDetailListDto.fromJS(resultData200) : new PagedResultDtoOfAccountDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountDetailListDto>(<any>null);
    }
}

@Injectable()
export class ActivityDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ActivityDetail的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateActivityDetailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ActivityDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityDetailListDto.fromJS(resultData200) : new ActivityDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityDetailListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetActivityDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityDetailForEditOutput.fromJS(resultData200) : new GetActivityDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityDetailForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityDetail/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityDetailListDto.fromJS(resultData200) : new PagedResultDtoOfActivityDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityDetailListDto>(<any>null);
    }
}

@Injectable()
export class ActivityTempServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ActivityTemp的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateActivityTempInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityTempListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ActivityTempListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityTempListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityTempListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityTempListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityTempListDto.fromJS(resultData200) : new ActivityTempListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTempListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetActivityTempForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityTempForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityTempForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityTempForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityTempForEditOutput.fromJS(resultData200) : new GetActivityTempForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityTempForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityTempListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTemp/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityTempListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityTempListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityTempListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityTempListDto.fromJS(resultData200) : new PagedResultDtoOfActivityTempListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityTempListDto>(<any>null);
    }
}

@Injectable()
export class ActivityTempDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ActivityTempDetail的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateActivityTempDetailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ActivityTempDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ActivityTempDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ActivityTempDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityTempDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ActivityTempDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityTempDetailListDto.fromJS(resultData200) : new ActivityTempDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityTempDetailListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetActivityTempDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetActivityTempDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetActivityTempDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetActivityTempDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetActivityTempDetailForEditOutput.fromJS(resultData200) : new GetActivityTempDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetActivityTempDetailForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfActivityTempDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/ActivityTempDetail/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivityTempDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivityTempDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfActivityTempDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivityTempDetailListDto.fromJS(resultData200) : new PagedResultDtoOfActivityTempDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivityTempDetailListDto>(<any>null);
    }
}

@Injectable()
export class AddressLinkageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取所有数据
     * @return Success
     */
    getAll(): Observable<AllAddressLinkage> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<AllAddressLinkage>><any>_observableThrow(e);
                }
            } else
                return <Observable<AllAddressLinkage>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<AllAddressLinkage> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AllAddressLinkage.fromJS(resultData200) : new AllAddressLinkage();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AllAddressLinkage>(<any>null);
    }

    /**
     * 获取所有县数据
     * @return Success
     */
    getAllArea(): Observable<AddressAreaDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetAllArea";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllArea(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllArea(<any>response_);
                } catch (e) {
                    return <Observable<AddressAreaDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressAreaDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllArea(response: HttpResponseBase): Observable<AddressAreaDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressAreaDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressAreaDto[]>(<any>null);
    }

    /**
     * 获取所有市数据
     * @return Success
     */
    getAllCity(): Observable<AddressCityDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetAllCity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCity(<any>response_);
                } catch (e) {
                    return <Observable<AddressCityDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressCityDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCity(response: HttpResponseBase): Observable<AddressCityDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressCityDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressCityDto[]>(<any>null);
    }

    /**
     * 获取所有镇数据
     * @return Success
     */
    getAllStreet(): Observable<AddressStreetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetAllStreet";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllStreet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllStreet(<any>response_);
                } catch (e) {
                    return <Observable<AddressStreetDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressStreetDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllStreet(response: HttpResponseBase): Observable<AddressStreetDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressStreetDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressStreetDto[]>(<any>null);
    }

    /**
     * 通过code获取省市区县镇名称（没有code传空）
     * @param provinceCode (optional) 
     * @param cityCode (optional) 
     * @param areaCode (optional) 
     * @param streetCode (optional) 
     * @return Success
     */
    getByCode(provinceCode: string | undefined, cityCode: string | undefined, areaCode: string | undefined, streetCode: string | undefined): Observable<GetByCodeOutput> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetByCode?";
        if (provinceCode === null)
            throw new Error("The parameter 'provinceCode' cannot be null.");
        else if (provinceCode !== undefined)
            url_ += "provinceCode=" + encodeURIComponent("" + provinceCode) + "&"; 
        if (cityCode === null)
            throw new Error("The parameter 'cityCode' cannot be null.");
        else if (cityCode !== undefined)
            url_ += "cityCode=" + encodeURIComponent("" + cityCode) + "&"; 
        if (areaCode === null)
            throw new Error("The parameter 'areaCode' cannot be null.");
        else if (areaCode !== undefined)
            url_ += "areaCode=" + encodeURIComponent("" + areaCode) + "&"; 
        if (streetCode === null)
            throw new Error("The parameter 'streetCode' cannot be null.");
        else if (streetCode !== undefined)
            url_ += "streetCode=" + encodeURIComponent("" + streetCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCode(<any>response_);
                } catch (e) {
                    return <Observable<GetByCodeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetByCodeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCode(response: HttpResponseBase): Observable<GetByCodeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetByCodeOutput.fromJS(resultData200) : new GetByCodeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetByCodeOutput>(<any>null);
    }

    /**
     * 通过父级code获取省市区县镇数据
     * @param parentCode (optional) 父级code
     * @return Success
     */
    getByParentCode(addressEnum: AddressEnum, parentCode: string | undefined): Observable<AddressProvincetDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AddressLinkage/GetByParentCode?";
        if (addressEnum === undefined || addressEnum === null)
            throw new Error("The parameter 'addressEnum' must be defined and cannot be null.");
        else
            url_ += "addressEnum=" + encodeURIComponent("" + addressEnum) + "&"; 
        if (parentCode === null)
            throw new Error("The parameter 'parentCode' cannot be null.");
        else if (parentCode !== undefined)
            url_ += "parentCode=" + encodeURIComponent("" + parentCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByParentCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByParentCode(<any>response_);
                } catch (e) {
                    return <Observable<AddressProvincetDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressProvincetDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByParentCode(response: HttpResponseBase): Observable<AddressProvincetDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(AddressProvincetDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressProvincetDto[]>(<any>null);
    }
}

@Injectable()
export class AppVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除AppVersion的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateAppVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取AppVersionListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AppVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AppVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AppVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppVersionListDto.fromJS(resultData200) : new AppVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppVersionListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetAppVersionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAppVersionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAppVersionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetAppVersionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAppVersionForEditOutput.fromJS(resultData200) : new GetAppVersionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAppVersionForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAppVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAppVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAppVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfAppVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAppVersionListDto.fromJS(resultData200) : new PagedResultDtoOfAppVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAppVersionListDto>(<any>null);
    }

    /**
     * 导出为excel文件
     * @return Success
     */
    getToExcelFile(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AppVersion/GetToExcelFile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToExcelFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToExcelFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetToExcelFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据ID查询操作日志详情
     * @param id (optional) 
     * @return Success
     */
    getAuditLogsInfoById(id: number | undefined): Observable<AuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsInfoById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsInfoById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsInfoById(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsInfoById(response: HttpResponseBase): Observable<AuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuditLogListDto.fromJS(resultData200) : new AuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "entityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "entityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * 根据ID查询登录日志异常
     * @param id (optional) 
     * @return Success
     */
    getLoginLogInfoByIf(id: number | undefined): Observable<LoginLogExceptionDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetLoginLogInfoByIf?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoginLogInfoByIf(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoginLogInfoByIf(<any>response_);
                } catch (e) {
                    return <Observable<LoginLogExceptionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginLogExceptionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoginLogInfoByIf(response: HttpResponseBase): Observable<LoginLogExceptionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginLogExceptionDto.fromJS(resultData200) : new LoginLogExceptionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginLogExceptionDto>(<any>null);
    }

    /**
     * 操作日志查询
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 用户名
     * @param serviceName (optional) 服务名称
     * @param methodName (optional) 方法名称
     * @param browserInfo (optional) 浏览器信息
     * @param hasException (optional) 是否包含异常
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedAuditLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetPagedAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "serviceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "methodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "browserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "minExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "maxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * 登录日志查询
     * @param startDate (optional) 开始时间
     * @param endDate (optional) 结束时间
     * @param userName (optional) 登录用户名或邮箱
     * @param sourceName (optional) 登录端
     * @param sourceCode (optional) 登录端编码
     * @param clientIpAddress (optional) IP地址
     * @param hasException (optional) 是否包含异常
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedLoginLogs(startDate: moment.Moment | undefined, endDate: moment.Moment | undefined, userName: string | undefined, sourceName: string | undefined, sourceCode: string | undefined, clientIpAddress: string | undefined, hasException: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLoginLogModel> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetPagedLoginLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&"; 
        if (sourceName === null)
            throw new Error("The parameter 'sourceName' cannot be null.");
        else if (sourceName !== undefined)
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (sourceCode === null)
            throw new Error("The parameter 'sourceCode' cannot be null.");
        else if (sourceCode !== undefined)
            url_ += "sourceCode=" + encodeURIComponent("" + sourceCode) + "&"; 
        if (clientIpAddress === null)
            throw new Error("The parameter 'clientIpAddress' cannot be null.");
        else if (clientIpAddress !== undefined)
            url_ += "clientIpAddress=" + encodeURIComponent("" + clientIpAddress) + "&"; 
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "hasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedLoginLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedLoginLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLoginLogModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLoginLogModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedLoginLogs(response: HttpResponseBase): Observable<PagedResultDtoOfLoginLogModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLoginLogModel.fromJS(resultData200) : new PagedResultDtoOfLoginLogModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLoginLogModel>(<any>null);
    }
}

@Injectable()
export class BranchServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Branch的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateBranchInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Branch/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BranchListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<BranchListDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BranchListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BranchListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BranchListDto.fromJS(resultData200) : new BranchListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetBranchForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetBranchForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchForEditOutput.fromJS(resultData200) : new GetBranchForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBranchListDto> {
        let url_ = this.baseUrl + "/api/services/app/Branch/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBranchListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBranchListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfBranchListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBranchListDto.fromJS(resultData200) : new PagedResultDtoOfBranchListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBranchListDto>(<any>null);
    }
}

@Injectable()
export class BranchListExcelExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToExcel(body: BranchListDto[] | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchListExcelExporter/ExportToExcel";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BranchUserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除BranchUser的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateBranchUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取BranchUserListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<BranchUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BranchUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<BranchUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BranchUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? BranchUserListDto.fromJS(resultData200) : new BranchUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BranchUserListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetBranchUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBranchUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBranchUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetBranchUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetBranchUserForEditOutput.fromJS(resultData200) : new GetBranchUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBranchUserForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfBranchUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/BranchUser/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBranchUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBranchUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfBranchUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfBranchUserListDto.fromJS(resultData200) : new PagedResultDtoOfBranchUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBranchUserListDto>(<any>null);
    }
}

@Injectable()
export class CheckRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除CheckRecord的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateCheckRecordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取CheckRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CheckRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CheckRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CheckRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckRecordListDto.fromJS(resultData200) : new CheckRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckRecordListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetCheckRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCheckRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCheckRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetCheckRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCheckRecordForEditOutput.fromJS(resultData200) : new GetCheckRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCheckRecordForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfCheckRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/CheckRecord/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCheckRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCheckRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfCheckRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCheckRecordListDto.fromJS(resultData200) : new PagedResultDtoOfCheckRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCheckRecordListDto>(<any>null);
    }
}

@Injectable()
export class ClientVersionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ClientVersion的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateClientVersionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ClientVersionListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ClientVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ClientVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClientVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ClientVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ClientVersionListDto.fromJS(resultData200) : new ClientVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClientVersionListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetClientVersionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetClientVersionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetClientVersionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetClientVersionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetClientVersionForEditOutput.fromJS(resultData200) : new GetClientVersionForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetClientVersionForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfClientVersionListDto> {
        let url_ = this.baseUrl + "/api/services/app/ClientVersion/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfClientVersionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfClientVersionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfClientVersionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfClientVersionListDto.fromJS(resultData200) : new PagedResultDtoOfClientVersionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfClientVersionListDto>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: CommonLookupFindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @return Success
     */
    getValidateCodeTypesForCombobox(): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetValidateCodeTypesForCombobox";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetValidateCodeTypesForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetValidateCodeTypesForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfComboboxItemDtoTOfInt32>><any>_observableThrow(response_);
        }));
    }

    protected processGetValidateCodeTypesForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfComboboxItemDtoTOfInt32> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfComboboxItemDtoTOfInt32.fromJS(resultData200) : new ListResultDtoOfComboboxItemDtoTOfInt32();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfComboboxItemDtoTOfInt32>(<any>null);
    }
}

@Injectable()
export class CustomerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Customer的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateCustomerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据证件ID查询客户，如果客户存在，则返回客户信息
     * @param identity (optional) 
     * @return Success
     */
    exists(identity: string | undefined): Observable<CustomerExistsDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/Exists?";
        if (identity === null)
            throw new Error("The parameter 'identity' cannot be null.");
        else if (identity !== undefined)
            url_ += "identity=" + encodeURIComponent("" + identity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExists(<any>response_);
                } catch (e) {
                    return <Observable<CustomerExistsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerExistsDto>><any>_observableThrow(response_);
        }));
    }

    protected processExists(response: HttpResponseBase): Observable<CustomerExistsDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerExistsDto.fromJS(resultData200) : new CustomerExistsDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerExistsDto>(<any>null);
    }

    /**
     * 通过指定id获取CustomerListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<CustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CustomerListDto.fromJS(resultData200) : new CustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetCustomerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetCustomerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCustomerForEditOutput.fromJS(resultData200) : new GetCustomerForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 传入参数
     * @return Success
     */
    getPaged(body: GetCustomersInput | undefined): Observable<PagedResultDtoOfCustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCustomerListDto.fromJS(resultData200) : new PagedResultDtoOfCustomerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerListDto>(<any>null);
    }

    /**
     * 上传客户照片
     * @param body (optional) 
     * @return Success
     */
    userPicture(body: Blob | undefined): Observable<UploadUserPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UserPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPicture(<any>response_);
                } catch (e) {
                    return <Observable<UploadUserPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadUserPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUserPicture(response: HttpResponseBase): Observable<UploadUserPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadUserPictureResultDto.fromJS(resultData200) : new UploadUserPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadUserPictureResultDto>(<any>null);
    }

    /**
     * 上传客户照片
     * @param body (optional) 
     * @return Success
     */
    userPictureBase64(body: UploadUserPictureDto | undefined): Observable<UploadUserPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Customer/UserPictureBase64";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUserPictureBase64(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUserPictureBase64(<any>response_);
                } catch (e) {
                    return <Observable<UploadUserPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadUserPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUserPictureBase64(response: HttpResponseBase): Observable<UploadUserPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadUserPictureResultDto.fromJS(resultData200) : new UploadUserPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadUserPictureResultDto>(<any>null);
    }
}

@Injectable()
export class DateDictionaryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除DateDictionary的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateDateDictionaryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取DateDictionaryListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DateDictionaryListDto> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DateDictionaryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateDictionaryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DateDictionaryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateDictionaryListDto.fromJS(resultData200) : new DateDictionaryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateDictionaryListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetDateDictionaryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDateDictionaryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDateDictionaryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetDateDictionaryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDateDictionaryForEditOutput.fromJS(resultData200) : new GetDateDictionaryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDateDictionaryForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfDateDictionaryListDto> {
        let url_ = this.baseUrl + "/api/services/app/DateDictionary/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDateDictionaryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDateDictionaryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfDateDictionaryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDateDictionaryListDto.fromJS(resultData200) : new PagedResultDtoOfDateDictionaryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDateDictionaryListDto>(<any>null);
    }
}

@Injectable()
export class DeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Device的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateDeviceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Device/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取DeviceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<DeviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<DeviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<DeviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<DeviceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DeviceListDto.fromJS(resultData200) : new DeviceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DeviceListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetDeviceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetDeviceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDeviceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetDeviceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDeviceForEditOutput.fromJS(resultData200) : new GetDeviceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDeviceForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetDevicesInput | undefined): Observable<PagedResultDtoOfDeviceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Device/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfDeviceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfDeviceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfDeviceListDto.fromJS(resultData200) : new PagedResultDtoOfDeviceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfDeviceListDto>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateEdition(body: CreateOrUpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EmployeeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Employee的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateEmployeeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Employee/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取EmployeeListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<EmployeeListDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<EmployeeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EmployeeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<EmployeeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EmployeeListDto.fromJS(resultData200) : new EmployeeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EmployeeListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetEmployeeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEmployeeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEmployeeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetEmployeeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEmployeeForEditOutput.fromJS(resultData200) : new GetEmployeeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEmployeeForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetEmployeesInput | undefined): Observable<PagedResultDtoOfEmployeeListDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEmployeeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEmployeeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfEmployeeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEmployeeListDto.fromJS(resultData200) : new PagedResultDtoOfEmployeeListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEmployeeListDto>(<any>null);
    }

    /**
     * 上传员工照片
     * @param body (optional) 
     * @return Success
     */
    uploadPictures(body: Blob | undefined): Observable<UploadEmployeeResultDto> {
        let url_ = this.baseUrl + "/api/services/app/Employee/UploadPictures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadPictures(<any>response_);
                } catch (e) {
                    return <Observable<UploadEmployeeResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadEmployeeResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUploadPictures(response: HttpResponseBase): Observable<UploadEmployeeResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadEmployeeResultDto.fromJS(resultData200) : new UploadEmployeeResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadEmployeeResultDto>(<any>null);
    }
}

@Injectable()
export class FaceSwipingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除FaceSwiping的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateFaceSwipingInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取FaceSwipingListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<FaceSwipingListDto> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FaceSwipingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FaceSwipingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FaceSwipingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FaceSwipingListDto.fromJS(resultData200) : new FaceSwipingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FaceSwipingListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetFaceSwipingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetFaceSwipingForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetFaceSwipingForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetFaceSwipingForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetFaceSwipingForEditOutput.fromJS(resultData200) : new GetFaceSwipingForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetFaceSwipingForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetFaceSwipingsInput | undefined): Observable<PagedResultDtoOfFaceSwipingListDto> {
        let url_ = this.baseUrl + "/api/services/app/FaceSwiping/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfFaceSwipingListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfFaceSwipingListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfFaceSwipingListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfFaceSwipingListDto.fromJS(resultData200) : new PagedResultDtoOfFaceSwipingListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfFaceSwipingListDto>(<any>null);
    }
}

@Injectable()
export class GateRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除GateRecord的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateGateRecordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取GateRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<GateRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<GateRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GateRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<GateRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GateRecordListDto.fromJS(resultData200) : new GateRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GateRecordListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetGateRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetGateRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGateRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetGateRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGateRecordForEditOutput.fromJS(resultData200) : new GetGateRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGateRecordForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetGateRecordsInput | undefined): Observable<PagedResultDtoOfGateRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/GateRecord/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGateRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGateRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfGateRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGateRecordListDto.fromJS(resultData200) : new PagedResultDtoOfGateRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGateRecordListDto>(<any>null);
    }
}

@Injectable()
export class HostCachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfHostCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/HostCaching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfHostCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfHostCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfHostCacheDto.fromJS(resultData200) : new ListResultDtoOfHostCacheDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfHostCacheDto>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class InvalidUserExporterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exportToFile(body: ImportUserDto[] | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/InvalidUserExporter/ExportToFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExportToFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExportToFile(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processExportToFile(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param sourceName 语言名称
     * @param baseLanguageName (optional) 原语言名称
     * @param targetLanguageName 目标语言名称
     * @param targetValueFilter (optional) 目标值过滤
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getLanguageTexts(sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "sourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "baseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "targetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "targetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 修改语言的文本内容
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class MemberServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Member的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateMemberInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Member/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取MemberListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<MemberListDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<MemberListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MemberListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MemberListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MemberListDto.fromJS(resultData200) : new MemberListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MemberListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetMemberForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetMemberForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberForEditOutput.fromJS(resultData200) : new GetMemberForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMemberListDto> {
        let url_ = this.baseUrl + "/api/services/app/Member/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMemberListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMemberListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMemberListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMemberListDto.fromJS(resultData200) : new PagedResultDtoOfMemberListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMemberListDto>(<any>null);
    }
}

@Injectable()
export class MenuServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Menu的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改Menu的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateMenuInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除Menu信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Menu/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取MenuListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<MenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<MenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<MenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MenuListDto.fromJS(resultData200) : new MenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuListDto>(<any>null);
    }

    /**
     * 获取编辑 Menu
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetMenuForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMenuForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMenuForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetMenuForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMenuForEditOutput.fromJS(resultData200) : new GetMenuForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMenuForEditOutput>(<any>null);
    }

    /**
     * 查询菜单下拉树
     * @return Success
     */
    getMenuDropDown(): Observable<MenuDropDownDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetMenuDropDown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuDropDown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuDropDown(<any>response_);
                } catch (e) {
                    return <Observable<MenuDropDownDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuDropDownDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuDropDown(response: HttpResponseBase): Observable<MenuDropDownDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MenuDropDownDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuDropDownDto[]>(<any>null);
    }

    /**
     * 查询菜单树
     * @return Success
     */
    getMenuTree(): Observable<MenuTreeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetMenuTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuTree(<any>response_);
                } catch (e) {
                    return <Observable<MenuTreeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<MenuTreeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuTree(response: HttpResponseBase): Observable<MenuTreeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(MenuTreeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MenuTreeDto[]>(<any>null);
    }

    /**
     * 获取Menu的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuListDto.fromJS(resultData200) : new PagedResultDtoOfMenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuListDto>(<any>null);
    }

    /**
     * 获取Menu的分页列表信息--Get方法
     * @param queryData (optional) MenuName,MenuCode,NavigateUrl,ParentId,IsEnabled
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedForGet(queryData: string | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfMenuListDto> {
        let url_ = this.baseUrl + "/api/services/app/Menu/GetPagedForGet?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            url_ += "queryData=" + encodeURIComponent("" + queryData) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedForGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedForGet(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMenuListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedForGet(response: HttpResponseBase): Observable<PagedResultDtoOfMenuListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMenuListDto.fromJS(resultData200) : new PagedResultDtoOfMenuListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMenuListDto>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 删除通知
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param state (optional) 是否阅读枚举 0是未读 1是已经阅读
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedUserNotifications(state: UserNotificationState | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetPagedUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    makeAllUserNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/MakeAllUserNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeAllUserNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeAllUserNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeAllUserNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    makeNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/MakeNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMakeNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMakeNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMakeNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新消息设置
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Organization的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Organization/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateOrganizationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Organization/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Organization/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取OrganizationListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<OrganizationListDto> {
        let url_ = this.baseUrl + "/api/services/app/Organization/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OrganizationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationListDto.fromJS(resultData200) : new OrganizationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetOrganizationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Organization/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOrganizationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetOrganizationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetOrganizationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOrganizationForEditOutput.fromJS(resultData200) : new GetOrganizationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetOrganizationForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 传入参数
     * @return Success
     */
    getPaged(body: GetOrganizationsInput | undefined): Observable<PagedResultDtoOfOrganizationListDto> {
        let url_ = this.baseUrl + "/api/services/app/Organization/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationListDto>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 添加角色 组织关联
     * @param body (optional) 
     * @return Success
     */
    addRoles(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRoles(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRoles(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsers(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsers(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsers(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量从组织中移除角色
     * @param organizationUnitId (optional) 
     * @param body (optional) 
     * @return Success
     */
    batchRemoveRoleFromOrganizationUnit(organizationUnitId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/BatchRemoveRoleFromOrganizationUnit?";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量从组织中移除用户
     * @param organizationUnitId (optional) 组织机构Id
     * @param body (optional) 用户Id列表
     * @return Success
     */
    batchRemoveUserFromOrganizationUnit(organizationUnitId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/BatchRemoveUserFromOrganizationUnit?";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllOrganizationUnitList(): Observable<ListResultDtoOfOrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAllOrganizationUnitList";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitList(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOrganizationUnitList(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitListDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitListDto>(<any>null);
    }

    /**
     * 获取角色列表
     * @param id (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedOrganizationUnitRoles(id: number | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetPagedOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPagedOrganizationUnitUsers(id: number | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetPagedOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isInOrganizationUnit(body: UserToOrganizationUnitInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/IsInOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsInOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsInOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    move(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Move";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMove(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processMove(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }

    /**
     * 删除 角色 组织关联
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRole(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRole?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUser(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "organizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 判断角色是否在当前组织
     * @param body (optional) 
     * @return Success
     */
    rolesIsInOrganizationUnit(body: RoleToOrganizationUnitInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RolesIsInOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRolesIsInOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRolesIsInOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRolesIsInOrganizationUnit(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitListDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<OrganizationUnitListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitListDto.fromJS(resultData200) : new OrganizationUnitListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitListDto>(<any>null);
    }
}

@Injectable()
export class PayMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除PayMethod的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdatePayMethodInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PayMethodListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PayMethodListDto> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PayMethodListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayMethodListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PayMethodListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PayMethodListDto.fromJS(resultData200) : new PayMethodListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayMethodListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetPayMethodForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPayMethodForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPayMethodForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPayMethodForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPayMethodForEditOutput.fromJS(resultData200) : new GetPayMethodForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPayMethodForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPayMethodListDto> {
        let url_ = this.baseUrl + "/api/services/app/PayMethod/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPayMethodListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPayMethodListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPayMethodListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPayMethodListDto.fromJS(resultData200) : new PagedResultDtoOfPayMethodListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPayMethodListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllPermissionsTree(): Observable<ListResultDtoOfTreePermissionDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissionsTree";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissionsTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissionsTree(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfTreePermissionDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfTreePermissionDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissionsTree(response: HttpResponseBase): Observable<ListResultDtoOfTreePermissionDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfTreePermissionDto.fromJS(resultData200) : new ListResultDtoOfTreePermissionDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfTreePermissionDto>(<any>null);
    }
}

@Injectable()
export class PowerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量增加权限
     * @param menuId (optional) 菜单Id
     * @param body (optional) 
     * @return Success
     */
    batchCreate(menuId: number | undefined, body: string[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/BatchCreate?";
        if (menuId === null)
            throw new Error("The parameter 'menuId' cannot be null.");
        else if (menuId !== undefined)
            url_ += "menuId=" + encodeURIComponent("" + menuId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除Power的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdatePowerInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Power/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PowerListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PowerListDto.fromJS(resultData200) : new PowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetPowerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPowerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPowerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPowerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPowerForEditOutput.fromJS(resultData200) : new GetPowerForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPowerForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param queryData (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Power/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerListDto.fromJS(resultData200) : new PagedResultDtoOfPowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerListDto>(<any>null);
    }
}

@Injectable()
export class PowerRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 根据角色ID修改权限
     * @param roleId (optional) 角色ID
     * @param body (optional) 权限ID列表
     * @return Success
     */
    batchAddOrUpdate(roleId: number | undefined, body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/BatchAddOrUpdate?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchAddOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchAddOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchAddOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 批量删除PowerRole的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdatePowerRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PowerRoleListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PowerRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PowerRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PowerRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PowerRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PowerRoleListDto.fromJS(resultData200) : new PowerRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PowerRoleListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetPowerRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPowerRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPowerRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPowerRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPowerRoleForEditOutput.fromJS(resultData200) : new GetPowerRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPowerRoleForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param queryData (optional) User.XX,Branch.XX
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPowerRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPowerRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerRoleListDto.fromJS(resultData200) : new PagedResultDtoOfPowerRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerRoleListDto>(<any>null);
    }

    /**
     * 根据角色ID查询权限信息
    IsCheck表示是否勾选
     * @param roleId (optional) 角色ID
     * @return Success
     */
    getPowerRoleListById(roleId: number | undefined): Observable<PagedResultDtoOfPowerListDto> {
        let url_ = this.baseUrl + "/api/services/app/PowerRole/GetPowerRoleListById?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPowerRoleListById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPowerRoleListById(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPowerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPowerRoleListById(response: HttpResponseBase): Observable<PagedResultDtoOfPowerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPowerListDto.fromJS(resultData200) : new PagedResultDtoOfPowerListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPowerListDto>(<any>null);
    }
}

@Injectable()
export class PriceAuditServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除PriceAudit的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdatePriceAuditInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PriceAuditListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PriceAuditListDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PriceAuditListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PriceAuditListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PriceAuditListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PriceAuditListDto.fromJS(resultData200) : new PriceAuditListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PriceAuditListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetPriceAuditForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPriceAuditForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPriceAuditForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPriceAuditForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPriceAuditForEditOutput.fromJS(resultData200) : new GetPriceAuditForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPriceAuditForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPriceAuditListDto> {
        let url_ = this.baseUrl + "/api/services/app/PriceAudit/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPriceAuditListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPriceAuditListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPriceAuditListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPriceAuditListDto.fromJS(resultData200) : new PagedResultDtoOfPriceAuditListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPriceAuditListDto>(<any>null);
    }
}

@Injectable()
export class PrintElementServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除PrintElement的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdatePrintElementInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取PrintElementListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<PrintElementListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PrintElementListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PrintElementListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PrintElementListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PrintElementListDto.fromJS(resultData200) : new PrintElementListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PrintElementListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetPrintElementForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetPrintElementForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPrintElementForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetPrintElementForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPrintElementForEditOutput.fromJS(resultData200) : new GetPrintElementForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPrintElementForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfPrintElementListDto> {
        let url_ = this.baseUrl + "/api/services/app/PrintElement/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfPrintElementListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfPrintElementListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfPrintElementListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfPrintElementListDto.fromJS(resultData200) : new PagedResultDtoOfPrintElementListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfPrintElementListDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除用户头像
     * @param profilePictureId (optional) 头像ID
     * @return Success
     */
    deleteProfilePictureById(profilePictureId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DeleteProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProfilePictureById(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取当前的个人信息
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | undefined): Observable<GetProfilePictureOutputDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId === null)
            throw new Error("The parameter 'profilePictureId' cannot be null.");
        else if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutputDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutputDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutputDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutputDto.fromJS(resultData200) : new GetProfilePictureOutputDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutputDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PurchaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPay(body: PurchasePayInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Purchase/CreatePay";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePay(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePay(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class RechargeRecordServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除RechargeRecord的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateRechargeRecordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取RechargeRecordListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<RechargeRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<RechargeRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RechargeRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<RechargeRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RechargeRecordListDto.fromJS(resultData200) : new RechargeRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RechargeRecordListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetRechargeRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRechargeRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRechargeRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetRechargeRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRechargeRecordForEditOutput.fromJS(resultData200) : new GetRechargeRecordForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRechargeRecordForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfRechargeRecordListDto> {
        let url_ = this.baseUrl + "/api/services/app/RechargeRecord/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRechargeRecordListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfRechargeRecordListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRechargeRecordListDto.fromJS(resultData200) : new PagedResultDtoOfRechargeRecordListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRechargeRecordListDto>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除角色
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 服务于前端RoleComboxComponent 组件信息，
     * @param permission (optional) 权限名称
     * @return Success
     */
    getAll(permission: string | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetAll?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            url_ += "permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param permissionNames (optional) 权限名称
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(permissionNames: string[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetPaged?";
        if (permissionNames === null)
            throw new Error("The parameter 'permissionNames' cannot be null.");
        else if (permissionNames !== undefined)
            permissionNames && permissionNames.forEach(item => { url_ += "permissionNames=" + encodeURIComponent("" + item) + "&"; });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfRoleListDto.fromJS(resultData200) : new PagedResultDtoOfRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermissions(body: UpdateRolePermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/UpdatePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ScenicSpotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除ScenicSpot的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateScenicSpotInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取ScenicSpotListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<ScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<ScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScenicSpotListDto.fromJS(resultData200) : new ScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ScenicSpotListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetScenicSpotForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetScenicSpotForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetScenicSpotForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetScenicSpotForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetScenicSpotForEditOutput.fromJS(resultData200) : new GetScenicSpotForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetScenicSpotForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/ScenicSpot/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfScenicSpotListDto.fromJS(resultData200) : new PagedResultDtoOfScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfScenicSpotListDto>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getUserConfigurations(): Observable<AbpUserConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetUserConfigurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserConfigurations(<any>response_);
                } catch (e) {
                    return <Observable<AbpUserConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AbpUserConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserConfigurations(response: HttpResponseBase): Observable<AbpUserConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AbpUserConfigurationDto.fromJS(resultData200) : new AbpUserConfigurationDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AbpUserConfigurationDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SettingsAppServiceBaseServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SettingsAppServiceBase/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Source的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateSourceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Source/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取SourceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<SourceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<SourceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SourceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<SourceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SourceListDto.fromJS(resultData200) : new SourceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SourceListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetSourceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSourceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSourceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetSourceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSourceForEditOutput.fromJS(resultData200) : new GetSourceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSourceForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSourceListDto> {
        let url_ = this.baseUrl + "/api/services/app/Source/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSourceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSourceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfSourceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSourceListDto.fromJS(resultData200) : new PagedResultDtoOfSourceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSourceListDto>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: EntityDto[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param subscriptionStart (optional) 
     * @param subscriptionEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(subscriptionStart: moment.Moment | undefined, subscriptionEnd: moment.Moment | undefined, creationDateStart: moment.Moment | undefined, creationDateEnd: moment.Moment | undefined, editionId: number | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetPaged?";
        if (subscriptionStart === null)
            throw new Error("The parameter 'subscriptionStart' cannot be null.");
        else if (subscriptionStart !== undefined)
            url_ += "subscriptionStart=" + encodeURIComponent(subscriptionStart ? "" + subscriptionStart.toJSON() : "") + "&"; 
        if (subscriptionEnd === null)
            throw new Error("The parameter 'subscriptionEnd' cannot be null.");
        else if (subscriptionEnd !== undefined)
            url_ += "subscriptionEnd=" + encodeURIComponent(subscriptionEnd ? "" + subscriptionEnd.toJSON() : "") + "&"; 
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "creationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "creationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 注册租户信息
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: CreateTenantDto | undefined): Observable<RegisterTenantResultDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantResultDto.fromJS(resultData200) : new RegisterTenantResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantResultDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取所有设置
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 更新所有设置
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Ticket的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketListDto.fromJS(resultData200) : new TicketListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketForEditOutput.fromJS(resultData200) : new GetTicketForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketListDto> {
        let url_ = this.baseUrl + "/api/services/app/Ticket/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketListDto.fromJS(resultData200) : new PagedResultDtoOfTicketListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketListDto>(<any>null);
    }
}

@Injectable()
export class TicketAccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除Account的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateAccountInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取AccountListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<AccountListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AccountListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AccountListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccountListDto.fromJS(resultData200) : new AccountListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccountListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetAccountForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAccountForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAccountForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetAccountForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetAccountForEditOutput.fromJS(resultData200) : new GetAccountForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAccountForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAccountListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketAccount/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAccountListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAccountListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfAccountListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAccountListDto.fromJS(resultData200) : new PagedResultDtoOfAccountListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAccountListDto>(<any>null);
    }

    /**
     * @param accounts (optional) 
     * @return Success
     */
    collectAccounts(accounts: number[] | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/TicketAccount/CollectAccounts?";
        if (accounts === null)
            throw new Error("The parameter 'accounts' cannot be null.");
        else if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processCollectAccounts(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param accounts (optional) 
     * @return Success
     */
    rCollectAccounts(accounts: number[] | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/TicketAccount/RCollectAccounts?";
        if (accounts === null)
            throw new Error("The parameter 'accounts' cannot be null.");
        else if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRCollectAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRCollectAccounts(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRCollectAccounts(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param accounts (optional) 
     * @return Success
     */
    rSettleAccount(accounts: number[] | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/TicketAccount/RSettleAccount?";
        if (accounts === null)
            throw new Error("The parameter 'accounts' cannot be null.");
        else if (accounts !== undefined)
            accounts && accounts.forEach(item => { url_ += "accounts=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRSettleAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRSettleAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processRSettleAccount(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * @param activitys (optional) 
     * @return Success
     */
    settleAccount(activitys: number[] | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/TicketAccount/SettleAccount?";
        if (activitys === null)
            throw new Error("The parameter 'activitys' cannot be null.");
        else if (activitys !== undefined)
            activitys && activitys.forEach(item => { url_ += "activitys=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSettleAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSettleAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSettleAccount(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }
}

@Injectable()
export class TicketDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketDetail的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketDetailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketDetailListDto.fromJS(resultData200) : new TicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDetailListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketDetailForEditOutput.fromJS(resultData200) : new GetTicketDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDetailForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetTicketDetailsInput | undefined): Observable<PagedResultDtoOfTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketDetailListDto.fromJS(resultData200) : new PagedResultDtoOfTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketDetailListDto>(<any>null);
    }

    /**
     * 打印票据
     * @param body (optional) 
     * @return Success
     */
    printTicketDetail(body: number[] | undefined): Observable<ActivityResultModel> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/PrintTicketDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrintTicketDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrintTicketDetail(<any>response_);
                } catch (e) {
                    return <Observable<ActivityResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivityResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processPrintTicketDetail(response: HttpResponseBase): Observable<ActivityResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivityResultModel.fromJS(resultData200) : new ActivityResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivityResultModel>(<any>null);
    }

    /**
     * 刷票
     * @param body (optional) 
     * @return Success
     */
    updateTicketStatus(body: TicketDetailEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetail/UpdateTicketStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTicketStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTicketStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTicketStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketDetailHistoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketDetailHistory的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketDetailHistoryInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketDetailHistoryListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketDetailHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketDetailHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketDetailHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketDetailHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketDetailHistoryListDto.fromJS(resultData200) : new TicketDetailHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketDetailHistoryListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketDetailHistoryForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketDetailHistoryForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketDetailHistoryForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketDetailHistoryForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketDetailHistoryForEditOutput.fromJS(resultData200) : new GetTicketDetailHistoryForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketDetailHistoryForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetTicketDetailHistorysInput | undefined): Observable<PagedResultDtoOfTicketDetailHistoryListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketDetailHistory/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketDetailHistoryListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketDetailHistoryListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketDetailHistoryListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketDetailHistoryListDto.fromJS(resultData200) : new PagedResultDtoOfTicketDetailHistoryListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketDetailHistoryListDto>(<any>null);
    }
}

@Injectable()
export class TicketIntroduceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketIntroduce的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketIntroduceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketIntroduceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketIntroduceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketIntroduceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketIntroduceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketIntroduceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketIntroduceListDto.fromJS(resultData200) : new TicketIntroduceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketIntroduceListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketIntroduceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketIntroduceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketIntroduceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketIntroduceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketIntroduceForEditOutput.fromJS(resultData200) : new GetTicketIntroduceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketIntroduceForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketIntroduceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketIntroduce/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketIntroduceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketIntroduceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketIntroduceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketIntroduceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketIntroduceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketIntroduceListDto>(<any>null);
    }
}

@Injectable()
export class TicketLocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketLocation的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketLocationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketLocationListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketLocationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketLocationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketLocationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketLocationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketLocationListDto.fromJS(resultData200) : new TicketLocationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketLocationListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketLocationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketLocationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketLocationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketLocationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketLocationForEditOutput.fromJS(resultData200) : new GetTicketLocationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketLocationForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketLocationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketLocation/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketLocationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketLocationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketLocationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketLocationListDto.fromJS(resultData200) : new PagedResultDtoOfTicketLocationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketLocationListDto>(<any>null);
    }
}

@Injectable()
export class TicketPriceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketPrice的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketPriceInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketPriceListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketPriceListDto.fromJS(resultData200) : new TicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketPriceListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketPriceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketPriceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketPriceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketPriceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketPriceForEditOutput.fromJS(resultData200) : new GetTicketPriceForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketPriceForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param body (optional) 
     * @return Success
     */
    getPaged(body: GetTicketPricesInput | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 散客票价查询
     * @param body (optional) 
     * @return Success
     */
    getPagedCustomer(body: GetTicketPricesInput | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPagedCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedCustomer(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedCustomer(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 团体票价查询
     * @param body (optional) 
     * @return Success
     */
    getPagedGroup(body: GetTicketPricesInput | undefined): Observable<PagedResultDtoOfTicketPriceListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/GetPagedGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedGroup(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketPriceListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedGroup(response: HttpResponseBase): Observable<PagedResultDtoOfTicketPriceListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketPriceListDto.fromJS(resultData200) : new PagedResultDtoOfTicketPriceListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketPriceListDto>(<any>null);
    }

    /**
     * 设置票型价格的启用状态
     * @param ticketPriceId (optional) 票型价格Id
     * @param isEnabled (optional) 启用状态
     * @return Success
     */
    setPriceEnable(ticketPriceId: number | undefined, isEnabled: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketPrice/SetPriceEnable?";
        if (ticketPriceId === null)
            throw new Error("The parameter 'ticketPriceId' cannot be null.");
        else if (ticketPriceId !== undefined)
            url_ += "ticketPriceId=" + encodeURIComponent("" + ticketPriceId) + "&"; 
        if (isEnabled === null)
            throw new Error("The parameter 'isEnabled' cannot be null.");
        else if (isEnabled !== undefined)
            url_ += "isEnabled=" + encodeURIComponent("" + isEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPriceEnable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPriceEnable(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetPriceEnable(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketRoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketRole的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketRoleForEditOutput.fromJS(resultData200) : new GetTicketRoleForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketRoleForEditOutput>(<any>null);
    }

    /**
     * 编辑初始化
     * @param roleId (optional) 
     * @return Success
     */
    getForUpdate(roleId: number | undefined): Observable<GetTicketRoleForUpdateOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetForUpdate?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "roleId=" + encodeURIComponent("" + roleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForUpdate(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketRoleForUpdateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketRoleForUpdateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForUpdate(response: HttpResponseBase): Observable<GetTicketRoleForUpdateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketRoleForUpdateOutput.fromJS(resultData200) : new GetTicketRoleForUpdateOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketRoleForUpdateOutput>(<any>null);
    }

    /**
     * 查询
     * @param rolename (optional) 
     * @param username (optional) 
     * @param ticketname (optional) 
     * @param body (optional) 
     * @return Success
     */
    getPaged(rolename: string | undefined, username: string | undefined, ticketname: string | undefined, body: GetTicketRolesInput | undefined): Observable<PagedResultDtoOfTicketRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/GetPaged?";
        if (rolename === null)
            throw new Error("The parameter 'rolename' cannot be null.");
        else if (rolename !== undefined)
            url_ += "rolename=" + encodeURIComponent("" + rolename) + "&"; 
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        if (ticketname === null)
            throw new Error("The parameter 'ticketname' cannot be null.");
        else if (ticketname !== undefined)
            url_ += "ticketname=" + encodeURIComponent("" + ticketname) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketRoleListDto.fromJS(resultData200) : new PagedResultDtoOfTicketRoleListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketRoleListDto>(<any>null);
    }

    /**
     * 编辑
     * @param body (optional) 
     * @return Success
     */
    update(body: UpdateTicketRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketRole/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TicketScheduleEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketScheduleEnable的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketScheduleEnableInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketScheduleEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketScheduleEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketScheduleEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketScheduleEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketScheduleEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketScheduleEnableListDto.fromJS(resultData200) : new TicketScheduleEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketScheduleEnableListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketScheduleEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketScheduleEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketScheduleEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketScheduleEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketScheduleEnableForEditOutput.fromJS(resultData200) : new GetTicketScheduleEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketScheduleEnableForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketScheduleEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketScheduleEnable/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketScheduleEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketScheduleEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketScheduleEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketScheduleEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketScheduleEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketScheduleEnableListDto>(<any>null);
    }
}

@Injectable()
export class TicketStationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketStation的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketStationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketStationListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketStationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketStationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketStationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketStationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketStationListDto.fromJS(resultData200) : new TicketStationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketStationListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketStationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketStationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketStationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketStationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketStationForEditOutput.fromJS(resultData200) : new GetTicketStationForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketStationForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketStationListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStation/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketStationListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketStationListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketStationListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketStationListDto.fromJS(resultData200) : new PagedResultDtoOfTicketStationListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketStationListDto>(<any>null);
    }
}

@Injectable()
export class TicketStationEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketStationEnable的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketStationEnableInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketStationEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketStationEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketStationEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketStationEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketStationEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketStationEnableListDto.fromJS(resultData200) : new TicketStationEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketStationEnableListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketStationEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketStationEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketStationEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketStationEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketStationEnableForEditOutput.fromJS(resultData200) : new GetTicketStationEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketStationEnableForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketStationEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketStationEnable/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketStationEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketStationEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketStationEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketStationEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketStationEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketStationEnableListDto>(<any>null);
    }
}

@Injectable()
export class TicketUserEnableServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TicketUserEnable的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTicketUserEnableInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TicketUserEnableListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TicketUserEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TicketUserEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TicketUserEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TicketUserEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TicketUserEnableListDto.fromJS(resultData200) : new TicketUserEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TicketUserEnableListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTicketUserEnableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTicketUserEnableForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTicketUserEnableForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTicketUserEnableForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTicketUserEnableForEditOutput.fromJS(resultData200) : new GetTicketUserEnableForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTicketUserEnableForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTicketUserEnableListDto> {
        let url_ = this.baseUrl + "/api/services/app/TicketUserEnable/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTicketUserEnableListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTicketUserEnableListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTicketUserEnableListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTicketUserEnableListDto.fromJS(resultData200) : new PagedResultDtoOfTicketUserEnableListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTicketUserEnableListDto>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "selectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "defaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class TravelAgencyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TravelAgency的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTravelAgencyInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TravelAgencyListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TravelAgencyListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TravelAgencyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TravelAgencyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TravelAgencyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TravelAgencyListDto.fromJS(resultData200) : new TravelAgencyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TravelAgencyListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTravelAgencyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTravelAgencyForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTravelAgencyForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTravelAgencyForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTravelAgencyForEditOutput.fromJS(resultData200) : new GetTravelAgencyForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTravelAgencyForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTravelAgencyListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelAgency/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTravelAgencyListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTravelAgencyListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTravelAgencyListDto.fromJS(resultData200) : new PagedResultDtoOfTravelAgencyListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTravelAgencyListDto>(<any>null);
    }
}

@Injectable()
export class TravelTicketDetailServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除TravelTicketDetail的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateTravelTicketDetailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取TravelTicketDetailListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<TravelTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<TravelTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TravelTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<TravelTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TravelTicketDetailListDto.fromJS(resultData200) : new TravelTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TravelTicketDetailListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetTravelTicketDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTravelTicketDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTravelTicketDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetTravelTicketDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTravelTicketDetailForEditOutput.fromJS(resultData200) : new GetTravelTicketDetailForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTravelTicketDetailForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTravelTicketDetailListDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelTicketDetail/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTravelTicketDetailListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTravelTicketDetailListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfTravelTicketDetailListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTravelTicketDetailListDto.fromJS(resultData200) : new PagedResultDtoOfTravelTicketDetailListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTravelTicketDetailListDto>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除用户
     * @param body (optional) 用户Id列表
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 修改用户信息
     * @param id (optional) 
     * @return Success
     */
    getForEditTree(id: number | undefined): Observable<GetUserForEditTreeOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetForEditTree?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEditTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEditTree(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditTreeOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEditTree(response: HttpResponseBase): Observable<GetUserForEditTreeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditTreeOutput.fromJS(resultData200) : new GetUserForEditTreeOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditTreeOutput>(<any>null);
    }

    /**
     * 分页获取所有用户
     * @param permission (optional) 权限
     * @param role (optional) 检索角色Id列表
     * @param isEmailConfirmed (optional) 是否已验证邮箱
     * @param isActive (optional) 是否已激活
     * @param onlyLockedUsers (optional) 仅被锁定的用户
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(permission: string[] | undefined, role: number[] | undefined, isEmailConfirmed: boolean | undefined, isActive: boolean | undefined, onlyLockedUsers: boolean | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetPaged?";
        if (permission === null)
            throw new Error("The parameter 'permission' cannot be null.");
        else if (permission !== undefined)
            permission && permission.forEach(item => { url_ += "permission=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            role && role.forEach(item => { url_ += "role=" + encodeURIComponent("" + item) + "&"; });
        if (isEmailConfirmed === null)
            throw new Error("The parameter 'isEmailConfirmed' cannot be null.");
        else if (isEmailConfirmed !== undefined)
            url_ += "isEmailConfirmed=" + encodeURIComponent("" + isEmailConfirmed) + "&"; 
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "isActive=" + encodeURIComponent("" + isActive) + "&"; 
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "onlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * 用户的权限编辑
     * @param id (optional) 
     * @return Success
     */
    getPermissionsTreeForEdit(id: number | undefined): Observable<GetUserPermissionsTreeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetPermissionsTreeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPermissionsTreeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPermissionsTreeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsTreeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsTreeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPermissionsTreeForEdit(response: HttpResponseBase): Observable<GetUserPermissionsTreeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsTreeForEditOutput.fromJS(resultData200) : new GetUserPermissionsTreeForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsTreeForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * 获取用户导出信息
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: NullableIdDtoOfInt64 | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlock(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/Unlock";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlock(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlock(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlock(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updatePermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdatePermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VerifiableSetServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除VerifiableSet的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateVerifiableSetInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取VerifiableSetListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<VerifiableSetListDto> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<VerifiableSetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<VerifiableSetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<VerifiableSetListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? VerifiableSetListDto.fromJS(resultData200) : new VerifiableSetListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VerifiableSetListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetVerifiableSetForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVerifiableSetForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVerifiableSetForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetVerifiableSetForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetVerifiableSetForEditOutput.fromJS(resultData200) : new GetVerifiableSetForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVerifiableSetForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfVerifiableSetListDto> {
        let url_ = this.baseUrl + "/api/services/app/VerifiableSet/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVerifiableSetListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVerifiableSetListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfVerifiableSetListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfVerifiableSetListDto.fromJS(resultData200) : new PagedResultDtoOfVerifiableSetListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVerifiableSetListDto>(<any>null);
    }
}

@Injectable()
export class WebSiteLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 下载日志文件压缩包
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * 获取最新的网站日志信息
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebSiteLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }
}

@Injectable()
export class WechatAppConfigServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除WechatAppConfig的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改WechatAppConfig的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateWechatAppConfigInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除WechatAppConfig信息的方法
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取WechatAppConfigListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<WechatAppConfigListDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<WechatAppConfigListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WechatAppConfigListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WechatAppConfigListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WechatAppConfigListDto.fromJS(resultData200) : new WechatAppConfigListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WechatAppConfigListDto>(<any>null);
    }

    /**
     * 获取编辑 WechatAppConfig
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetWechatAppConfigForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWechatAppConfigForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWechatAppConfigForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetWechatAppConfigForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWechatAppConfigForEditOutput.fromJS(resultData200) : new GetWechatAppConfigForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWechatAppConfigForEditOutput>(<any>null);
    }

    /**
     * 获取WechatAppConfig的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfWechatAppConfigListDto> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWechatAppConfigListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWechatAppConfigListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfWechatAppConfigListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWechatAppConfigListDto.fromJS(resultData200) : new PagedResultDtoOfWechatAppConfigListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWechatAppConfigListDto>(<any>null);
    }

    /**
     * 将wechat app注入到容器,如果已注入则刷新注入
     * @param appId (optional) 
     * @return Success
     */
    registerWechatApp(appId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatAppConfig/RegisterWechatApp?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterWechatApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterWechatApp(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterWechatApp(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WeChatHomePageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除WeChatHomePage的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateWeChatHomePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取WeChatHomePageListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<WeChatHomePageListDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<WeChatHomePageListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatHomePageListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WeChatHomePageListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeChatHomePageListDto.fromJS(resultData200) : new WeChatHomePageListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatHomePageListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetWeChatHomePageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWeChatHomePageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWeChatHomePageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetWeChatHomePageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWeChatHomePageForEditOutput.fromJS(resultData200) : new GetWeChatHomePageForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWeChatHomePageForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfWeChatHomePageListDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWeChatHomePageListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWeChatHomePageListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfWeChatHomePageListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWeChatHomePageListDto.fromJS(resultData200) : new PagedResultDtoOfWeChatHomePageListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWeChatHomePageListDto>(<any>null);
    }

    /**
     * 上传照片
     * @param body (optional) 
     * @return Success
     */
    weChatPicture(body: Blob | undefined): Observable<UploadWeChatPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatHomePage/WeChatPicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWeChatPicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWeChatPicture(<any>response_);
                } catch (e) {
                    return <Observable<UploadWeChatPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadWeChatPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processWeChatPicture(response: HttpResponseBase): Observable<UploadWeChatPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadWeChatPictureResultDto.fromJS(resultData200) : new UploadWeChatPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadWeChatPictureResultDto>(<any>null);
    }
}

@Injectable()
export class WechatMediaServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    createOtherrMaterial(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/CreateOtherrMaterial";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOtherrMaterial(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOtherrMaterial(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOtherrMaterial(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @param mediaId (optional) 
     * @return Success
     */
    delete(appId: string | undefined, mediaId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/Delete?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        if (mediaId === null)
            throw new Error("The parameter 'mediaId' cannot be null.");
        else if (mediaId !== undefined)
            url_ += "mediaId=" + encodeURIComponent("" + mediaId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getImageTextMaterialPaged(body: GetImageTextMaterialsInput | undefined): Observable<PagedResultDtoOfMediaList_News_Item> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/GetImageTextMaterialPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetImageTextMaterialPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetImageTextMaterialPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMediaList_News_Item>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMediaList_News_Item>><any>_observableThrow(response_);
        }));
    }

    protected processGetImageTextMaterialPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMediaList_News_Item> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMediaList_News_Item.fromJS(resultData200) : new PagedResultDtoOfMediaList_News_Item();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMediaList_News_Item>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getOtherMaterialPaged(body: GetOtherMaterialsInput | undefined): Observable<PagedResultDtoOfMediaList_Others_Item> {
        let url_ = this.baseUrl + "/api/services/app/WechatMedia/GetOtherMaterialPaged";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOtherMaterialPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOtherMaterialPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMediaList_Others_Item>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMediaList_Others_Item>><any>_observableThrow(response_);
        }));
    }

    protected processGetOtherMaterialPaged(response: HttpResponseBase): Observable<PagedResultDtoOfMediaList_Others_Item> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfMediaList_Others_Item.fromJS(resultData200) : new PagedResultDtoOfMediaList_Others_Item();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMediaList_Others_Item>(<any>null);
    }
}

@Injectable()
export class WechatMenuAppSeviceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrWechatEditMenu(body: CreateOrEditWechatMenuInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/CreateOrWechatEditMenu";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrWechatEditMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrWechatEditMenu(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrWechatEditMenu(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @param menuConditionalId (optional) 
     * @return Success
     */
    deleteMenuConditional(appId: string | undefined, menuConditionalId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/DeleteMenuConditional?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        if (menuConditionalId === null)
            throw new Error("The parameter 'menuConditionalId' cannot be null.");
        else if (menuConditionalId !== undefined)
            url_ += "menuConditionalId=" + encodeURIComponent("" + menuConditionalId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteMenuConditional(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteMenuConditional(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteMenuConditional(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param appId (optional) 
     * @return Success
     */
    getMenuForEdit(appId: string | undefined): Observable<GetWechatMenuForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WechatMenuAppSevice/GetMenuForEdit?";
        if (appId === null)
            throw new Error("The parameter 'appId' cannot be null.");
        else if (appId !== undefined)
            url_ += "appId=" + encodeURIComponent("" + appId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMenuForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMenuForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWechatMenuForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWechatMenuForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMenuForEdit(response: HttpResponseBase): Observable<GetWechatMenuForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWechatMenuForEditOutput.fromJS(resultData200) : new GetWechatMenuForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWechatMenuForEditOutput>(<any>null);
    }
}

@Injectable()
export class WeChatScenicSpotServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 批量删除WeChatScenicSpot的方法
     * @param body (optional) 
     * @return Success
     */
    batchDelete(body: number[] | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/BatchDelete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBatchDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBatchDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBatchDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 添加或者修改的公共方法
     * @param body (optional) 
     * @return Success
     */
    createOrUpdate(body: CreateOrUpdateWeChatScenicSpotInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/CreateOrUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 删除信息
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 通过指定id获取WeChatScenicSpotListDto信息
     * @param id (optional) 
     * @return Success
     */
    getById(id: number | undefined): Observable<WeChatScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/GetById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<WeChatScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeChatScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<WeChatScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? WeChatScenicSpotListDto.fromJS(resultData200) : new WeChatScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeChatScenicSpotListDto>(<any>null);
    }

    /**
     * 获取编辑
     * @param id (optional) 
     * @return Success
     */
    getForEdit(id: number | undefined): Observable<GetWeChatScenicSpotForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/GetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWeChatScenicSpotForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWeChatScenicSpotForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetForEdit(response: HttpResponseBase): Observable<GetWeChatScenicSpotForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetWeChatScenicSpotForEditOutput.fromJS(resultData200) : new GetWeChatScenicSpotForEditOutput();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWeChatScenicSpotForEditOutput>(<any>null);
    }

    /**
     * 获取的分页列表信息
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaged(filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfWeChatScenicSpotListDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/GetPaged?";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWeChatScenicSpotListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWeChatScenicSpotListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<PagedResultDtoOfWeChatScenicSpotListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfWeChatScenicSpotListDto.fromJS(resultData200) : new PagedResultDtoOfWeChatScenicSpotListDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWeChatScenicSpotListDto>(<any>null);
    }

    /**
     * 上传照片
     * @param body (optional) 
     * @return Success
     */
    upLoadPictures(body: Blob | undefined): Observable<UploadWeChatPictureResultDto> {
        let url_ = this.baseUrl + "/api/services/app/WeChatScenicSpot/UpLoadPictures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = body;

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "multipart/form-data", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpLoadPictures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpLoadPictures(<any>response_);
                } catch (e) {
                    return <Observable<UploadWeChatPictureResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadWeChatPictureResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpLoadPictures(response: HttpResponseBase): Observable<UploadWeChatPictureResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UploadWeChatPictureResultDto.fromJS(resultData200) : new UploadWeChatPictureResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadWeChatPictureResultDto>(<any>null);
    }
}

@Injectable()
export class SalesByOrderSourceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取统计结果
     * @param queryData (optional) CreationTime 日期
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sourceId (optional) 
     * @param payMethodId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, sourceId: string | undefined, payMethodId: string | undefined): Observable<StatsPagedResultDtoOfSalesByOrderSourceResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesByOrderSource/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sourceId === null)
            throw new Error("The parameter 'sourceId' cannot be null.");
        else if (sourceId !== undefined)
            url_ += "sourceId=" + encodeURIComponent("" + sourceId) + "&"; 
        if (payMethodId === null)
            throw new Error("The parameter 'payMethodId' cannot be null.");
        else if (payMethodId !== undefined)
            url_ += "payMethodId=" + encodeURIComponent("" + payMethodId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesByOrderSourceResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesByOrderSourceResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesByOrderSourceResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesByOrderSourceResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesByOrderSourceResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesByOrderSourceResultDto>(<any>null);
    }
}

@Injectable()
export class SalesByOrganizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取统计结果
     * @param queryData (optional) CreationTime 日期
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param organizationId (optional) 
     * @param payMethodId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, organizationId: string | undefined, payMethodId: string | undefined): Observable<StatsPagedResultDtoOfSalesByOrganizationResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesByOrganization/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (organizationId !== undefined)
            url_ += "organizationId=" + encodeURIComponent("" + organizationId) + "&"; 
        if (payMethodId === null)
            throw new Error("The parameter 'payMethodId' cannot be null.");
        else if (payMethodId !== undefined)
            url_ += "payMethodId=" + encodeURIComponent("" + payMethodId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesByOrganizationResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesByOrganizationResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesByOrganizationResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesByOrganizationResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesByOrganizationResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesByOrganizationResultDto>(<any>null);
    }
}

@Injectable()
export class SalesByPayMethodServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取统计结果
     * @param queryData (optional) CreationTime 日期
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param payMethodId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, payMethodId: string | undefined): Observable<StatsPagedResultDtoOfSalesByPayMethodResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesByPayMethod/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (payMethodId === null)
            throw new Error("The parameter 'payMethodId' cannot be null.");
        else if (payMethodId !== undefined)
            url_ += "payMethodId=" + encodeURIComponent("" + payMethodId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesByPayMethodResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesByPayMethodResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesByPayMethodResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesByPayMethodResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesByPayMethodResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesByPayMethodResultDto>(<any>null);
    }
}

@Injectable()
export class SalesBySellerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取统计结果
     * @param queryData (optional) CreatorUserId 售票员 CreationTime 日期
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, ticketId: string | undefined): Observable<StatsPagedResultDtoOfSalesBySellerResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesBySeller/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesBySellerResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesBySellerResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesBySellerResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesBySellerResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesBySellerResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesBySellerResultDto>(<any>null);
    }
}

@Injectable()
export class SalesBySellerDailyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取统计结果
     * @param queryData (optional) CreatorUserId 售票员 CreationTime 日期
     * @param filterText (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param ticketId (optional) 
     * @return Success
     */
    getPaged(queryData: QueryData[] | undefined, filterText: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined, ticketId: string | undefined): Observable<StatsPagedResultDtoOfSalesBySellerDailyResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesBySellerDaily/GetPaged?";
        if (queryData === null)
            throw new Error("The parameter 'queryData' cannot be null.");
        else if (queryData !== undefined)
            queryData && queryData.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "queryData[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "filterText=" + encodeURIComponent("" + filterText) + "&"; 
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "maxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "skipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (ticketId === null)
            throw new Error("The parameter 'ticketId' cannot be null.");
        else if (ticketId !== undefined)
            url_ += "ticketId=" + encodeURIComponent("" + ticketId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaged(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaged(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesBySellerDailyResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesBySellerDailyResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaged(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesBySellerDailyResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesBySellerDailyResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesBySellerDailyResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesBySellerDailyResultDto>(<any>null);
    }
}

@Injectable()
export class SalesCommonServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取订单信息
     * @param sellerId (optional) 
     * @return Success
     */
    getPagedActivities(sellerId: string | undefined): Observable<StatsPagedResultDtoOfSalesActivityResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesCommon/GetPagedActivities?";
        if (sellerId === null)
            throw new Error("The parameter 'sellerId' cannot be null.");
        else if (sellerId !== undefined)
            url_ += "sellerId=" + encodeURIComponent("" + sellerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedActivities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedActivities(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesActivityResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesActivityResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedActivities(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesActivityResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesActivityResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesActivityResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesActivityResultDto>(<any>null);
    }

    /**
     * 获取订单明细
     * @param activityId (optional) 
     * @return Success
     */
    getPagedActivityDetails(activityId: string | undefined): Observable<StatsPagedResultDtoOfSalesActivityDetailResultDto> {
        let url_ = this.baseUrl + "/api/Stats/SalesCommon/GetPagedActivityDetails?";
        if (activityId === null)
            throw new Error("The parameter 'activityId' cannot be null.");
        else if (activityId !== undefined)
            url_ += "activityId=" + encodeURIComponent("" + activityId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPagedActivityDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPagedActivityDetails(<any>response_);
                } catch (e) {
                    return <Observable<StatsPagedResultDtoOfSalesActivityDetailResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StatsPagedResultDtoOfSalesActivityDetailResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPagedActivityDetails(response: HttpResponseBase): Observable<StatsPagedResultDtoOfSalesActivityDetailResultDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StatsPagedResultDtoOfSalesActivityDetailResultDto.fromJS(resultData200) : new StatsPagedResultDtoOfSalesActivityDetailResultDto();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StatsPagedResultDtoOfSalesActivityDetailResultDto>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateAccount(body: ActivateAccountModel | undefined): Observable<ActivateAccountResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ActivateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateAccount(<any>response_);
                } catch (e) {
                    return <Observable<ActivateAccountResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ActivateAccountResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processActivateAccount(response: HttpResponseBase): Observable<ActivateAccountResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ActivateAccountResultModel.fromJS(resultData200) : new ActivateAccountResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ActivateAccountResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * 生成验证码
     * @param name (optional) 
     * @param tid (optional) 
     * @return Success
     */
    generateVerification(name: string | undefined, tid: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/GenerateVerification?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (tid === null)
            throw new Error("The parameter 'tid' cannot be null.");
        else if (tid !== undefined)
            url_ += "tid=" + encodeURIComponent("" + tid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateVerification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateVerification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateVerification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }
}

@Injectable()
export class VerificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 生成验证码
     * @param name (optional) 验证码key
     * @param t (optional) 验证码类型
     * @param tid (optional) 租户Id(可空)
     * @return Success
     */
    generateCaptcha(name: string | undefined, t: CaptchaType | undefined, tid: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/Verification/GenerateCaptcha?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&"; 
        if (t === null)
            throw new Error("The parameter 't' cannot be null.");
        else if (t !== undefined)
            url_ += "t=" + encodeURIComponent("" + t) + "&"; 
        if (tid === null)
            throw new Error("The parameter 'tid' cannot be null.");
        else if (tid !== undefined)
            url_ += "tid=" + encodeURIComponent("" + tid) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCaptcha(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCaptcha(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCaptcha(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WechatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取微信常用游客
     * @param openId (optional) 
     * @return Success
     */
    getCustomersByOpenId(openId: string | undefined): Observable<PagedResultDtoOfCustomer> {
        let url_ = this.baseUrl + "/api/Wechat/GetCustomersByOpenId?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersByOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersByOpenId(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomer>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomer>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersByOpenId(response: HttpResponseBase): Observable<PagedResultDtoOfCustomer> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfCustomer.fromJS(resultData200) : new PagedResultDtoOfCustomer();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomer>(<any>null);
    }

    /**
     * 获取微信用户的订单
     * @param openId (optional) 
     * @return Success
     */
    getWechatActivitys(openId: string | undefined): Observable<PagedResultDtoOfActivity> {
        let url_ = this.baseUrl + "/api/Wechat/GetWechatActivitys?";
        if (openId === null)
            throw new Error("The parameter 'openId' cannot be null.");
        else if (openId !== undefined)
            url_ += "openId=" + encodeURIComponent("" + openId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWechatActivitys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWechatActivitys(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfActivity>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfActivity>><any>_observableThrow(response_);
        }));
    }

    protected processGetWechatActivitys(response: HttpResponseBase): Observable<PagedResultDtoOfActivity> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfActivity.fromJS(resultData200) : new PagedResultDtoOfActivity();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfActivity>(<any>null);
    }
}

@Injectable()
export class WechatPayServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * 获取OpenId
     * @param code (optional) 
     * @return Success
     */
    getOpenId(code: string | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/GetOpenId?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOpenId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOpenId(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetOpenId(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 获取OpenId
     * @param appid (optional) 
     * @param secret (optional) 
     * @param grant_type (optional) 
     * @return Success
     */
    getToken(appid: string | undefined, secret: string | undefined, grant_type: string | undefined): Observable<AccessTokenResult> {
        let url_ = this.baseUrl + "/api/WechatPay/GetToken?";
        if (appid === null)
            throw new Error("The parameter 'appid' cannot be null.");
        else if (appid !== undefined)
            url_ += "appid=" + encodeURIComponent("" + appid) + "&"; 
        if (secret === null)
            throw new Error("The parameter 'secret' cannot be null.");
        else if (secret !== undefined)
            url_ += "secret=" + encodeURIComponent("" + secret) + "&"; 
        if (grant_type === null)
            throw new Error("The parameter 'grant_type' cannot be null.");
        else if (grant_type !== undefined)
            url_ += "grant_type=" + encodeURIComponent("" + grant_type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetToken(<any>response_);
                } catch (e) {
                    return <Observable<AccessTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccessTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processGetToken(response: HttpResponseBase): Observable<AccessTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AccessTokenResult.fromJS(resultData200) : new AccessTokenResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AccessTokenResult>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlGet(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlGet(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlGet(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlPost(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlPost(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlPost(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 支付回调URL，对应于Service.Config.TenPayV3Notify
     * @return Success
     */
    payNotifyUrlPut(): Observable<void> {
        let url_ = this.baseUrl + "/api/WechatPay/PayNotifyUrl";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPayNotifyUrlPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPayNotifyUrlPut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPayNotifyUrlPut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * 根据票据Id退票，暂存订单支付状态不变，只修改票据状态，可以调用/api/services/app/ActivityTempDetail/GetDetailListByTempId查询状态
     * @param ticketDetailId (optional) 票据id
     * @return Success
     */
    refundGet(ticketDetailId: number | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/Refund?";
        if (ticketDetailId === null)
            throw new Error("The parameter 'ticketDetailId' cannot be null.");
        else if (ticketDetailId !== undefined)
            url_ += "ticketDetailId=" + encodeURIComponent("" + ticketDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundGet(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefundGet(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 根据票据Id退票，暂存订单支付状态不变，只修改票据状态，可以调用/api/services/app/ActivityTempDetail/GetDetailListByTempId查询状态
     * @param ticketDetailId (optional) 票据id
     * @return Success
     */
    refundPost(ticketDetailId: number | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/Refund?";
        if (ticketDetailId === null)
            throw new Error("The parameter 'ticketDetailId' cannot be null.");
        else if (ticketDetailId !== undefined)
            url_ += "ticketDetailId=" + encodeURIComponent("" + ticketDetailId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefundPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefundPost(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefundPost(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 发起支付请求,生成暂存订单
     * @param body (optional) 
     * @return Success
     */
    wechatPayOrder(body: CreateActivityModel | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/WechatPayOrder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json", 
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWechatPayOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWechatPayOrder(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processWechatPayOrder(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }

    /**
     * 重新支付暂存订单
     * @param activityTempId (optional) 暂存订单Id
     * @return Success
     */
    wechatPayOrderAgain(activityTempId: number | undefined): Observable<AjaxResult> {
        let url_ = this.baseUrl + "/api/WechatPay/WechatPayOrderAgain?";
        if (activityTempId === null)
            throw new Error("The parameter 'activityTempId' cannot be null.");
        else if (activityTempId !== undefined)
            url_ += "activityTempId=" + encodeURIComponent("" + activityTempId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processWechatPayOrderAgain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processWechatPayOrderAgain(<any>response_);
                } catch (e) {
                    return <Observable<AjaxResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<AjaxResult>><any>_observableThrow(response_);
        }));
    }

    protected processWechatPayOrderAgain(response: HttpResponseBase): Observable<AjaxResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AjaxResult.fromJS(resultData200) : new AjaxResult();
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AjaxResult>(<any>null);
    }
}

export enum OrderTypeEnum {
    OrderTypeCustomer = <any>"OrderTypeCustomer", 
    OrderTypeOrg = <any>"OrderTypeOrg", 
}

export class CreateActivityDetailModel implements ICreateActivityDetailModel {
    quantity: number;
    ticketPriceId: number;
    customerId: number;

    constructor(data?: ICreateActivityDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quantity = data["quantity"];
            this.ticketPriceId = data["ticketPriceId"];
            this.customerId = data["customerId"];
        }
    }

    static fromJS(data: any): CreateActivityDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["ticketPriceId"] = this.ticketPriceId;
        data["customerId"] = this.customerId;
        return data; 
    }

    clone(): CreateActivityDetailModel {
        const json = this.toJSON();
        let result = new CreateActivityDetailModel();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityDetailModel {
    quantity: number;
    ticketPriceId: number;
    customerId: number;
}

export class CreateActivityModel implements ICreateActivityModel {
    sourceId: number | undefined;
    payMethodId: number | undefined;
    voucherNo: string | undefined;
    orderType: OrderTypeEnum;
    remark: string | undefined;
    createUserId: number;
    totalQuantity: number;
    totalAmount: number;
    activityDetails: CreateActivityDetailModel[] | undefined;
    travelAgencyId: number | undefined;
    organizationId: number | undefined;
    startDateTime: string | undefined;
    endDateTime: string | undefined;
    discount: number;
    openId: string | undefined;

    constructor(data?: ICreateActivityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceId = data["sourceId"];
            this.payMethodId = data["payMethodId"];
            this.voucherNo = data["voucherNo"];
            this.orderType = data["orderType"];
            this.remark = data["remark"];
            this.createUserId = data["createUserId"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(CreateActivityDetailModel.fromJS(item));
            }
            this.travelAgencyId = data["travelAgencyId"];
            this.organizationId = data["organizationId"];
            this.startDateTime = data["startDateTime"];
            this.endDateTime = data["endDateTime"];
            this.discount = data["discount"];
            this.openId = data["openId"];
        }
    }

    static fromJS(data: any): CreateActivityModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateActivityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        data["payMethodId"] = this.payMethodId;
        data["voucherNo"] = this.voucherNo;
        data["orderType"] = this.orderType;
        data["remark"] = this.remark;
        data["createUserId"] = this.createUserId;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["travelAgencyId"] = this.travelAgencyId;
        data["organizationId"] = this.organizationId;
        data["startDateTime"] = this.startDateTime;
        data["endDateTime"] = this.endDateTime;
        data["discount"] = this.discount;
        data["openId"] = this.openId;
        return data; 
    }

    clone(): CreateActivityModel {
        const json = this.toJSON();
        let result = new CreateActivityModel();
        result.init(json);
        return result;
    }
}

export interface ICreateActivityModel {
    sourceId: number | undefined;
    payMethodId: number | undefined;
    voucherNo: string | undefined;
    orderType: OrderTypeEnum;
    remark: string | undefined;
    createUserId: number;
    totalQuantity: number;
    totalAmount: number;
    activityDetails: CreateActivityDetailModel[] | undefined;
    travelAgencyId: number | undefined;
    organizationId: number | undefined;
    startDateTime: string | undefined;
    endDateTime: string | undefined;
    discount: number;
    openId: string | undefined;
}

export class ActivityResultModel implements IActivityResultModel {
    resultCode: string | undefined;
    resultMessage: string | undefined;
    detail: string | undefined;
    data: Data | undefined;

    constructor(data?: IActivityResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.resultCode = data["resultCode"];
            this.resultMessage = data["resultMessage"];
            this.detail = data["detail"];
            this.data = data["data"] ? Data.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["resultCode"] = this.resultCode;
        data["resultMessage"] = this.resultMessage;
        data["detail"] = this.detail;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ActivityResultModel {
        const json = this.toJSON();
        let result = new ActivityResultModel();
        result.init(json);
        return result;
    }
}

export interface IActivityResultModel {
    resultCode: string | undefined;
    resultMessage: string | undefined;
    detail: string | undefined;
    data: Data | undefined;
}

export class CreateGroupActivityDetailModel implements ICreateGroupActivityDetailModel {
    quantity: number;
    customerId: number;
    ticketPriceId: number;

    constructor(data?: ICreateGroupActivityDetailModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quantity = data["quantity"];
            this.customerId = data["customerId"];
            this.ticketPriceId = data["ticketPriceId"];
        }
    }

    static fromJS(data: any): CreateGroupActivityDetailModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupActivityDetailModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quantity"] = this.quantity;
        data["customerId"] = this.customerId;
        data["ticketPriceId"] = this.ticketPriceId;
        return data; 
    }

    clone(): CreateGroupActivityDetailModel {
        const json = this.toJSON();
        let result = new CreateGroupActivityDetailModel();
        result.init(json);
        return result;
    }
}

export interface ICreateGroupActivityDetailModel {
    quantity: number;
    customerId: number;
    ticketPriceId: number;
}

export class CreateGroupActivityModel implements ICreateGroupActivityModel {
    sourceId: number | undefined;
    payMethodId: number | undefined;
    voucherNo: string | undefined;
    discount: number;
    orderType: OrderTypeEnum;
    remark: string | undefined;
    createUserId: number;
    totalQuantity: number;
    totalAmount: number;
    activityDetails: CreateGroupActivityDetailModel[] | undefined;
    groupId: number;
    availableStart: string | undefined;
    availableEnd: string | undefined;

    constructor(data?: ICreateGroupActivityModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceId = data["sourceId"];
            this.payMethodId = data["payMethodId"];
            this.voucherNo = data["voucherNo"];
            this.discount = data["discount"];
            this.orderType = data["orderType"];
            this.remark = data["remark"];
            this.createUserId = data["createUserId"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(CreateGroupActivityDetailModel.fromJS(item));
            }
            this.groupId = data["groupId"];
            this.availableStart = data["availableStart"];
            this.availableEnd = data["availableEnd"];
        }
    }

    static fromJS(data: any): CreateGroupActivityModel {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGroupActivityModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceId"] = this.sourceId;
        data["payMethodId"] = this.payMethodId;
        data["voucherNo"] = this.voucherNo;
        data["discount"] = this.discount;
        data["orderType"] = this.orderType;
        data["remark"] = this.remark;
        data["createUserId"] = this.createUserId;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["groupId"] = this.groupId;
        data["availableStart"] = this.availableStart;
        data["availableEnd"] = this.availableEnd;
        return data; 
    }

    clone(): CreateGroupActivityModel {
        const json = this.toJSON();
        let result = new CreateGroupActivityModel();
        result.init(json);
        return result;
    }
}

export interface ICreateGroupActivityModel {
    sourceId: number | undefined;
    payMethodId: number | undefined;
    voucherNo: string | undefined;
    discount: number;
    orderType: OrderTypeEnum;
    remark: string | undefined;
    createUserId: number;
    totalQuantity: number;
    totalAmount: number;
    activityDetails: CreateGroupActivityDetailModel[] | undefined;
    groupId: number;
    availableStart: string | undefined;
    availableEnd: string | undefined;
}

export class QueryData implements IQueryData {
    field: string | undefined;
    method: string | undefined;
    value: string | undefined;
    logic: string | undefined;

    constructor(data?: IQueryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.field = data["field"];
            this.method = data["method"];
            this.value = data["value"];
            this.logic = data["logic"];
        }
    }

    static fromJS(data: any): QueryData {
        data = typeof data === 'object' ? data : {};
        let result = new QueryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["method"] = this.method;
        data["value"] = this.value;
        data["logic"] = this.logic;
        return data; 
    }

    clone(): QueryData {
        const json = this.toJSON();
        let result = new QueryData();
        result.init(json);
        return result;
    }
}

export interface IQueryData {
    field: string | undefined;
    method: string | undefined;
    value: string | undefined;
    logic: string | undefined;
}

export class VerifyTypeDataItem implements IVerifyTypeDataItem {
    /** 类型名称 */
    typeName: string | undefined;
    /** 值 */
    value: number;

    constructor(data?: IVerifyTypeDataItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.typeName = data["typeName"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): VerifyTypeDataItem {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyTypeDataItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["typeName"] = this.typeName;
        data["value"] = this.value;
        return data; 
    }

    clone(): VerifyTypeDataItem {
        const json = this.toJSON();
        let result = new VerifyTypeDataItem();
        result.init(json);
        return result;
    }
}

export interface IVerifyTypeDataItem {
    /** 类型名称 */
    typeName: string | undefined;
    /** 值 */
    value: number;
}

/** 过闸统计页面Dto */
export class GateHistoryResultDto implements IGateHistoryResultDto {
    /** 设备名称 */
    deviceName: string | undefined;
    /** 设备代码 */
    deviceId: string | undefined;
    /** 验票介质类型 */
    verifyTypeDatas: VerifyTypeDataItem[] | undefined;
    /** 合计 */
    total: number;
    /** 设备分类 */
    deviceType: string | undefined;

    constructor(data?: IGateHistoryResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deviceName = data["deviceName"];
            this.deviceId = data["deviceId"];
            if (data["verifyTypeDatas"] && data["verifyTypeDatas"].constructor === Array) {
                this.verifyTypeDatas = [] as any;
                for (let item of data["verifyTypeDatas"])
                    this.verifyTypeDatas.push(VerifyTypeDataItem.fromJS(item));
            }
            this.total = data["total"];
            this.deviceType = data["deviceType"];
        }
    }

    static fromJS(data: any): GateHistoryResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateHistoryResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceName"] = this.deviceName;
        data["deviceId"] = this.deviceId;
        if (this.verifyTypeDatas && this.verifyTypeDatas.constructor === Array) {
            data["verifyTypeDatas"] = [];
            for (let item of this.verifyTypeDatas)
                data["verifyTypeDatas"].push(item.toJSON());
        }
        data["total"] = this.total;
        data["deviceType"] = this.deviceType;
        return data; 
    }

    clone(): GateHistoryResultDto {
        const json = this.toJSON();
        let result = new GateHistoryResultDto();
        result.init(json);
        return result;
    }
}

/** 过闸统计页面Dto */
export interface IGateHistoryResultDto {
    /** 设备名称 */
    deviceName: string | undefined;
    /** 设备代码 */
    deviceId: string | undefined;
    /** 验票介质类型 */
    verifyTypeDatas: VerifyTypeDataItem[] | undefined;
    /** 合计 */
    total: number;
    /** 设备分类 */
    deviceType: string | undefined;
}

export class PagedResultDtoOfGateHistoryResultDto implements IPagedResultDtoOfGateHistoryResultDto {
    totalCount: number;
    items: GateHistoryResultDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGateHistoryResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GateHistoryResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGateHistoryResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGateHistoryResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGateHistoryResultDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGateHistoryResultDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGateHistoryResultDto {
    totalCount: number;
    items: GateHistoryResultDto[] | undefined;
}

export class CheckResult implements ICheckResult {
    status: number;
    msg: string | undefined;
    count: number;
    audio: string | undefined;
    show_msg: string | undefined;

    constructor(data?: ICheckResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.msg = data["msg"];
            this.count = data["count"];
            this.audio = data["audio"];
            this.show_msg = data["show_msg"];
        }
    }

    static fromJS(data: any): CheckResult {
        data = typeof data === 'object' ? data : {};
        let result = new CheckResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["msg"] = this.msg;
        data["count"] = this.count;
        data["audio"] = this.audio;
        data["show_msg"] = this.show_msg;
        return data; 
    }

    clone(): CheckResult {
        const json = this.toJSON();
        let result = new CheckResult();
        result.init(json);
        return result;
    }
}

export interface ICheckResult {
    status: number;
    msg: string | undefined;
    count: number;
    audio: string | undefined;
    show_msg: string | undefined;
}

export class AudioResultDto implements IAudioResultDto {
    success: boolean;
    errorMsg: string | undefined;
    uri: string | undefined;

    constructor(data?: IAudioResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.success = data["success"];
            this.errorMsg = data["errorMsg"];
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): AudioResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new AudioResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["errorMsg"] = this.errorMsg;
        data["uri"] = this.uri;
        return data; 
    }

    clone(): AudioResultDto {
        const json = this.toJSON();
        let result = new AudioResultDto();
        result.init(json);
        return result;
    }
}

export interface IAudioResultDto {
    success: boolean;
    errorMsg: string | undefined;
    uri: string | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
    c: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }

    clone(): ActivateEmailInput {
        const json = this.toJSON();
        let result = new ActivateEmailInput();
        result.init(json);
        return result;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    /** Encrypted values for {TenantId}, {UserId} and {ConfirmationCode} */
    c: string | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): ImpersonateOutput {
        const json = this.toJSON();
        let result = new ImpersonateOutput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ImpersonateInput {
        const json = this.toJSON();
        let result = new ImpersonateInput();
        result.init(json);
        return result;
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number;
}

/** ��֤�⻧�����Ƿ���� */
export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string | undefined;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): IsTenantAvailableInput {
        const json = this.toJSON();
        let result = new IsTenantAvailableInput();
        result.init(json);
        return result;
    }
}

/** ��֤�⻧�����Ƿ���� */
export interface IIsTenantAvailableInput {
    tenancyName: string | undefined;
}

export enum TenantAvailabilityState {
    Available = <any>"Available", 
    InActive = <any>"InActive", 
    NotFound = <any>"NotFound", 
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        return data; 
    }

    clone(): IsTenantAvailableOutput {
        const json = this.toJSON();
        let result = new IsTenantAvailableOutput();
        result.init(json);
        return result;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
}

export class RegisterInput implements IRegisterInput {
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.verificationCode = data["verificationCode"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        return data; 
    }

    clone(): RegisterInput {
        const json = this.toJSON();
        let result = new RegisterInput();
        result.init(json);
        return result;
    }
}

export interface IRegisterInput {
    userName: string | undefined;
    emailAddress: string | undefined;
    password: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }

    clone(): RegisterOutput {
        const json = this.toJSON();
        let result = new RegisterOutput();
        result.init(json);
        return result;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }

    clone(): ResetPasswordInput {
        const json = this.toJSON();
        let result = new ResetPasswordInput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }

    clone(): ResetPasswordOutput {
        const json = this.toJSON();
        let result = new ResetPasswordOutput();
        result.init(json);
        return result;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }

    clone(): ResolveTenantIdInput {
        const json = this.toJSON();
        let result = new ResolveTenantIdInput();
        result.init(json);
        return result;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string | undefined;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendEmailActivationLinkInput {
        const json = this.toJSON();
        let result = new SendEmailActivationLinkInput();
        result.init(json);
        return result;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string | undefined;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendPasswordResetCodeInput {
        const json = this.toJSON();
        let result = new SendPasswordResetCodeInput();
        result.init(json);
        return result;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }

    clone(): SwitchToLinkedAccountInput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountInput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }

    clone(): SwitchToLinkedAccountOutput {
        const json = this.toJSON();
        let result = new SwitchToLinkedAccountOutput();
        result.init(json);
        return result;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export enum AccountStatusEnum {
    NotAccount = <any>"IsAccount", 
    IsAccount = <any>"NotAccount", 
}

export class UserToken implements IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserToken {
        const json = this.toJSON();
        let result = new UserToken();
        result.init(json);
        return result;
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number;
}

export class UserLogin implements IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLogin {
        const json = this.toJSON();
        let result = new UserLogin();
        result.init(json);
        return result;
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number;
    loginProvider: string | undefined;
    providerKey: string | undefined;
    id: number;
}

export class UserRole implements IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserRole {
        const json = this.toJSON();
        let result = new UserRole();
        result.init(json);
        return result;
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number;
    roleId: number;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserClaim implements IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserClaim {
        const json = this.toJSON();
        let result = new UserClaim();
        result.init(json);
        return result;
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserPermissionSetting {
        const json = this.toJSON();
        let result = new UserPermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IUserPermissionSetting {
    userId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Setting implements ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Setting {
        const json = this.toJSON();
        let result = new Setting();
        result.init(json);
        return result;
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string | undefined;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class User implements IUser {
    signInToken: string | undefined;
    needToChangeThePassword: boolean;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    name: string | undefined;
    profilePictureId: string | undefined;
    surname: string | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    readonly fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.needToChangeThePassword = data["needToChangeThePassword"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.name = data["name"];
            this.profilePictureId = data["profilePictureId"];
            this.surname = data["surname"];
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (data["tokens"] && data["tokens"].constructor === Array) {
                this.tokens = [] as any;
                for (let item of data["tokens"])
                    this.tokens.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            (<any>this).fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (data["logins"] && data["logins"].constructor === Array) {
                this.logins = [] as any;
                for (let item of data["logins"])
                    this.logins.push(UserLogin.fromJS(item));
            }
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRole.fromJS(item));
            }
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["claims"])
                    this.claims.push(UserClaim.fromJS(item));
            }
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(UserPermissionSetting.fromJS(item));
            }
            if (data["settings"] && data["settings"].constructor === Array) {
                this.settings = [] as any;
                for (let item of data["settings"])
                    this.settings.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["profilePictureId"] = this.profilePictureId;
        data["surname"] = this.surname;
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (this.tokens && this.tokens.constructor === Array) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (this.logins && this.logins.constructor === Array) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.settings && this.settings.constructor === Array) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    signInToken: string | undefined;
    needToChangeThePassword: boolean;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    name: string | undefined;
    profilePictureId: string | undefined;
    surname: string | undefined;
    normalizedUserName: string | undefined;
    normalizedEmailAddress: string | undefined;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    authenticationSource: string | undefined;
    userName: string | undefined;
    tenantId: number | undefined;
    emailAddress: string | undefined;
    fullName: string | undefined;
    password: string | undefined;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number;
    isLockoutEnabled: boolean;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean;
    isActive: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PayMethod implements IPayMethod {
    payName: string | undefined;
    payCode: string | undefined;
    sort: number | undefined;
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPayMethod) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PayMethod {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethod();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PayMethod {
        const json = this.toJSON();
        let result = new PayMethod();
        result.init(json);
        return result;
    }
}

export interface IPayMethod {
    payName: string | undefined;
    payCode: string | undefined;
    sort: number | undefined;
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Branch implements IBranch {
    parentId: number | undefined;
    parent: Branch;
    branchCode: string | undefined;
    branchName: string | undefined;
    sort: number | undefined;
    level: number | undefined;
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBranch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Branch {
        data = typeof data === 'object' ? data : {};
        let result = new Branch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Branch {
        const json = this.toJSON();
        let result = new Branch();
        result.init(json);
        return result;
    }
}

export interface IBranch {
    parentId: number | undefined;
    parent: Branch;
    branchCode: string | undefined;
    branchName: string | undefined;
    sort: number | undefined;
    level: number | undefined;
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Account implements IAccount {
    branchId: number | undefined;
    accountNo: string | undefined;
    accountDate: moment.Moment;
    quantity: number;
    amount: number;
    accountStatus: AccountStatusEnum;
    collectiorId: number | undefined;
    collectior: User;
    collectionTime: moment.Moment | undefined;
    payMethodId: number | undefined;
    payMethod: PayMethod;
    remark: string | undefined;
    voucherNo: string | undefined;
    rAmount: number;
    totalAmount: number;
    rQuantity: number;
    totalQuantity: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectior = data["collectior"] ? User.fromJS(data["collectior"]) : <any>undefined;
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectior"] = this.collectior ? this.collectior.toJSON() : <any>undefined;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Account {
        const json = this.toJSON();
        let result = new Account();
        result.init(json);
        return result;
    }
}

export interface IAccount {
    branchId: number | undefined;
    accountNo: string | undefined;
    accountDate: moment.Moment;
    quantity: number;
    amount: number;
    accountStatus: AccountStatusEnum;
    collectiorId: number | undefined;
    collectior: User;
    collectionTime: moment.Moment | undefined;
    payMethodId: number | undefined;
    payMethod: PayMethod;
    remark: string | undefined;
    voucherNo: string | undefined;
    rAmount: number;
    totalAmount: number;
    rQuantity: number;
    totalQuantity: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Source implements ISource {
    branchId: number | undefined;
    sourceName: string | undefined;
    sourceCode: string | undefined;
    discount: number;
    rDiscount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Source {
        data = typeof data === 'object' ? data : {};
        let result = new Source();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Source {
        const json = this.toJSON();
        let result = new Source();
        result.init(json);
        return result;
    }
}

export interface ISource {
    branchId: number | undefined;
    sourceName: string | undefined;
    sourceCode: string | undefined;
    discount: number;
    rDiscount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum SexEnum {
    Unknown = <any>"Unknown", 
    Man = <any>"Man", 
    Woman = <any>"Woman", 
}

export enum VerifiableTypeEnum {
    IdentityCard = <any>"IdentityCard", 
    ICCard = <any>"ICCard", 
    QRCode = <any>"QRCode", 
    ReturnCard = <any>"ReturnCard", 
    TaiwanCard = <any>"TaiwanCard", 
}

export class Customer implements ICustomer {
    branchId: number | undefined;
    customerName: string | undefined;
    mobile: string | undefined;
    loginPwd: string | undefined;
    sex: SexEnum;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    job: string | undefined;
    openID: string | undefined;
    photo: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.loginPwd = data["loginPwd"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Customer {
        data = typeof data === 'object' ? data : {};
        let result = new Customer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["loginPwd"] = this.loginPwd;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Customer {
        const json = this.toJSON();
        let result = new Customer();
        result.init(json);
        return result;
    }
}

export interface ICustomer {
    branchId: number | undefined;
    customerName: string | undefined;
    mobile: string | undefined;
    loginPwd: string | undefined;
    sex: SexEnum;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    county: string | undefined;
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    job: string | undefined;
    openID: string | undefined;
    photo: string | undefined;
    dateOfBirth: moment.Moment | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum PayStatusEnum {
    NotPay = <any>"NotPay", 
    PayStatusPayment = <any>"PayStatusPayment", 
    PayStatusRefund = <any>"PayStatusRefund", 
    PayStatusClose = <any>"PayStatusClose", 
}

export enum ActivityTypeEnum {
    ActivityTypePayment = <any>"ActivityTypePayment", 
    ActivityTypeRefund = <any>"ActivityTypeRefund", 
}

export class Organization implements IOrganization {
    branchId: number | undefined;
    groupName: string | undefined;
    contacts: string | undefined;
    mobile: string | undefined;
    remand: string | undefined;
    discount: string | undefined;
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOrganization) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.groupName = data["groupName"];
            this.contacts = data["contacts"];
            this.mobile = data["mobile"];
            this.remand = data["remand"];
            this.discount = data["discount"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Organization {
        data = typeof data === 'object' ? data : {};
        let result = new Organization();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["groupName"] = this.groupName;
        data["contacts"] = this.contacts;
        data["mobile"] = this.mobile;
        data["remand"] = this.remand;
        data["discount"] = this.discount;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Organization {
        const json = this.toJSON();
        let result = new Organization();
        result.init(json);
        return result;
    }
}

export interface IOrganization {
    branchId: number | undefined;
    groupName: string | undefined;
    contacts: string | undefined;
    mobile: string | undefined;
    remand: string | undefined;
    discount: string | undefined;
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Activity implements IActivity {
    branchId: number | undefined;
    activityNo: string | undefined;
    sourceId: number;
    source: Source;
    orgActivityId: number | undefined;
    activityDate: moment.Moment;
    playDate: moment.Moment;
    customerId: number | undefined;
    customer: Customer;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: number;
    payMethod: PayMethod;
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    remark: string | undefined;
    isPrint: boolean;
    closed: boolean;
    totalQuantity: number;
    totalAmount: number;
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    organizationId: number | undefined;
    organization: Organization;
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.organizationId = data["organizationId"];
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityDetail.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Activity {
        data = typeof data === 'object' ? data : {};
        let result = new Activity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["organizationId"] = this.organizationId;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Activity {
        const json = this.toJSON();
        let result = new Activity();
        result.init(json);
        return result;
    }
}

export interface IActivity {
    branchId: number | undefined;
    activityNo: string | undefined;
    sourceId: number;
    source: Source;
    orgActivityId: number | undefined;
    activityDate: moment.Moment;
    playDate: moment.Moment;
    customerId: number | undefined;
    customer: Customer;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: number;
    payMethod: PayMethod;
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    remark: string | undefined;
    isPrint: boolean;
    closed: boolean;
    totalQuantity: number;
    totalAmount: number;
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    organizationId: number | undefined;
    organization: Organization;
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum TicketModeEnum {
    OnebyOne = <any>"OnebyOne", 
    OneByMore = <any>"OneByMore", 
}

export enum TicketTypeEnum {
    Card = <any>"Card", 
    Paper = <any>"Paper", 
}

export enum CheckMethodEnum {
    NumberCheck = <any>"NumberCheck", 
    TimeCheck = <any>"TimeCheck", 
    BalanceCheck = <any>"BalanceCheck", 
}

export enum TicketClassifyEnum {
    Adult = <any>"Adult", 
    Children = <any>"Children", 
    Old = <any>"Old", 
}

export enum AuditStatusEnum {
    WaiteAudit = <any>"WaiteAudit", 
    ThroughAudit = <any>"ThroughAudit", 
    RejecteAudit = <any>"RejecteAudit", 
}

export class Ticket implements ITicket {
    branchId: number | undefined;
    ticketName: string | undefined;
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    checkNum: number | undefined;
    effectiveLong: number | undefined;
    unitPrice: number;
    ticketLength: number | undefined;
    upperLimit: number | undefined;
    lowerLimit: number | undefined;
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    isEnabled: boolean;
    sort: number | undefined;
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicket) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.group = data["group"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Ticket {
        data = typeof data === 'object' ? data : {};
        let result = new Ticket();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["group"] = this.group;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Ticket {
        const json = this.toJSON();
        let result = new Ticket();
        result.init(json);
        return result;
    }
}

export interface ITicket {
    branchId: number | undefined;
    ticketName: string | undefined;
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    checkNum: number | undefined;
    effectiveLong: number | undefined;
    unitPrice: number;
    ticketLength: number | undefined;
    upperLimit: number | undefined;
    lowerLimit: number | undefined;
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    isEnabled: boolean;
    sort: number | undefined;
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum PositionEnum {
    Windows = <any>"windows", 
    Online = <any>"Online", 
}

export class WeChatScenicSpot implements IWeChatScenicSpot {
    branchId: number | undefined;
    scenicSpotName: string | undefined;
    parentId: number | undefined;
    parent: WeChatScenicSpot;
    coverPicture: string | undefined;
    scenicSpotAddr: string | undefined;
    openTime: moment.Moment;
    smokedWay: string | undefined;
    scheduledTime: string | undefined;
    focusPicture: string | undefined;
    isEnable: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IWeChatScenicSpot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? WeChatScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.coverPicture = data["coverPicture"];
            this.scenicSpotAddr = data["scenicSpotAddr"];
            this.openTime = data["openTime"] ? moment(data["openTime"].toString()) : <any>undefined;
            this.smokedWay = data["smokedWay"];
            this.scheduledTime = data["scheduledTime"];
            this.focusPicture = data["focusPicture"];
            this.isEnable = data["isEnable"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WeChatScenicSpot {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatScenicSpot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["coverPicture"] = this.coverPicture;
        data["scenicSpotAddr"] = this.scenicSpotAddr;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>undefined;
        data["smokedWay"] = this.smokedWay;
        data["scheduledTime"] = this.scheduledTime;
        data["focusPicture"] = this.focusPicture;
        data["isEnable"] = this.isEnable;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeChatScenicSpot {
        const json = this.toJSON();
        let result = new WeChatScenicSpot();
        result.init(json);
        return result;
    }
}

export interface IWeChatScenicSpot {
    branchId: number | undefined;
    scenicSpotName: string | undefined;
    parentId: number | undefined;
    parent: WeChatScenicSpot;
    coverPicture: string | undefined;
    scenicSpotAddr: string | undefined;
    openTime: moment.Moment;
    smokedWay: string | undefined;
    scheduledTime: string | undefined;
    focusPicture: string | undefined;
    isEnable: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class TicketPrice implements ITicketPrice {
    branchId: number | undefined;
    ticketId: number;
    ticket: Ticket;
    price: number;
    rDiscount: number;
    upperTime: moment.Moment;
    lowerTime: moment.Moment;
    position: PositionEnum;
    isEnabled: boolean;
    sort: number | undefined;
    ticketName: string | undefined;
    wechatScenicSpotId: number | undefined;
    weChatScenicSpot: WeChatScenicSpot;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rDiscount = 1;
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.price = data["price"];
            this.rDiscount = data["rDiscount"] !== undefined ? data["rDiscount"] : 1;
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.position = data["position"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.ticketName = data["ticketName"];
            this.wechatScenicSpotId = data["wechatScenicSpotId"];
            this.weChatScenicSpot = data["weChatScenicSpot"] ? WeChatScenicSpot.fromJS(data["weChatScenicSpot"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketPrice {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["position"] = this.position;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["ticketName"] = this.ticketName;
        data["wechatScenicSpotId"] = this.wechatScenicSpotId;
        data["weChatScenicSpot"] = this.weChatScenicSpot ? this.weChatScenicSpot.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketPrice {
        const json = this.toJSON();
        let result = new TicketPrice();
        result.init(json);
        return result;
    }
}

export interface ITicketPrice {
    branchId: number | undefined;
    ticketId: number;
    ticket: Ticket;
    price: number;
    rDiscount: number;
    upperTime: moment.Moment;
    lowerTime: moment.Moment;
    position: PositionEnum;
    isEnabled: boolean;
    sort: number | undefined;
    ticketName: string | undefined;
    wechatScenicSpotId: number | undefined;
    weChatScenicSpot: WeChatScenicSpot;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityDetail implements IActivityDetail {
    branchId: number | undefined;
    activityId: number;
    activity: Activity;
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    quantity: number;
    unitPrice: number;
    discount: number;
    salePrice: number;
    totalAmount: number;
    remark: string | undefined;
    accountId: number | undefined;
    accountDetailId: number | undefined;
    orgDetailId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.accountDetailId = data["accountDetailId"];
            this.orgDetailId = data["orgDetailId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["accountDetailId"] = this.accountDetailId;
        data["orgDetailId"] = this.orgDetailId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityDetail {
        const json = this.toJSON();
        let result = new ActivityDetail();
        result.init(json);
        return result;
    }
}

export interface IActivityDetail {
    branchId: number | undefined;
    activityId: number;
    activity: Activity;
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    quantity: number;
    unitPrice: number;
    discount: number;
    salePrice: number;
    totalAmount: number;
    remark: string | undefined;
    accountId: number | undefined;
    accountDetailId: number | undefined;
    orgDetailId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.AccountDetail */
export class AccountDetailEditDto implements IAccountDetailEditDto {
    /** Id */
    id: number | undefined;
    /** AccountId */
    accountId: number;
    account: Account;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;

    constructor(data?: IAccountDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accountId = data["accountId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccountDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccountDetailEditDto {
        const json = this.toJSON();
        let result = new AccountDetailEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.AccountDetail */
export interface IAccountDetailEditDto {
    /** Id */
    id: number | undefined;
    /** AccountId */
    accountId: number;
    account: Account;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
}

export class CreateOrUpdateAccountDetailInput implements ICreateOrUpdateAccountDetailInput {
    accountDetail: AccountDetailEditDto;

    constructor(data?: ICreateOrUpdateAccountDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.accountDetail = new AccountDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.accountDetail = data["accountDetail"] ? AccountDetailEditDto.fromJS(data["accountDetail"]) : new AccountDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateAccountDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateAccountDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountDetail"] = this.accountDetail ? this.accountDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateAccountDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateAccountDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateAccountDetailInput {
    accountDetail: AccountDetailEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.AccountDetail */
export class AccountDetailListDto implements IAccountDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** AccountId */
    accountId: number;
    account: Account;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAccountDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountId = data["accountId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountId"] = this.accountId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AccountDetailListDto {
        const json = this.toJSON();
        let result = new AccountDetailListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.AccountDetail */
export interface IAccountDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** AccountId */
    accountId: number;
    account: Account;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetAccountDetailForEditOutput implements IGetAccountDetailForEditOutput {
    accountDetail: AccountDetailEditDto;

    constructor(data?: IGetAccountDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accountDetail = data["accountDetail"] ? AccountDetailEditDto.fromJS(data["accountDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAccountDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accountDetail"] = this.accountDetail ? this.accountDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAccountDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetAccountDetailForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetAccountDetailForEditOutput {
    accountDetail: AccountDetailEditDto;
}

export class PagedResultDtoOfAccountDetailListDto implements IPagedResultDtoOfAccountDetailListDto {
    totalCount: number;
    items: AccountDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AccountDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAccountDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAccountDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAccountDetailListDto {
    totalCount: number;
    items: AccountDetailListDto[] | undefined;
}

export enum PayMethodEnum {
    PaySuccess = <any>"PaySuccess", 
    PayFalse = <any>"PayFalse", 
}

export class TravelAgency implements ITravelAgency {
    branchId: number | undefined;
    travelName: string | undefined;
    mobile: string | undefined;
    contacts: string | undefined;
    isEnabled: boolean;
    discount: number;
    payMethod: PayMethodEnum;
    totalSum: number;
    prepaidAmount: number;
    alarmAmount: number;
    upperLimit: number | undefined;
    lowerlimit: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITravelAgency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelAgency {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelAgency {
        const json = this.toJSON();
        let result = new TravelAgency();
        result.init(json);
        return result;
    }
}

export interface ITravelAgency {
    branchId: number | undefined;
    travelName: string | undefined;
    mobile: string | undefined;
    contacts: string | undefined;
    isEnabled: boolean;
    discount: number;
    payMethod: PayMethodEnum;
    totalSum: number;
    prepaidAmount: number;
    alarmAmount: number;
    upperLimit: number | undefined;
    lowerlimit: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.Activity */
export class ActivityEditDto implements IActivityEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** Closed */
    closed: boolean;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** AccountsId */
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityDetail[] | undefined;

    constructor(data?: IActivityEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ActivityEditDto {
        const json = this.toJSON();
        let result = new ActivityEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Activity */
export interface IActivityEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** Closed */
    closed: boolean;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** AccountsId */
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityDetail[] | undefined;
}

export class CreateOrUpdateActivityInput implements ICreateOrUpdateActivityInput {
    activity: ActivityEditDto;

    constructor(data?: ICreateOrUpdateActivityInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activity = new ActivityEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activity = data["activity"] ? ActivityEditDto.fromJS(data["activity"]) : new ActivityEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityInput {
    activity: ActivityEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Activity */
export class ActivityListDto implements IActivityListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** Closed */
    closed: boolean;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** AccountsId */
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.orgActivityId = data["orgActivityId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.payStatus = data["payStatus"];
            this.activityType = data["activityType"];
            this.remark = data["remark"];
            this.isPrint = data["isPrint"];
            this.closed = data["closed"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.accountsId = data["accountsId"];
            this.account = data["account"] ? Account.fromJS(data["account"]) : <any>undefined;
            this.orderType = data["orderType"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityDetail.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["orgActivityId"] = this.orgActivityId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["payStatus"] = this.payStatus;
        data["activityType"] = this.activityType;
        data["remark"] = this.remark;
        data["isPrint"] = this.isPrint;
        data["closed"] = this.closed;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["accountsId"] = this.accountsId;
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        data["orderType"] = this.orderType;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityListDto {
        const json = this.toJSON();
        let result = new ActivityListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Activity */
export interface IActivityListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    payStatus: PayStatusEnum;
    activityType: ActivityTypeEnum;
    /** Remark */
    remark: string | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** Closed */
    closed: boolean;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** AccountsId */
    accountsId: number | undefined;
    account: Account;
    orderType: OrderTypeEnum;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class KeyValuePairOfStringString implements IKeyValuePairOfStringString {
    readonly key: string | undefined;
    readonly value: string | undefined;

    constructor(data?: IKeyValuePairOfStringString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).key = data["key"];
            (<any>this).value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringString {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): KeyValuePairOfStringString {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringString();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringString {
    key: string | undefined;
    value: string | undefined;
}

/** 读取可编辑的Dto */
export class GetActivityForEditOutput implements IGetActivityForEditOutput {
    activity: ActivityEditDto;
    payStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    activityTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    orderTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetActivityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activity = data["activity"] ? ActivityEditDto.fromJS(data["activity"]) : <any>undefined;
            if (data["payStatusEnumTypeEnum"] && data["payStatusEnumTypeEnum"].constructor === Array) {
                this.payStatusEnumTypeEnum = [] as any;
                for (let item of data["payStatusEnumTypeEnum"])
                    this.payStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["activityTypeEnumTypeEnum"] && data["activityTypeEnumTypeEnum"].constructor === Array) {
                this.activityTypeEnumTypeEnum = [] as any;
                for (let item of data["activityTypeEnumTypeEnum"])
                    this.activityTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["orderTypeEnumTypeEnum"] && data["orderTypeEnumTypeEnum"].constructor === Array) {
                this.orderTypeEnumTypeEnum = [] as any;
                for (let item of data["orderTypeEnumTypeEnum"])
                    this.orderTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetActivityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        if (this.payStatusEnumTypeEnum && this.payStatusEnumTypeEnum.constructor === Array) {
            data["payStatusEnumTypeEnum"] = [];
            for (let item of this.payStatusEnumTypeEnum)
                data["payStatusEnumTypeEnum"].push(item.toJSON());
        }
        if (this.activityTypeEnumTypeEnum && this.activityTypeEnumTypeEnum.constructor === Array) {
            data["activityTypeEnumTypeEnum"] = [];
            for (let item of this.activityTypeEnumTypeEnum)
                data["activityTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.orderTypeEnumTypeEnum && this.orderTypeEnumTypeEnum.constructor === Array) {
            data["orderTypeEnumTypeEnum"] = [];
            for (let item of this.orderTypeEnumTypeEnum)
                data["orderTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetActivityForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetActivityForEditOutput {
    activity: ActivityEditDto;
    payStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    activityTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    orderTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetActivitysInput implements IGetActivitysInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetActivitysInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetActivitysInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivitysInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetActivitysInput {
        const json = this.toJSON();
        let result = new GetActivitysInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetActivitysInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfActivityListDto implements IPagedResultDtoOfActivityListDto {
    totalCount: number;
    items: ActivityListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityListDto {
    totalCount: number;
    items: ActivityListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityDetail */
export class ActivityDetailEditDto implements IActivityDetailEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityId */
    activityId: number;
    activity: Activity;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** Quantity */
    quantity: number;
    /** UnitPrice */
    unitPrice: number;
    /** Discount */
    discount: number;
    /** SalePrice */
    salePrice: number;
    /** TotalAmount */
    totalAmount: number;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: number | undefined;
    /** AccountDetailId */
    accountDetailId: number | undefined;
    /** OrgDetailId */
    orgDetailId: number | undefined;
    customer: Customer;

    constructor(data?: IActivityDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.accountDetailId = data["accountDetailId"];
            this.orgDetailId = data["orgDetailId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["accountDetailId"] = this.accountDetailId;
        data["orgDetailId"] = this.orgDetailId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ActivityDetailEditDto {
        const json = this.toJSON();
        let result = new ActivityDetailEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityDetail */
export interface IActivityDetailEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityId */
    activityId: number;
    activity: Activity;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** Quantity */
    quantity: number;
    /** UnitPrice */
    unitPrice: number;
    /** Discount */
    discount: number;
    /** SalePrice */
    salePrice: number;
    /** TotalAmount */
    totalAmount: number;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: number | undefined;
    /** AccountDetailId */
    accountDetailId: number | undefined;
    /** OrgDetailId */
    orgDetailId: number | undefined;
    customer: Customer;
}

export class CreateOrUpdateActivityDetailInput implements ICreateOrUpdateActivityDetailInput {
    activityDetail: ActivityDetailEditDto;

    constructor(data?: ICreateOrUpdateActivityDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityDetail = new ActivityDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityDetail = data["activityDetail"] ? ActivityDetailEditDto.fromJS(data["activityDetail"]) : new ActivityDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityDetailInput {
    activityDetail: ActivityDetailEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityDetail */
export class ActivityDetailListDto implements IActivityDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityId */
    activityId: number;
    activity: Activity;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** Quantity */
    quantity: number;
    /** UnitPrice */
    unitPrice: number;
    /** Discount */
    discount: number;
    /** SalePrice */
    salePrice: number;
    /** TotalAmount */
    totalAmount: number;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: number | undefined;
    /** AccountDetailId */
    accountDetailId: number | undefined;
    /** OrgDetailId */
    orgDetailId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.discount = data["discount"];
            this.salePrice = data["salePrice"];
            this.totalAmount = data["totalAmount"];
            this.remark = data["remark"];
            this.accountId = data["accountId"];
            this.accountDetailId = data["accountDetailId"];
            this.orgDetailId = data["orgDetailId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["discount"] = this.discount;
        data["salePrice"] = this.salePrice;
        data["totalAmount"] = this.totalAmount;
        data["remark"] = this.remark;
        data["accountId"] = this.accountId;
        data["accountDetailId"] = this.accountDetailId;
        data["orgDetailId"] = this.orgDetailId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityDetailListDto {
        const json = this.toJSON();
        let result = new ActivityDetailListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityDetail */
export interface IActivityDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityId */
    activityId: number;
    activity: Activity;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** Quantity */
    quantity: number;
    /** UnitPrice */
    unitPrice: number;
    /** Discount */
    discount: number;
    /** SalePrice */
    salePrice: number;
    /** TotalAmount */
    totalAmount: number;
    /** Remark */
    remark: string | undefined;
    /** AccountId */
    accountId: number | undefined;
    /** AccountDetailId */
    accountDetailId: number | undefined;
    /** OrgDetailId */
    orgDetailId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetActivityDetailForEditOutput implements IGetActivityDetailForEditOutput {
    activityDetail: ActivityDetailEditDto;

    constructor(data?: IGetActivityDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityDetail = data["activityDetail"] ? ActivityDetailEditDto.fromJS(data["activityDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityDetailForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetActivityDetailForEditOutput {
    activityDetail: ActivityDetailEditDto;
}

export class PagedResultDtoOfActivityDetailListDto implements IPagedResultDtoOfActivityDetailListDto {
    totalCount: number;
    items: ActivityDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityDetailListDto {
    totalCount: number;
    items: ActivityDetailListDto[] | undefined;
}

export class ActivityTemp implements IActivityTemp {
    branchId: number | undefined;
    activityNo: string | undefined;
    sourceId: number;
    source: Source;
    scheduleId: number;
    activityDate: moment.Moment;
    playDate: moment.Moment;
    customerId: number | undefined;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: number;
    payMethod: PayMethod;
    voucherNo: string | undefined;
    remark: string | undefined;
    totalQuantity: number;
    totalAmount: number;
    collectionPwd: string | undefined;
    collector: string | undefined;
    collectionCode: string | undefined;
    payTime: moment.Moment | undefined;
    activityId: number | undefined;
    organizationId: number | undefined;
    organization: Organization;
    activityDetails: ActivityTempDetail[] | undefined;
    openId: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityTemp) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collector = data["collector"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.organizationId = data["organizationId"];
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityTempDetail.fromJS(item));
            }
            this.openId = data["openId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTemp {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTemp();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collector"] = this.collector;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["organizationId"] = this.organizationId;
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["openId"] = this.openId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTemp {
        const json = this.toJSON();
        let result = new ActivityTemp();
        result.init(json);
        return result;
    }
}

export interface IActivityTemp {
    branchId: number | undefined;
    activityNo: string | undefined;
    sourceId: number;
    source: Source;
    scheduleId: number;
    activityDate: moment.Moment;
    playDate: moment.Moment;
    customerId: number | undefined;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    buyer: string | undefined;
    mobile: string | undefined;
    payMethodId: number;
    payMethod: PayMethod;
    voucherNo: string | undefined;
    remark: string | undefined;
    totalQuantity: number;
    totalAmount: number;
    collectionPwd: string | undefined;
    collector: string | undefined;
    collectionCode: string | undefined;
    payTime: moment.Moment | undefined;
    activityId: number | undefined;
    organizationId: number | undefined;
    organization: Organization;
    activityDetails: ActivityTempDetail[] | undefined;
    openId: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class ActivityTempDetail implements IActivityTempDetail {
    branchId: number | undefined;
    activityTempId: number;
    activityTemp: ActivityTemp;
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    ticketName: string | undefined;
    salePrice: number;
    quantity: number;
    uniPrice: number;
    discount: number;
    totalAmount: number;
    customerId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityTempDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.totalAmount = data["totalAmount"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["totalAmount"] = this.totalAmount;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempDetail {
        const json = this.toJSON();
        let result = new ActivityTempDetail();
        result.init(json);
        return result;
    }
}

export interface IActivityTempDetail {
    branchId: number | undefined;
    activityTempId: number;
    activityTemp: ActivityTemp;
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    ticketName: string | undefined;
    salePrice: number;
    quantity: number;
    uniPrice: number;
    discount: number;
    totalAmount: number;
    customerId: number | undefined;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityTemp */
export class ActivityTempEditDto implements IActivityTempEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityTempDetail[] | undefined;

    constructor(data?: IActivityTempEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collector = data["collector"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityTempDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ActivityTempEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collector"] = this.collector;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ActivityTempEditDto {
        const json = this.toJSON();
        let result = new ActivityTempEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityTemp */
export interface IActivityTempEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityTempDetail[] | undefined;
}

export class CreateOrUpdateActivityTempInput implements ICreateOrUpdateActivityTempInput {
    activityTemp: ActivityTempEditDto;

    constructor(data?: ICreateOrUpdateActivityTempInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityTemp = new ActivityTempEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTemp = data["activityTemp"] ? ActivityTempEditDto.fromJS(data["activityTemp"]) : new ActivityTempEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityTempInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityTempInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityTempInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityTempInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityTempInput {
    activityTemp: ActivityTempEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityTemp */
export class ActivityTempListDto implements IActivityTempListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityTempDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityTempListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityNo = data["activityNo"];
            this.sourceId = data["sourceId"];
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.scheduleId = data["scheduleId"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.playDate = data["playDate"] ? moment(data["playDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.orderType = data["orderType"];
            this.payStatus = data["payStatus"];
            this.buyer = data["buyer"];
            this.mobile = data["mobile"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.voucherNo = data["voucherNo"];
            this.remark = data["remark"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
            this.collectionPwd = data["collectionPwd"];
            this.collector = data["collector"];
            this.collectionCode = data["collectionCode"];
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.activityId = data["activityId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["activityDetails"] && data["activityDetails"].constructor === Array) {
                this.activityDetails = [] as any;
                for (let item of data["activityDetails"])
                    this.activityDetails.push(ActivityTempDetail.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityNo"] = this.activityNo;
        data["sourceId"] = this.sourceId;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["scheduleId"] = this.scheduleId;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["playDate"] = this.playDate ? this.playDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["orderType"] = this.orderType;
        data["payStatus"] = this.payStatus;
        data["buyer"] = this.buyer;
        data["mobile"] = this.mobile;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["voucherNo"] = this.voucherNo;
        data["remark"] = this.remark;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        data["collectionPwd"] = this.collectionPwd;
        data["collector"] = this.collector;
        data["collectionCode"] = this.collectionCode;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["activityId"] = this.activityId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.activityDetails && this.activityDetails.constructor === Array) {
            data["activityDetails"] = [];
            for (let item of this.activityDetails)
                data["activityDetails"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempListDto {
        const json = this.toJSON();
        let result = new ActivityTempListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityTemp */
export interface IActivityTempListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityNo */
    activityNo: string | undefined;
    /** SourceId */
    sourceId: number;
    source: Source;
    /** ScheduleId */
    scheduleId: number;
    /** ActivityDate */
    activityDate: moment.Moment;
    /** PlayDate */
    playDate: moment.Moment;
    /** CustomerId */
    customerId: number;
    orderType: OrderTypeEnum;
    payStatus: PayStatusEnum;
    /** Buyer */
    buyer: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** Remark */
    remark: string | undefined;
    /** TotalQuantity */
    totalQuantity: number;
    /** TotalAmount */
    totalAmount: number;
    /** CollectionPwd */
    collectionPwd: string | undefined;
    /** Collector */
    collector: string | undefined;
    /** CollectionCode */
    collectionCode: string | undefined;
    /** PayTime */
    payTime: moment.Moment | undefined;
    /** ActivityId */
    activityId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number | undefined;
    travelAgency: TravelAgency;
    /** ActivityDetails */
    activityDetails: ActivityTempDetail[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetActivityTempForEditOutput implements IGetActivityTempForEditOutput {
    activityTemp: ActivityTempEditDto;
    orderTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    payStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetActivityTempForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTemp = data["activityTemp"] ? ActivityTempEditDto.fromJS(data["activityTemp"]) : <any>undefined;
            if (data["orderTypeEnumTypeEnum"] && data["orderTypeEnumTypeEnum"].constructor === Array) {
                this.orderTypeEnumTypeEnum = [] as any;
                for (let item of data["orderTypeEnumTypeEnum"])
                    this.orderTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["payStatusEnumTypeEnum"] && data["payStatusEnumTypeEnum"].constructor === Array) {
                this.payStatusEnumTypeEnum = [] as any;
                for (let item of data["payStatusEnumTypeEnum"])
                    this.payStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetActivityTempForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityTempForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        if (this.orderTypeEnumTypeEnum && this.orderTypeEnumTypeEnum.constructor === Array) {
            data["orderTypeEnumTypeEnum"] = [];
            for (let item of this.orderTypeEnumTypeEnum)
                data["orderTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.payStatusEnumTypeEnum && this.payStatusEnumTypeEnum.constructor === Array) {
            data["payStatusEnumTypeEnum"] = [];
            for (let item of this.payStatusEnumTypeEnum)
                data["payStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetActivityTempForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityTempForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetActivityTempForEditOutput {
    activityTemp: ActivityTempEditDto;
    orderTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    payStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfActivityTempListDto implements IPagedResultDtoOfActivityTempListDto {
    totalCount: number;
    items: ActivityTempListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityTempListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityTempListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityTempListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityTempListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityTempListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityTempListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityTempListDto {
    totalCount: number;
    items: ActivityTempListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityTempDetail */
export class ActivityTempDetailEditDto implements IActivityTempDetailEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityTempId */
    activityTempId: number;
    activityTemp: ActivityTemp;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** TicketName */
    ticketName: string | undefined;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** TotalAmount */
    totalAmount: number;
    /** CustomerId */
    customerId: number;
    customer: Customer;

    constructor(data?: IActivityTempDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.totalAmount = data["totalAmount"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ActivityTempDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["totalAmount"] = this.totalAmount;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): ActivityTempDetailEditDto {
        const json = this.toJSON();
        let result = new ActivityTempDetailEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.ActivityTempDetail */
export interface IActivityTempDetailEditDto {
    /** Id */
    id: number | undefined;
    /** ActivityTempId */
    activityTempId: number;
    activityTemp: ActivityTemp;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** TicketName */
    ticketName: string | undefined;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** TotalAmount */
    totalAmount: number;
    /** CustomerId */
    customerId: number;
    customer: Customer;
}

export class CreateOrUpdateActivityTempDetailInput implements ICreateOrUpdateActivityTempDetailInput {
    activityTempDetail: ActivityTempDetailEditDto;

    constructor(data?: ICreateOrUpdateActivityTempDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.activityTempDetail = new ActivityTempDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTempDetail = data["activityTempDetail"] ? ActivityTempDetailEditDto.fromJS(data["activityTempDetail"]) : new ActivityTempDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateActivityTempDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateActivityTempDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTempDetail"] = this.activityTempDetail ? this.activityTempDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateActivityTempDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateActivityTempDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateActivityTempDetailInput {
    activityTempDetail: ActivityTempDetailEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityTempDetail */
export class ActivityTempDetailListDto implements IActivityTempDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityTempId */
    activityTempId: number;
    activityTemp: ActivityTemp;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** TicketName */
    ticketName: string | undefined;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** TotalAmount */
    totalAmount: number;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IActivityTempDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.activityTempId = data["activityTempId"];
            this.activityTemp = data["activityTemp"] ? ActivityTemp.fromJS(data["activityTemp"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticketName = data["ticketName"];
            this.salePrice = data["salePrice"];
            this.quantity = data["quantity"];
            this.uniPrice = data["uniPrice"];
            this.discount = data["discount"];
            this.totalAmount = data["totalAmount"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ActivityTempDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ActivityTempDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["activityTempId"] = this.activityTempId;
        data["activityTemp"] = this.activityTemp ? this.activityTemp.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticketName"] = this.ticketName;
        data["salePrice"] = this.salePrice;
        data["quantity"] = this.quantity;
        data["uniPrice"] = this.uniPrice;
        data["discount"] = this.discount;
        data["totalAmount"] = this.totalAmount;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ActivityTempDetailListDto {
        const json = this.toJSON();
        let result = new ActivityTempDetailListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.ActivityTempDetail */
export interface IActivityTempDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ActivityTempId */
    activityTempId: number;
    activityTemp: ActivityTemp;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    /** TicketName */
    ticketName: string | undefined;
    /** SalePrice */
    salePrice: number;
    /** Quantity */
    quantity: number;
    /** UniPrice */
    uniPrice: number;
    /** Discount */
    discount: number;
    /** TotalAmount */
    totalAmount: number;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetActivityTempDetailForEditOutput implements IGetActivityTempDetailForEditOutput {
    activityTempDetail: ActivityTempDetailEditDto;

    constructor(data?: IGetActivityTempDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.activityTempDetail = data["activityTempDetail"] ? ActivityTempDetailEditDto.fromJS(data["activityTempDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetActivityTempDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetActivityTempDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["activityTempDetail"] = this.activityTempDetail ? this.activityTempDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetActivityTempDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetActivityTempDetailForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetActivityTempDetailForEditOutput {
    activityTempDetail: ActivityTempDetailEditDto;
}

export class PagedResultDtoOfActivityTempDetailListDto implements IPagedResultDtoOfActivityTempDetailListDto {
    totalCount: number;
    items: ActivityTempDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfActivityTempDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ActivityTempDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivityTempDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivityTempDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivityTempDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivityTempDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivityTempDetailListDto {
    totalCount: number;
    items: ActivityTempDetailListDto[] | undefined;
}

export class AddressProvincetDto implements IAddressProvincetDto {
    code: string | undefined;
    name: string | undefined;

    constructor(data?: IAddressProvincetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressProvincetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressProvincetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): AddressProvincetDto {
        const json = this.toJSON();
        let result = new AddressProvincetDto();
        result.init(json);
        return result;
    }
}

export interface IAddressProvincetDto {
    code: string | undefined;
    name: string | undefined;
}

export class AddressCityDto implements IAddressCityDto {
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;

    constructor(data?: IAddressCityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provinceCode = data["provinceCode"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressCityDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressCityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provinceCode"] = this.provinceCode;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): AddressCityDto {
        const json = this.toJSON();
        let result = new AddressCityDto();
        result.init(json);
        return result;
    }
}

export interface IAddressCityDto {
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
}

export class AddressAreaDto implements IAddressAreaDto {
    cityCode: string | undefined;
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;

    constructor(data?: IAddressAreaDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.cityCode = data["cityCode"];
            this.provinceCode = data["provinceCode"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressAreaDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressAreaDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cityCode"] = this.cityCode;
        data["provinceCode"] = this.provinceCode;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): AddressAreaDto {
        const json = this.toJSON();
        let result = new AddressAreaDto();
        result.init(json);
        return result;
    }
}

export interface IAddressAreaDto {
    cityCode: string | undefined;
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
}

export class AddressStreetDto implements IAddressStreetDto {
    areaCode: string | undefined;
    cityCode: string | undefined;
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;

    constructor(data?: IAddressStreetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.areaCode = data["areaCode"];
            this.cityCode = data["cityCode"];
            this.provinceCode = data["provinceCode"];
            this.code = data["code"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): AddressStreetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressStreetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["areaCode"] = this.areaCode;
        data["cityCode"] = this.cityCode;
        data["provinceCode"] = this.provinceCode;
        data["code"] = this.code;
        data["name"] = this.name;
        return data; 
    }

    clone(): AddressStreetDto {
        const json = this.toJSON();
        let result = new AddressStreetDto();
        result.init(json);
        return result;
    }
}

export interface IAddressStreetDto {
    areaCode: string | undefined;
    cityCode: string | undefined;
    provinceCode: string | undefined;
    code: string | undefined;
    name: string | undefined;
}

/** 所有联动数据 */
export class AllAddressLinkage implements IAllAddressLinkage {
    /** 省 */
    provinces: AddressProvincetDto[] | undefined;
    /** 市 */
    citys: AddressCityDto[] | undefined;
    /** 县 */
    areas: AddressAreaDto[] | undefined;
    /** 镇 */
    streets: AddressStreetDto[] | undefined;

    constructor(data?: IAllAddressLinkage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["provinces"] && data["provinces"].constructor === Array) {
                this.provinces = [] as any;
                for (let item of data["provinces"])
                    this.provinces.push(AddressProvincetDto.fromJS(item));
            }
            if (data["citys"] && data["citys"].constructor === Array) {
                this.citys = [] as any;
                for (let item of data["citys"])
                    this.citys.push(AddressCityDto.fromJS(item));
            }
            if (data["areas"] && data["areas"].constructor === Array) {
                this.areas = [] as any;
                for (let item of data["areas"])
                    this.areas.push(AddressAreaDto.fromJS(item));
            }
            if (data["streets"] && data["streets"].constructor === Array) {
                this.streets = [] as any;
                for (let item of data["streets"])
                    this.streets.push(AddressStreetDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AllAddressLinkage {
        data = typeof data === 'object' ? data : {};
        let result = new AllAddressLinkage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.provinces && this.provinces.constructor === Array) {
            data["provinces"] = [];
            for (let item of this.provinces)
                data["provinces"].push(item.toJSON());
        }
        if (this.citys && this.citys.constructor === Array) {
            data["citys"] = [];
            for (let item of this.citys)
                data["citys"].push(item.toJSON());
        }
        if (this.areas && this.areas.constructor === Array) {
            data["areas"] = [];
            for (let item of this.areas)
                data["areas"].push(item.toJSON());
        }
        if (this.streets && this.streets.constructor === Array) {
            data["streets"] = [];
            for (let item of this.streets)
                data["streets"].push(item.toJSON());
        }
        return data; 
    }

    clone(): AllAddressLinkage {
        const json = this.toJSON();
        let result = new AllAddressLinkage();
        result.init(json);
        return result;
    }
}

/** 所有联动数据 */
export interface IAllAddressLinkage {
    /** 省 */
    provinces: AddressProvincetDto[] | undefined;
    /** 市 */
    citys: AddressCityDto[] | undefined;
    /** 县 */
    areas: AddressAreaDto[] | undefined;
    /** 镇 */
    streets: AddressStreetDto[] | undefined;
}

export class GetByCodeOutput implements IGetByCodeOutput {
    provinceName: string | undefined;
    cityName: string | undefined;
    areaName: string | undefined;
    streetName: string | undefined;

    constructor(data?: IGetByCodeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provinceName = data["provinceName"];
            this.cityName = data["cityName"];
            this.areaName = data["areaName"];
            this.streetName = data["streetName"];
        }
    }

    static fromJS(data: any): GetByCodeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetByCodeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provinceName"] = this.provinceName;
        data["cityName"] = this.cityName;
        data["areaName"] = this.areaName;
        data["streetName"] = this.streetName;
        return data; 
    }

    clone(): GetByCodeOutput {
        const json = this.toJSON();
        let result = new GetByCodeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetByCodeOutput {
    provinceName: string | undefined;
    cityName: string | undefined;
    areaName: string | undefined;
    streetName: string | undefined;
}

export enum AddressEnum {
    Provinces = <any>"Provinces", 
    Cities = <any>"Cities", 
    Areas = <any>"Areas", 
    Streets = <any>"Streets", 
}

/** 的列表DTO Yozeev.BusinessLogic.Common.AppVersion */
export class AppVersionEditDto implements IAppVersionEditDto {
    /** Id */
    id: number | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** ProgramName */
    programName: string | undefined;
    /** VersionId */
    versionId: string | undefined;

    constructor(data?: IAppVersionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.versionName = data["versionName"];
            this.programName = data["programName"];
            this.versionId = data["versionId"];
        }
    }

    static fromJS(data: any): AppVersionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppVersionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["versionName"] = this.versionName;
        data["programName"] = this.programName;
        data["versionId"] = this.versionId;
        return data; 
    }

    clone(): AppVersionEditDto {
        const json = this.toJSON();
        let result = new AppVersionEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Common.AppVersion */
export interface IAppVersionEditDto {
    /** Id */
    id: number | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** ProgramName */
    programName: string | undefined;
    /** VersionId */
    versionId: string | undefined;
}

export class CreateOrUpdateAppVersionInput implements ICreateOrUpdateAppVersionInput {
    appVersion: AppVersionEditDto;

    constructor(data?: ICreateOrUpdateAppVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.appVersion = new AppVersionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.appVersion = data["appVersion"] ? AppVersionEditDto.fromJS(data["appVersion"]) : new AppVersionEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateAppVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateAppVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appVersion"] = this.appVersion ? this.appVersion.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateAppVersionInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateAppVersionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateAppVersionInput {
    appVersion: AppVersionEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.AppVersion */
export class AppVersionListDto implements IAppVersionListDto {
    /** BranchId */
    branchId: number | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** ProgramName */
    programName: string | undefined;
    /** VersionId */
    versionId: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAppVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.versionName = data["versionName"];
            this.programName = data["programName"];
            this.versionId = data["versionId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AppVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["versionName"] = this.versionName;
        data["programName"] = this.programName;
        data["versionId"] = this.versionId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AppVersionListDto {
        const json = this.toJSON();
        let result = new AppVersionListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.AppVersion */
export interface IAppVersionListDto {
    /** BranchId */
    branchId: number | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** ProgramName */
    programName: string | undefined;
    /** VersionId */
    versionId: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetAppVersionForEditOutput implements IGetAppVersionForEditOutput {
    appVersion: AppVersionEditDto;

    constructor(data?: IGetAppVersionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appVersion = data["appVersion"] ? AppVersionEditDto.fromJS(data["appVersion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAppVersionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAppVersionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appVersion"] = this.appVersion ? this.appVersion.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetAppVersionForEditOutput {
        const json = this.toJSON();
        let result = new GetAppVersionForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetAppVersionForEditOutput {
    appVersion: AppVersionEditDto;
}

export class PagedResultDtoOfAppVersionListDto implements IPagedResultDtoOfAppVersionListDto {
    totalCount: number;
    items: AppVersionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAppVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AppVersionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAppVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAppVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAppVersionListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAppVersionListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAppVersionListDto {
    totalCount: number;
    items: AppVersionListDto[] | undefined;
}

export class FileDto implements IFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileToken: string | undefined;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }

    clone(): FileDto {
        const json = this.toJSON();
        let result = new FileDto();
        result.init(json);
        return result;
    }
}

export interface IFileDto {
    fileName: string | undefined;
    fileType: string | undefined;
    fileToken: string | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    /** 用户Id */
    userId: number | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId: number | undefined;
    /** 服务名称 */
    serviceName: string | undefined;
    /** 方法名称 */
    methodName: string | undefined;
    /** 参数 */
    parameters: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment;
    /** 持续时间 */
    executionDuration: number;
    /** 客户端ip地址 */
    clientIpAddress: string | undefined;
    /** 客户端 */
    clientName: string | undefined;
    /** 浏览器信息 */
    browserInfo: string | undefined;
    /** 异常 */
    exception: string | undefined;
    customData: string | undefined;
    id: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }

    clone(): AuditLogListDto {
        const json = this.toJSON();
        let result = new AuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IAuditLogListDto {
    /** 用户Id */
    userId: number | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 模拟租户Id */
    impersonatorTenantId: number | undefined;
    /** 模拟用户Id */
    impersonatorUserId: number | undefined;
    /** 服务名称 */
    serviceName: string | undefined;
    /** 方法名称 */
    methodName: string | undefined;
    /** 参数 */
    parameters: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment;
    /** 持续时间 */
    executionDuration: number;
    /** 客户端ip地址 */
    clientIpAddress: string | undefined;
    /** 客户端 */
    clientName: string | undefined;
    /** 浏览器信息 */
    browserInfo: string | undefined;
    /** 异常 */
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export enum EntityChangeType {
    Created = <any>"Created", 
    Updated = <any>"Updated", 
    Deleted = <any>"Deleted", 
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    readonly changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityChangeListDto {
        const json = this.toJSON();
        let result = new EntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEntityChangeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }

    clone(): NameValueDto {
        const json = this.toJSON();
        let result = new NameValueDto();
        result.init(json);
        return result;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

/** 显示登录日志错误信息 */
export class LoginLogExceptionDto implements ILoginLogExceptionDto {
    details: string | undefined;

    constructor(data?: ILoginLogExceptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.details = data["details"];
        }
    }

    static fromJS(data: any): LoginLogExceptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginLogExceptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["details"] = this.details;
        return data; 
    }

    clone(): LoginLogExceptionDto {
        const json = this.toJSON();
        let result = new LoginLogExceptionDto();
        result.init(json);
        return result;
    }
}

/** 显示登录日志错误信息 */
export interface ILoginLogExceptionDto {
    details: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAuditLogListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

/** 显示登录信息 */
export class LoginLogModel implements ILoginLogModel {
    /** 用户名或邮箱 */
    userNameOrEmailAddress: string | undefined;
    /** 登录端 */
    sourceName: string | undefined;
    /** 登录端编码 */
    sourceCode: string | undefined;
    /** IP地址 */
    clientIpAddress: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment;
    /** 是否包含异常 */
    hasException: boolean;
    /** 异常 */
    exception: string | undefined;

    constructor(data?: ILoginLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.clientIpAddress = data["clientIpAddress"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.hasException = data["hasException"];
            this.exception = data["exception"];
        }
    }

    static fromJS(data: any): LoginLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["clientIpAddress"] = this.clientIpAddress;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["hasException"] = this.hasException;
        data["exception"] = this.exception;
        return data; 
    }

    clone(): LoginLogModel {
        const json = this.toJSON();
        let result = new LoginLogModel();
        result.init(json);
        return result;
    }
}

/** 显示登录信息 */
export interface ILoginLogModel {
    /** 用户名或邮箱 */
    userNameOrEmailAddress: string | undefined;
    /** 登录端 */
    sourceName: string | undefined;
    /** 登录端编码 */
    sourceCode: string | undefined;
    /** IP地址 */
    clientIpAddress: string | undefined;
    /** 执行时间 */
    executionTime: moment.Moment;
    /** 是否包含异常 */
    hasException: boolean;
    /** 异常 */
    exception: string | undefined;
}

export class PagedResultDtoOfLoginLogModel implements IPagedResultDtoOfLoginLogModel {
    totalCount: number;
    items: LoginLogModel[] | undefined;

    constructor(data?: IPagedResultDtoOfLoginLogModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LoginLogModel.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLoginLogModel {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLoginLogModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLoginLogModel {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLoginLogModel();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLoginLogModel {
    totalCount: number;
    items: LoginLogModel[] | undefined;
}

/** 的列表DTO Yozeev.SystemConfig.BasicConfig.Branch */
export class BranchEditDto implements IBranchEditDto {
    /** Id */
    id: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: Branch;
    /** BranchCode */
    branchCode: string | undefined;
    /** BranchName */
    branchName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IBranchEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): BranchEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): BranchEditDto {
        const json = this.toJSON();
        let result = new BranchEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.BasicConfig.Branch */
export interface IBranchEditDto {
    /** Id */
    id: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: Branch;
    /** BranchCode */
    branchCode: string | undefined;
    /** BranchName */
    branchName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdateBranchInput implements ICreateOrUpdateBranchInput {
    branch: BranchEditDto;

    constructor(data?: ICreateOrUpdateBranchInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.branch = new BranchEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.branch = data["branch"] ? BranchEditDto.fromJS(data["branch"]) : new BranchEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBranchInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBranchInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBranchInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBranchInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBranchInput {
    branch: BranchEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.BasicConfig.Branch */
export class BranchListDto implements IBranchListDto {
    /** ParentId */
    parentId: number | undefined;
    parent: Branch;
    /** BranchCode */
    branchCode: string | undefined;
    /** BranchName */
    branchName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBranchListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Branch.fromJS(data["parent"]) : <any>undefined;
            this.branchCode = data["branchCode"];
            this.branchName = data["branchName"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BranchListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["branchCode"] = this.branchCode;
        data["branchName"] = this.branchName;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BranchListDto {
        const json = this.toJSON();
        let result = new BranchListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.BasicConfig.Branch */
export interface IBranchListDto {
    /** ParentId */
    parentId: number | undefined;
    parent: Branch;
    /** BranchCode */
    branchCode: string | undefined;
    /** BranchName */
    branchName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetBranchForEditOutput implements IGetBranchForEditOutput {
    branch: BranchEditDto;

    constructor(data?: IGetBranchForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branch = data["branch"] ? BranchEditDto.fromJS(data["branch"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBranchForEditOutput {
        const json = this.toJSON();
        let result = new GetBranchForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetBranchForEditOutput {
    branch: BranchEditDto;
}

export class PagedResultDtoOfBranchListDto implements IPagedResultDtoOfBranchListDto {
    totalCount: number;
    items: BranchListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBranchListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BranchListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBranchListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBranchListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBranchListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBranchListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBranchListDto {
    totalCount: number;
    items: BranchListDto[] | undefined;
}

/** 的列表DTO Yozeev.SystemConfig.BranchUser */
export class BranchUserEditDto implements IBranchUserEditDto {
    /** Id */
    id: number | undefined;
    /** BranchId */
    branchId: number;
    branch: Branch;
    /** UserId */
    userId: number;
    user: User;

    constructor(data?: IBranchUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.branchId = data["branchId"];
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): BranchUserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchUserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["branchId"] = this.branchId;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data; 
    }

    clone(): BranchUserEditDto {
        const json = this.toJSON();
        let result = new BranchUserEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.BranchUser */
export interface IBranchUserEditDto {
    /** Id */
    id: number | undefined;
    /** BranchId */
    branchId: number;
    branch: Branch;
    /** UserId */
    userId: number;
    user: User;
}

export class CreateOrUpdateBranchUserInput implements ICreateOrUpdateBranchUserInput {
    branchUser: BranchUserEditDto;

    constructor(data?: ICreateOrUpdateBranchUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.branchUser = new BranchUserEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.branchUser = data["branchUser"] ? BranchUserEditDto.fromJS(data["branchUser"]) : new BranchUserEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateBranchUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateBranchUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchUser"] = this.branchUser ? this.branchUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateBranchUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateBranchUserInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateBranchUserInput {
    branchUser: BranchUserEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.BranchUser */
export class BranchUserListDto implements IBranchUserListDto {
    /** BranchId */
    branchId: number;
    branch: Branch;
    /** UserId */
    userId: number;
    user: User;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IBranchUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.userId = data["userId"];
            this.user = data["user"] ? User.fromJS(data["user"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BranchUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BranchUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): BranchUserListDto {
        const json = this.toJSON();
        let result = new BranchUserListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.BranchUser */
export interface IBranchUserListDto {
    /** BranchId */
    branchId: number;
    branch: Branch;
    /** UserId */
    userId: number;
    user: User;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetBranchUserForEditOutput implements IGetBranchUserForEditOutput {
    branchUser: BranchUserEditDto;

    constructor(data?: IGetBranchUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchUser = data["branchUser"] ? BranchUserEditDto.fromJS(data["branchUser"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBranchUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBranchUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchUser"] = this.branchUser ? this.branchUser.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetBranchUserForEditOutput {
        const json = this.toJSON();
        let result = new GetBranchUserForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetBranchUserForEditOutput {
    branchUser: BranchUserEditDto;
}

export class PagedResultDtoOfBranchUserListDto implements IPagedResultDtoOfBranchUserListDto {
    totalCount: number;
    items: BranchUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBranchUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(BranchUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBranchUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBranchUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfBranchUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfBranchUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfBranchUserListDto {
    totalCount: number;
    items: BranchUserListDto[] | undefined;
}

export enum MassageTypeEnum {
    Common = <any>"Common", 
}

/** 的列表DTO Yozeev.SystemConfig.SystemRecord.CheckRecord */
export class CheckRecordEditDto implements ICheckRecordEditDto {
    /** Id */
    id: number | undefined;
    /** Mobile */
    mobile: string | undefined;
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string | undefined;
    /** Captcha */
    captcha: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;

    constructor(data?: ICheckRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.mobile = data["mobile"];
            this.massageType = data["massageType"];
            this.checkExplain = data["checkExplain"];
            this.captcha = data["captcha"];
            this.isEnabled = data["isEnabled"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CheckRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["mobile"] = this.mobile;
        data["massageType"] = this.massageType;
        data["checkExplain"] = this.checkExplain;
        data["captcha"] = this.captcha;
        data["isEnabled"] = this.isEnabled;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CheckRecordEditDto {
        const json = this.toJSON();
        let result = new CheckRecordEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.SystemRecord.CheckRecord */
export interface ICheckRecordEditDto {
    /** Id */
    id: number | undefined;
    /** Mobile */
    mobile: string | undefined;
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string | undefined;
    /** Captcha */
    captcha: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
}

export class CreateOrUpdateCheckRecordInput implements ICreateOrUpdateCheckRecordInput {
    checkRecord: CheckRecordEditDto;

    constructor(data?: ICreateOrUpdateCheckRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.checkRecord = new CheckRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.checkRecord = data["checkRecord"] ? CheckRecordEditDto.fromJS(data["checkRecord"]) : new CheckRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateCheckRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCheckRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkRecord"] = this.checkRecord ? this.checkRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateCheckRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCheckRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCheckRecordInput {
    checkRecord: CheckRecordEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.SystemRecord.CheckRecord */
export class CheckRecordListDto implements ICheckRecordListDto {
    /** Mobile */
    mobile: string | undefined;
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string | undefined;
    /** Captcha */
    captcha: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICheckRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.mobile = data["mobile"];
            this.massageType = data["massageType"];
            this.checkExplain = data["checkExplain"];
            this.captcha = data["captcha"];
            this.isEnabled = data["isEnabled"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CheckRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CheckRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mobile"] = this.mobile;
        data["massageType"] = this.massageType;
        data["checkExplain"] = this.checkExplain;
        data["captcha"] = this.captcha;
        data["isEnabled"] = this.isEnabled;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CheckRecordListDto {
        const json = this.toJSON();
        let result = new CheckRecordListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.SystemRecord.CheckRecord */
export interface ICheckRecordListDto {
    /** Mobile */
    mobile: string | undefined;
    massageType: MassageTypeEnum;
    /** CheckExplain */
    checkExplain: string | undefined;
    /** Captcha */
    captcha: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** CheckTime */
    checkTime: moment.Moment;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetCheckRecordForEditOutput implements IGetCheckRecordForEditOutput {
    checkRecord: CheckRecordEditDto;
    massageTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetCheckRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.checkRecord = data["checkRecord"] ? CheckRecordEditDto.fromJS(data["checkRecord"]) : <any>undefined;
            if (data["massageTypeEnumTypeEnum"] && data["massageTypeEnumTypeEnum"].constructor === Array) {
                this.massageTypeEnumTypeEnum = [] as any;
                for (let item of data["massageTypeEnumTypeEnum"])
                    this.massageTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCheckRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCheckRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["checkRecord"] = this.checkRecord ? this.checkRecord.toJSON() : <any>undefined;
        if (this.massageTypeEnumTypeEnum && this.massageTypeEnumTypeEnum.constructor === Array) {
            data["massageTypeEnumTypeEnum"] = [];
            for (let item of this.massageTypeEnumTypeEnum)
                data["massageTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetCheckRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetCheckRecordForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetCheckRecordForEditOutput {
    checkRecord: CheckRecordEditDto;
    massageTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfCheckRecordListDto implements IPagedResultDtoOfCheckRecordListDto {
    totalCount: number;
    items: CheckRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCheckRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(CheckRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCheckRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCheckRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCheckRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCheckRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCheckRecordListDto {
    totalCount: number;
    items: CheckRecordListDto[] | undefined;
}

export enum DeviceTypeEnum {
    TicketMachine = <any>"TicketMachine", 
    GateMachine = <any>"GateMachine", 
    FaceMachine = <any>"FaceMachine", 
    SelfhelpMachine = <any>"SelfhelpMachine", 
    HandMachine = <any>"HandMachine", 
}

/** 的列表DTO Yozeev.SystemConfig.ClientVersion */
export class ClientVersionEditDto implements IClientVersionEditDto {
    /** Id */
    id: number | undefined;
    /** AppName */
    appName: string | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** VersionCode */
    versionCode: string | undefined;
    /** VersionDesc */
    versionDesc: string | undefined;
    deviceType: DeviceTypeEnum;

    constructor(data?: IClientVersionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appName = data["appName"];
            this.versionName = data["versionName"];
            this.versionCode = data["versionCode"];
            this.versionDesc = data["versionDesc"];
            this.deviceType = data["deviceType"];
        }
    }

    static fromJS(data: any): ClientVersionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVersionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appName"] = this.appName;
        data["versionName"] = this.versionName;
        data["versionCode"] = this.versionCode;
        data["versionDesc"] = this.versionDesc;
        data["deviceType"] = this.deviceType;
        return data; 
    }

    clone(): ClientVersionEditDto {
        const json = this.toJSON();
        let result = new ClientVersionEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.ClientVersion */
export interface IClientVersionEditDto {
    /** Id */
    id: number | undefined;
    /** AppName */
    appName: string | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** VersionCode */
    versionCode: string | undefined;
    /** VersionDesc */
    versionDesc: string | undefined;
    deviceType: DeviceTypeEnum;
}

export class CreateOrUpdateClientVersionInput implements ICreateOrUpdateClientVersionInput {
    clientVersion: ClientVersionEditDto;

    constructor(data?: ICreateOrUpdateClientVersionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.clientVersion = new ClientVersionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.clientVersion = data["clientVersion"] ? ClientVersionEditDto.fromJS(data["clientVersion"]) : new ClientVersionEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateClientVersionInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateClientVersionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientVersion"] = this.clientVersion ? this.clientVersion.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateClientVersionInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateClientVersionInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateClientVersionInput {
    clientVersion: ClientVersionEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.ClientVersion */
export class ClientVersionListDto implements IClientVersionListDto {
    /** AppName */
    appName: string | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** VersionCode */
    versionCode: string | undefined;
    /** VersionDesc */
    versionDesc: string | undefined;
    deviceType: DeviceTypeEnum;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IClientVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appName = data["appName"];
            this.versionName = data["versionName"];
            this.versionCode = data["versionCode"];
            this.versionDesc = data["versionDesc"];
            this.deviceType = data["deviceType"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ClientVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ClientVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appName"] = this.appName;
        data["versionName"] = this.versionName;
        data["versionCode"] = this.versionCode;
        data["versionDesc"] = this.versionDesc;
        data["deviceType"] = this.deviceType;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ClientVersionListDto {
        const json = this.toJSON();
        let result = new ClientVersionListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.ClientVersion */
export interface IClientVersionListDto {
    /** AppName */
    appName: string | undefined;
    /** VersionName */
    versionName: string | undefined;
    /** VersionCode */
    versionCode: string | undefined;
    /** VersionDesc */
    versionDesc: string | undefined;
    deviceType: DeviceTypeEnum;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetClientVersionForEditOutput implements IGetClientVersionForEditOutput {
    clientVersion: ClientVersionEditDto;
    deviceTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetClientVersionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientVersion = data["clientVersion"] ? ClientVersionEditDto.fromJS(data["clientVersion"]) : <any>undefined;
            if (data["deviceTypeEnumTypeEnum"] && data["deviceTypeEnumTypeEnum"].constructor === Array) {
                this.deviceTypeEnumTypeEnum = [] as any;
                for (let item of data["deviceTypeEnumTypeEnum"])
                    this.deviceTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetClientVersionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetClientVersionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientVersion"] = this.clientVersion ? this.clientVersion.toJSON() : <any>undefined;
        if (this.deviceTypeEnumTypeEnum && this.deviceTypeEnumTypeEnum.constructor === Array) {
            data["deviceTypeEnumTypeEnum"] = [];
            for (let item of this.deviceTypeEnumTypeEnum)
                data["deviceTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetClientVersionForEditOutput {
        const json = this.toJSON();
        let result = new GetClientVersionForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetClientVersionForEditOutput {
    clientVersion: ClientVersionEditDto;
    deviceTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfClientVersionListDto implements IPagedResultDtoOfClientVersionListDto {
    totalCount: number;
    items: ClientVersionListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfClientVersionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ClientVersionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfClientVersionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfClientVersionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfClientVersionListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfClientVersionListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfClientVersionListDto {
    totalCount: number;
    items: ClientVersionListDto[] | undefined;
}

export class CommonLookupFindUsersInput implements ICommonLookupFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filterText: string | undefined;

    constructor(data?: ICommonLookupFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filterText = data["filterText"];
        }
    }

    static fromJS(data: any): CommonLookupFindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new CommonLookupFindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filterText"] = this.filterText;
        return data; 
    }

    clone(): CommonLookupFindUsersInput {
        const json = this.toJSON();
        let result = new CommonLookupFindUsersInput();
        result.init(json);
        return result;
    }
}

export interface ICommonLookupFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number;
    skipCount: number;
    filterText: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): GetDefaultEditionNameOutput {
        const json = this.toJSON();
        let result = new GetDefaultEditionNameOutput();
        result.init(json);
        return result;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): SubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new SubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfSubscribableEditionComboboxItemDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class ComboboxItemDtoTOfInt32 implements IComboboxItemDtoTOfInt32 {
    value: number;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: IComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDtoTOfInt32 {
        const json = this.toJSON();
        let result = new ComboboxItemDtoTOfInt32();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDtoTOfInt32 {
    value: number;
    displayText: string | undefined;
    isSelected: boolean;
}

export class ListResultDtoOfComboboxItemDtoTOfInt32 implements IListResultDtoOfComboboxItemDtoTOfInt32 {
    items: ComboboxItemDtoTOfInt32[] | undefined;

    constructor(data?: IListResultDtoOfComboboxItemDtoTOfInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ComboboxItemDtoTOfInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfComboboxItemDtoTOfInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfComboboxItemDtoTOfInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfComboboxItemDtoTOfInt32 {
        const json = this.toJSON();
        let result = new ListResultDtoOfComboboxItemDtoTOfInt32();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfComboboxItemDtoTOfInt32 {
    items: ComboboxItemDtoTOfInt32[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Customer */
export class CustomerEditDto implements ICustomerEditDto {
    /** Id */
    id: number | undefined;
    /** 姓名 */
    customerName: string | undefined;
    /** 手机号 */
    mobile: string | undefined;
    /** 登陆密码 */
    loginPwd: string | undefined;
    sex: SexEnum;
    /** 国家 */
    country: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 县 */
    county: string | undefined;
    /** 证件号 */
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    /** 职务 */
    job: string | undefined;
    /** 微信OpenID */
    openID: string | undefined;
    /** 照片 */
    photo: string | undefined;
    /** 出生日期 */
    dateOfBirth: moment.Moment | undefined;

    constructor(data?: ICustomerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.loginPwd = data["loginPwd"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["loginPwd"] = this.loginPwd;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        return data; 
    }

    clone(): CustomerEditDto {
        const json = this.toJSON();
        let result = new CustomerEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Customer */
export interface ICustomerEditDto {
    /** Id */
    id: number | undefined;
    /** 姓名 */
    customerName: string | undefined;
    /** 手机号 */
    mobile: string | undefined;
    /** 登陆密码 */
    loginPwd: string | undefined;
    sex: SexEnum;
    /** 国家 */
    country: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 县 */
    county: string | undefined;
    /** 证件号 */
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    /** 职务 */
    job: string | undefined;
    /** 微信OpenID */
    openID: string | undefined;
    /** 照片 */
    photo: string | undefined;
    /** 出生日期 */
    dateOfBirth: moment.Moment | undefined;
}

export class CreateOrUpdateCustomerInput implements ICreateOrUpdateCustomerInput {
    customer: CustomerEditDto;

    constructor(data?: ICreateOrUpdateCustomerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.customer = new CustomerEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : new CustomerEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateCustomerInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCustomerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateCustomerInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateCustomerInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateCustomerInput {
    customer: CustomerEditDto;
}

/** 判断客户是否已经存在的dto */
export class CustomerExistsDto implements ICustomerExistsDto {
    exist: boolean;
    customer: CustomerEditDto;

    constructor(data?: ICustomerExistsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.exist = data["exist"];
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CustomerExistsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerExistsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exist"] = this.exist;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CustomerExistsDto {
        const json = this.toJSON();
        let result = new CustomerExistsDto();
        result.init(json);
        return result;
    }
}

/** 判断客户是否已经存在的dto */
export interface ICustomerExistsDto {
    exist: boolean;
    customer: CustomerEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Customer */
export class CustomerListDto implements ICustomerListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 姓名 */
    customerName: string | undefined;
    /** 手机号 */
    mobile: string | undefined;
    /** 登陆密码 */
    loginPwd: string | undefined;
    sex: SexEnum;
    /** 国家 */
    country: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 县 */
    county: string | undefined;
    /** 证件号 */
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    /** 职务 */
    job: string | undefined;
    /** 微信OpenID */
    openID: string | undefined;
    /** 照片 */
    photo: string | undefined;
    /** 出生日期 */
    dateOfBirth: moment.Moment | undefined;
    readonly dateOfBirthStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ICustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerName = data["customerName"];
            this.mobile = data["mobile"];
            this.loginPwd = data["loginPwd"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.county = data["county"];
            this.certificatesNum = data["certificatesNum"];
            this.verifiableType = data["verifiableType"];
            this.job = data["job"];
            this.openID = data["openID"];
            this.photo = data["photo"];
            this.dateOfBirth = data["dateOfBirth"] ? moment(data["dateOfBirth"].toString()) : <any>undefined;
            (<any>this).dateOfBirthStr = data["dateOfBirthStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerName"] = this.customerName;
        data["mobile"] = this.mobile;
        data["loginPwd"] = this.loginPwd;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["county"] = this.county;
        data["certificatesNum"] = this.certificatesNum;
        data["verifiableType"] = this.verifiableType;
        data["job"] = this.job;
        data["openID"] = this.openID;
        data["photo"] = this.photo;
        data["dateOfBirth"] = this.dateOfBirth ? this.dateOfBirth.toISOString() : <any>undefined;
        data["dateOfBirthStr"] = this.dateOfBirthStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): CustomerListDto {
        const json = this.toJSON();
        let result = new CustomerListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Customer */
export interface ICustomerListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 姓名 */
    customerName: string | undefined;
    /** 手机号 */
    mobile: string | undefined;
    /** 登陆密码 */
    loginPwd: string | undefined;
    sex: SexEnum;
    /** 国家 */
    country: string | undefined;
    /** 省 */
    province: string | undefined;
    /** 市 */
    city: string | undefined;
    /** 县 */
    county: string | undefined;
    /** 证件号 */
    certificatesNum: string | undefined;
    verifiableType: VerifiableTypeEnum;
    /** 职务 */
    job: string | undefined;
    /** 微信OpenID */
    openID: string | undefined;
    /** 照片 */
    photo: string | undefined;
    /** 出生日期 */
    dateOfBirth: moment.Moment | undefined;
    dateOfBirthStr: string | undefined;
    creationTimeStr: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetCustomerForEditOutput implements IGetCustomerForEditOutput {
    customer: CustomerEditDto;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetCustomerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CustomerEditDto.fromJS(data["customer"]) : <any>undefined;
            if (data["sexEnumTypeEnum"] && data["sexEnumTypeEnum"].constructor === Array) {
                this.sexEnumTypeEnum = [] as any;
                for (let item of data["sexEnumTypeEnum"])
                    this.sexEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCustomerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        if (this.sexEnumTypeEnum && this.sexEnumTypeEnum.constructor === Array) {
            data["sexEnumTypeEnum"] = [];
            for (let item of this.sexEnumTypeEnum)
                data["sexEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetCustomerForEditOutput {
        const json = this.toJSON();
        let result = new GetCustomerForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetCustomerForEditOutput {
    customer: CustomerEditDto;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetCustomersInput implements IGetCustomersInput {
    /** CertificatesNum */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetCustomersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetCustomersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetCustomersInput {
        const json = this.toJSON();
        let result = new GetCustomersInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetCustomersInput {
    /** CertificatesNum */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfCustomerListDto implements IPagedResultDtoOfCustomerListDto {
    totalCount: number;
    items: CustomerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(CustomerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCustomerListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCustomerListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCustomerListDto {
    totalCount: number;
    items: CustomerListDto[] | undefined;
}

export class UploadUserPictureResultDto implements IUploadUserPictureResultDto {
    uri: string | undefined;

    constructor(data?: IUploadUserPictureResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): UploadUserPictureResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadUserPictureResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): UploadUserPictureResultDto {
        const json = this.toJSON();
        let result = new UploadUserPictureResultDto();
        result.init(json);
        return result;
    }
}

export interface IUploadUserPictureResultDto {
    uri: string | undefined;
}

export class UploadUserPictureDto implements IUploadUserPictureDto {
    pictureString: string | undefined;

    constructor(data?: IUploadUserPictureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pictureString = data["pictureString"];
        }
    }

    static fromJS(data: any): UploadUserPictureDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadUserPictureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pictureString"] = this.pictureString;
        return data; 
    }

    clone(): UploadUserPictureDto {
        const json = this.toJSON();
        let result = new UploadUserPictureDto();
        result.init(json);
        return result;
    }
}

export interface IUploadUserPictureDto {
    pictureString: string | undefined;
}

export class DateDictionary implements IDateDictionary {
    dictionaryName: string | undefined;
    dictionaryCode: string | undefined;
    sort: number | undefined;
    parentId: number | undefined;
    parent: DateDictionary;
    explain: string | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDateDictionary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DateDictionary {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DateDictionary {
        const json = this.toJSON();
        let result = new DateDictionary();
        result.init(json);
        return result;
    }
}

export interface IDateDictionary {
    dictionaryName: string | undefined;
    dictionaryCode: string | undefined;
    sort: number | undefined;
    parentId: number | undefined;
    parent: DateDictionary;
    explain: string | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.SystemConfig.BasicConfig.DateDictionary */
export class DateDictionaryEditDto implements IDateDictionaryEditDto {
    /** Id */
    id: number | undefined;
    /** DictionaryName */
    dictionaryName: string | undefined;
    /** DictionaryCode */
    dictionaryCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: DateDictionary;
    /** Explain */
    explain: string | undefined;

    constructor(data?: IDateDictionaryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
        }
    }

    static fromJS(data: any): DateDictionaryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionaryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        return data; 
    }

    clone(): DateDictionaryEditDto {
        const json = this.toJSON();
        let result = new DateDictionaryEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.BasicConfig.DateDictionary */
export interface IDateDictionaryEditDto {
    /** Id */
    id: number | undefined;
    /** DictionaryName */
    dictionaryName: string | undefined;
    /** DictionaryCode */
    dictionaryCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: DateDictionary;
    /** Explain */
    explain: string | undefined;
}

export class CreateOrUpdateDateDictionaryInput implements ICreateOrUpdateDateDictionaryInput {
    dateDictionary: DateDictionaryEditDto;

    constructor(data?: ICreateOrUpdateDateDictionaryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dateDictionary = new DateDictionaryEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.dateDictionary = data["dateDictionary"] ? DateDictionaryEditDto.fromJS(data["dateDictionary"]) : new DateDictionaryEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateDateDictionaryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDateDictionaryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateDictionary"] = this.dateDictionary ? this.dateDictionary.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateDateDictionaryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDateDictionaryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDateDictionaryInput {
    dateDictionary: DateDictionaryEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.BasicConfig.DateDictionary */
export class DateDictionaryListDto implements IDateDictionaryListDto {
    /** DictionaryName */
    dictionaryName: string | undefined;
    /** DictionaryCode */
    dictionaryCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: DateDictionary;
    /** Explain */
    explain: string | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDateDictionaryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dictionaryName = data["dictionaryName"];
            this.dictionaryCode = data["dictionaryCode"];
            this.sort = data["sort"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? DateDictionary.fromJS(data["parent"]) : <any>undefined;
            this.explain = data["explain"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DateDictionaryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DateDictionaryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dictionaryName"] = this.dictionaryName;
        data["dictionaryCode"] = this.dictionaryCode;
        data["sort"] = this.sort;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["explain"] = this.explain;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DateDictionaryListDto {
        const json = this.toJSON();
        let result = new DateDictionaryListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.BasicConfig.DateDictionary */
export interface IDateDictionaryListDto {
    /** DictionaryName */
    dictionaryName: string | undefined;
    /** DictionaryCode */
    dictionaryCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: DateDictionary;
    /** Explain */
    explain: string | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetDateDictionaryForEditOutput implements IGetDateDictionaryForEditOutput {
    dateDictionary: DateDictionaryEditDto;

    constructor(data?: IGetDateDictionaryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateDictionary = data["dateDictionary"] ? DateDictionaryEditDto.fromJS(data["dateDictionary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDateDictionaryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDateDictionaryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateDictionary"] = this.dateDictionary ? this.dateDictionary.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDateDictionaryForEditOutput {
        const json = this.toJSON();
        let result = new GetDateDictionaryForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetDateDictionaryForEditOutput {
    dateDictionary: DateDictionaryEditDto;
}

export class PagedResultDtoOfDateDictionaryListDto implements IPagedResultDtoOfDateDictionaryListDto {
    totalCount: number;
    items: DateDictionaryListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDateDictionaryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(DateDictionaryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDateDictionaryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDateDictionaryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDateDictionaryListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDateDictionaryListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDateDictionaryListDto {
    totalCount: number;
    items: DateDictionaryListDto[] | undefined;
}

export enum DeviceStatusEnum {
    Not = <any>"Not", 
    Using = <any>"Using", 
    Closing = <any>"Closing", 
}

/** 的列表DTO Yozeev.BusinessLogic.Device */
export class DeviceEditDto implements IDeviceEditDto {
    /** Id */
    id: number | undefined;
    /** 站点 */
    ticketStationId: string | undefined;
    /** 设备代码 */
    deviceCode: string | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
    /** IPAddress */
    ipAddress: string | undefined;
    /** Port */
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IDeviceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.deviceStatus = data["deviceStatus"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): DeviceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["deviceStatus"] = this.deviceStatus;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): DeviceEditDto {
        const json = this.toJSON();
        let result = new DeviceEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Device */
export interface IDeviceEditDto {
    /** Id */
    id: number | undefined;
    /** 站点 */
    ticketStationId: string | undefined;
    /** 设备代码 */
    deviceCode: string | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
    /** IPAddress */
    ipAddress: string | undefined;
    /** Port */
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdateDeviceInput implements ICreateOrUpdateDeviceInput {
    device: DeviceEditDto;

    constructor(data?: ICreateOrUpdateDeviceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.device = new DeviceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.device = data["device"] ? DeviceEditDto.fromJS(data["device"]) : new DeviceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateDeviceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateDeviceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateDeviceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateDeviceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateDeviceInput {
    device: DeviceEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Device */
export class DeviceListDto implements IDeviceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 站点 */
    ticketStationId: string | undefined;
    /** 设备代码 */
    deviceCode: string | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
    /** IPAddress */
    ipAddress: string | undefined;
    /** Port */
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDeviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.deviceStatus = data["deviceStatus"];
            this.isEnabled = data["isEnabled"];
            if (data["verifiableTypes"] && data["verifiableTypes"].constructor === Array) {
                this.verifiableTypes = [] as any;
                for (let item of data["verifiableTypes"])
                    this.verifiableTypes.push(item);
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): DeviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["deviceStatus"] = this.deviceStatus;
        data["isEnabled"] = this.isEnabled;
        if (this.verifiableTypes && this.verifiableTypes.constructor === Array) {
            data["verifiableTypes"] = [];
            for (let item of this.verifiableTypes)
                data["verifiableTypes"].push(item);
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): DeviceListDto {
        const json = this.toJSON();
        let result = new DeviceListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Device */
export interface IDeviceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 站点 */
    ticketStationId: string | undefined;
    /** 设备代码 */
    deviceCode: string | undefined;
    /** 设备名称 */
    deviceName: string | undefined;
    /** IPAddress */
    ipAddress: string | undefined;
    /** Port */
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    /** SecretKey */
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** 访问类型名称列表 */
    verifiableTypes: VerifiableTypeEnum[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetDeviceForEditOutput implements IGetDeviceForEditOutput {
    device: DeviceEditDto;

    constructor(data?: IGetDeviceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.device = data["device"] ? DeviceEditDto.fromJS(data["device"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDeviceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDeviceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetDeviceForEditOutput {
        const json = this.toJSON();
        let result = new GetDeviceForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetDeviceForEditOutput {
    device: DeviceEditDto;
}

/** 获取的传入参数Dto */
export class GetDevicesInput implements IGetDevicesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetDevicesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetDevicesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDevicesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetDevicesInput {
        const json = this.toJSON();
        let result = new GetDevicesInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetDevicesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfDeviceListDto implements IPagedResultDtoOfDeviceListDto {
    totalCount: number;
    items: DeviceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfDeviceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(DeviceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfDeviceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfDeviceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfDeviceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfDeviceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfDeviceListDto {
    totalCount: number;
    items: DeviceListDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }

    clone(): EditionEditDto {
        const json = this.toJSON();
        let result = new EditionEditDto();
        result.init(json);
        return result;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateOrUpdateEditionDto {
        const json = this.toJSON();
        let result = new CreateOrUpdateEditionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name: string | undefined;
    readonly attributes: { [key: string] : Anonymous; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes[key] = data["attributes"][key] ? Anonymous.fromJS(data["attributes"][key]) : new Anonymous();
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key] ? this.attributes[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): IValueValidator {
        const json = this.toJSON();
        let result = new IValueValidator();
        result.init(json);
        return result;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : Anonymous; } | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }

    clone(): LocalizableComboboxItemDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): LocalizableComboboxItemSourceDto {
        const json = this.toJSON();
        let result = new LocalizableComboboxItemSourceDto();
        result.init(json);
        return result;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : Anonymous2; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key] ? Anonymous2.fromJS(data["attributes"][key]) : new Anonymous2();
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key] ? this.attributes[key].toJSON() : <any>undefined;
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FeatureInputTypeDto {
        const json = this.toJSON();
        let result = new FeatureInputTypeDto();
        result.init(json);
        return result;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : Anonymous2; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }

    clone(): FlatFeatureDto {
        const json = this.toJSON();
        let result = new FlatFeatureDto();
        result.init(json);
        return result;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEditionEditOutput {
        const json = this.toJSON();
        let result = new GetEditionEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionListDto {
        const json = this.toJSON();
        let result = new EditionListDto();
        result.init(json);
        return result;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment;
    id: number;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfEditionListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfEditionListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }

    clone(): MoveTenantsToAnotherEditionDto {
        const json = this.toJSON();
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(json);
        return result;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

/** 的列表DTO Yozeev.BusinessLogic.Common.Employee */
export class EmployeeEditDto implements IEmployeeEditDto {
    /** Id */
    id: number | undefined;
    /** 姓名 */
    name: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 手机号 */
    mobile: string | undefined;
    /** 照片 */
    photo: string | undefined;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** 证件号 */
    certificatesNum: string | undefined;
    /** 机构标识 */
    branchId: number | undefined;

    constructor(data?: IEmployeeEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.isEnable = data["isEnable"];
            this.mobile = data["mobile"];
            this.photo = data["photo"];
            this.sex = data["sex"];
            this.verifiableType = data["verifiableType"];
            this.certificatesNum = data["certificatesNum"];
            this.branchId = data["branchId"];
        }
    }

    static fromJS(data: any): EmployeeEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["isEnable"] = this.isEnable;
        data["mobile"] = this.mobile;
        data["photo"] = this.photo;
        data["sex"] = this.sex;
        data["verifiableType"] = this.verifiableType;
        data["certificatesNum"] = this.certificatesNum;
        data["branchId"] = this.branchId;
        return data; 
    }

    clone(): EmployeeEditDto {
        const json = this.toJSON();
        let result = new EmployeeEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Common.Employee */
export interface IEmployeeEditDto {
    /** Id */
    id: number | undefined;
    /** 姓名 */
    name: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 手机号 */
    mobile: string | undefined;
    /** 照片 */
    photo: string | undefined;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** 证件号 */
    certificatesNum: string | undefined;
    /** 机构标识 */
    branchId: number | undefined;
}

export class CreateOrUpdateEmployeeInput implements ICreateOrUpdateEmployeeInput {
    employee: EmployeeEditDto;

    constructor(data?: ICreateOrUpdateEmployeeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.employee = new EmployeeEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.employee = data["employee"] ? EmployeeEditDto.fromJS(data["employee"]) : new EmployeeEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateEmployeeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEmployeeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateEmployeeInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateEmployeeInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateEmployeeInput {
    employee: EmployeeEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.Employee */
export class EmployeeListDto implements IEmployeeListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 姓名 */
    name: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 手机号 */
    mobile: string | undefined;
    /** 照片 */
    photo: string | undefined;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** 证件号 */
    certificatesNum: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IEmployeeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.name = data["name"];
            this.isEnable = data["isEnable"];
            this.mobile = data["mobile"];
            this.photo = data["photo"];
            this.sex = data["sex"];
            this.verifiableType = data["verifiableType"];
            this.certificatesNum = data["certificatesNum"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EmployeeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["name"] = this.name;
        data["isEnable"] = this.isEnable;
        data["mobile"] = this.mobile;
        data["photo"] = this.photo;
        data["sex"] = this.sex;
        data["verifiableType"] = this.verifiableType;
        data["certificatesNum"] = this.certificatesNum;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): EmployeeListDto {
        const json = this.toJSON();
        let result = new EmployeeListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.Employee */
export interface IEmployeeListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 姓名 */
    name: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 手机号 */
    mobile: string | undefined;
    /** 照片 */
    photo: string | undefined;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** 证件号 */
    certificatesNum: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetEmployeeForEditOutput implements IGetEmployeeForEditOutput {
    employee: EmployeeEditDto;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetEmployeeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.employee = data["employee"] ? EmployeeEditDto.fromJS(data["employee"]) : <any>undefined;
            if (data["sexEnumTypeEnum"] && data["sexEnumTypeEnum"].constructor === Array) {
                this.sexEnumTypeEnum = [] as any;
                for (let item of data["sexEnumTypeEnum"])
                    this.sexEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["verifiableTypeEnumTypeEnum"] && data["verifiableTypeEnumTypeEnum"].constructor === Array) {
                this.verifiableTypeEnumTypeEnum = [] as any;
                for (let item of data["verifiableTypeEnumTypeEnum"])
                    this.verifiableTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEmployeeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["employee"] = this.employee ? this.employee.toJSON() : <any>undefined;
        if (this.sexEnumTypeEnum && this.sexEnumTypeEnum.constructor === Array) {
            data["sexEnumTypeEnum"] = [];
            for (let item of this.sexEnumTypeEnum)
                data["sexEnumTypeEnum"].push(item.toJSON());
        }
        if (this.verifiableTypeEnumTypeEnum && this.verifiableTypeEnumTypeEnum.constructor === Array) {
            data["verifiableTypeEnumTypeEnum"] = [];
            for (let item of this.verifiableTypeEnumTypeEnum)
                data["verifiableTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetEmployeeForEditOutput {
        const json = this.toJSON();
        let result = new GetEmployeeForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetEmployeeForEditOutput {
    employee: EmployeeEditDto;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetEmployeesInput implements IGetEmployeesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetEmployeesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetEmployeesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEmployeesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetEmployeesInput {
        const json = this.toJSON();
        let result = new GetEmployeesInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetEmployeesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfEmployeeListDto implements IPagedResultDtoOfEmployeeListDto {
    totalCount: number;
    items: EmployeeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEmployeeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(EmployeeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEmployeeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEmployeeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfEmployeeListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfEmployeeListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfEmployeeListDto {
    totalCount: number;
    items: EmployeeListDto[] | undefined;
}

export class UploadEmployeeResultDto implements IUploadEmployeeResultDto {
    uri: string | undefined;

    constructor(data?: IUploadEmployeeResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): UploadEmployeeResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadEmployeeResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): UploadEmployeeResultDto {
        const json = this.toJSON();
        let result = new UploadEmployeeResultDto();
        result.init(json);
        return result;
    }
}

export interface IUploadEmployeeResultDto {
    uri: string | undefined;
}

export class Device implements IDevice {
    branchId: number | undefined;
    ticketStationId: string | undefined;
    deviceCode: string | undefined;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IDevice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketStationId = data["ticketStationId"];
            this.deviceCode = data["deviceCode"];
            this.deviceName = data["deviceName"];
            this.ipAddress = data["ipAddress"];
            this.port = data["port"];
            this.deviceType = data["deviceType"];
            this.secretKey = data["secretKey"];
            this.deviceStatus = data["deviceStatus"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Device {
        data = typeof data === 'object' ? data : {};
        let result = new Device();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketStationId"] = this.ticketStationId;
        data["deviceCode"] = this.deviceCode;
        data["deviceName"] = this.deviceName;
        data["ipAddress"] = this.ipAddress;
        data["port"] = this.port;
        data["deviceType"] = this.deviceType;
        data["secretKey"] = this.secretKey;
        data["deviceStatus"] = this.deviceStatus;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Device {
        const json = this.toJSON();
        let result = new Device();
        result.init(json);
        return result;
    }
}

export interface IDevice {
    branchId: number | undefined;
    ticketStationId: string | undefined;
    deviceCode: string | undefined;
    deviceName: string | undefined;
    ipAddress: string | undefined;
    port: string | undefined;
    deviceType: DeviceTypeEnum;
    secretKey: string | undefined;
    deviceStatus: DeviceStatusEnum;
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.FaceSwiping */
export class FaceSwipingEditDto implements IFaceSwipingEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** MemberId */
    memberId: number;
    /** CardNo */
    cardNo: string | undefined;
    /** Pictures */
    pictures: string | undefined;
    /** DistinguishResult */
    distinguishResult: string | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;

    constructor(data?: IFaceSwipingEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.memberId = data["memberId"];
            this.cardNo = data["cardNo"];
            this.pictures = data["pictures"];
            this.distinguishResult = data["distinguishResult"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FaceSwipingEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaceSwipingEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["memberId"] = this.memberId;
        data["cardNo"] = this.cardNo;
        data["pictures"] = this.pictures;
        data["distinguishResult"] = this.distinguishResult;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): FaceSwipingEditDto {
        const json = this.toJSON();
        let result = new FaceSwipingEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.FaceSwiping */
export interface IFaceSwipingEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** MemberId */
    memberId: number;
    /** CardNo */
    cardNo: string | undefined;
    /** Pictures */
    pictures: string | undefined;
    /** DistinguishResult */
    distinguishResult: string | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
}

export class CreateOrUpdateFaceSwipingInput implements ICreateOrUpdateFaceSwipingInput {
    faceSwiping: FaceSwipingEditDto;

    constructor(data?: ICreateOrUpdateFaceSwipingInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.faceSwiping = new FaceSwipingEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.faceSwiping = data["faceSwiping"] ? FaceSwipingEditDto.fromJS(data["faceSwiping"]) : new FaceSwipingEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateFaceSwipingInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateFaceSwipingInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceSwiping"] = this.faceSwiping ? this.faceSwiping.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateFaceSwipingInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateFaceSwipingInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateFaceSwipingInput {
    faceSwiping: FaceSwipingEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.FaceSwiping */
export class FaceSwipingListDto implements IFaceSwipingListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** MemberId */
    memberId: number;
    /** CardNo */
    cardNo: string | undefined;
    /** Pictures */
    pictures: string | undefined;
    /** DistinguishResult */
    distinguishResult: string | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IFaceSwipingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.memberId = data["memberId"];
            this.cardNo = data["cardNo"];
            this.pictures = data["pictures"];
            this.distinguishResult = data["distinguishResult"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): FaceSwipingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new FaceSwipingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["memberId"] = this.memberId;
        data["cardNo"] = this.cardNo;
        data["pictures"] = this.pictures;
        data["distinguishResult"] = this.distinguishResult;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): FaceSwipingListDto {
        const json = this.toJSON();
        let result = new FaceSwipingListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.FaceSwiping */
export interface IFaceSwipingListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** MemberId */
    memberId: number;
    /** CardNo */
    cardNo: string | undefined;
    /** Pictures */
    pictures: string | undefined;
    /** DistinguishResult */
    distinguishResult: string | undefined;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetFaceSwipingForEditOutput implements IGetFaceSwipingForEditOutput {
    faceSwiping: FaceSwipingEditDto;

    constructor(data?: IGetFaceSwipingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.faceSwiping = data["faceSwiping"] ? FaceSwipingEditDto.fromJS(data["faceSwiping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetFaceSwipingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFaceSwipingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["faceSwiping"] = this.faceSwiping ? this.faceSwiping.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetFaceSwipingForEditOutput {
        const json = this.toJSON();
        let result = new GetFaceSwipingForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetFaceSwipingForEditOutput {
    faceSwiping: FaceSwipingEditDto;
}

/** 获取的传入参数Dto */
export class GetFaceSwipingsInput implements IGetFaceSwipingsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetFaceSwipingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetFaceSwipingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetFaceSwipingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetFaceSwipingsInput {
        const json = this.toJSON();
        let result = new GetFaceSwipingsInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetFaceSwipingsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfFaceSwipingListDto implements IPagedResultDtoOfFaceSwipingListDto {
    totalCount: number;
    items: FaceSwipingListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfFaceSwipingListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(FaceSwipingListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfFaceSwipingListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfFaceSwipingListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfFaceSwipingListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfFaceSwipingListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfFaceSwipingListDto {
    totalCount: number;
    items: FaceSwipingListDto[] | undefined;
}

export enum ReturnStateEnum {
    Success = <any>"Success", 
    False = <any>"False", 
}

/** 的列表DTO Yozeev.BusinessLogic.GateRecord */
export class GateRecordEditDto implements IGateRecordEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string | undefined;
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string | undefined;

    constructor(data?: IGateRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.verifiableType = data["verifiableType"];
            this.verifiableValue = data["verifiableValue"];
            this.returnState = data["returnState"];
            this.returnInfo = data["returnInfo"];
        }
    }

    static fromJS(data: any): GateRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verifiableType"] = this.verifiableType;
        data["verifiableValue"] = this.verifiableValue;
        data["returnState"] = this.returnState;
        data["returnInfo"] = this.returnInfo;
        return data; 
    }

    clone(): GateRecordEditDto {
        const json = this.toJSON();
        let result = new GateRecordEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.GateRecord */
export interface IGateRecordEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string | undefined;
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string | undefined;
}

export class CreateOrUpdateGateRecordInput implements ICreateOrUpdateGateRecordInput {
    gateRecord: GateRecordEditDto;

    constructor(data?: ICreateOrUpdateGateRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.gateRecord = new GateRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.gateRecord = data["gateRecord"] ? GateRecordEditDto.fromJS(data["gateRecord"]) : new GateRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateGateRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateGateRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateRecord"] = this.gateRecord ? this.gateRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateGateRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateGateRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateGateRecordInput {
    gateRecord: GateRecordEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.GateRecord */
export class GateRecordListDto implements IGateRecordListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string | undefined;
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IGateRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.verifiableType = data["verifiableType"];
            this.verifiableValue = data["verifiableValue"];
            this.returnState = data["returnState"];
            this.returnInfo = data["returnInfo"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): GateRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new GateRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verifiableType"] = this.verifiableType;
        data["verifiableValue"] = this.verifiableValue;
        data["returnState"] = this.returnState;
        data["returnInfo"] = this.returnInfo;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): GateRecordListDto {
        const json = this.toJSON();
        let result = new GateRecordListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.GateRecord */
export interface IGateRecordListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** VerifiableValue */
    verifiableValue: string | undefined;
    returnState: ReturnStateEnum;
    /** ReturnInfo */
    returnInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetGateRecordForEditOutput implements IGetGateRecordForEditOutput {
    gateRecord: GateRecordEditDto;

    constructor(data?: IGetGateRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateRecord = data["gateRecord"] ? GateRecordEditDto.fromJS(data["gateRecord"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGateRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGateRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateRecord"] = this.gateRecord ? this.gateRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetGateRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetGateRecordForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetGateRecordForEditOutput {
    gateRecord: GateRecordEditDto;
}

/** 获取的传入参数Dto */
export class GetGateRecordsInput implements IGetGateRecordsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetGateRecordsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetGateRecordsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGateRecordsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetGateRecordsInput {
        const json = this.toJSON();
        let result = new GetGateRecordsInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetGateRecordsInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfGateRecordListDto implements IPagedResultDtoOfGateRecordListDto {
    totalCount: number;
    items: GateRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGateRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(GateRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGateRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGateRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfGateRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfGateRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfGateRecordListDto {
    totalCount: number;
    items: GateRecordListDto[] | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfString {
        const json = this.toJSON();
        let result = new EntityDtoOfString();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class HostCacheDto implements IHostCacheDto {
    name: string | undefined;

    constructor(data?: IHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): HostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): HostCacheDto {
        const json = this.toJSON();
        let result = new HostCacheDto();
        result.init(json);
        return result;
    }
}

export interface IHostCacheDto {
    name: string | undefined;
}

export class ListResultDtoOfHostCacheDto implements IListResultDtoOfHostCacheDto {
    items: HostCacheDto[] | undefined;

    constructor(data?: IListResultDtoOfHostCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(HostCacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfHostCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfHostCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfHostCacheDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfHostCacheDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfHostCacheDto {
    items: HostCacheDto[] | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    /** 时区 */
    timezone: string | undefined;
    /** 这个字段只用于比较用户的时区与默认时区 */
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }

    clone(): GeneralSettingsEditDto {
        const json = this.toJSON();
        let result = new GeneralSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IGeneralSettingsEditDto {
    /** 时区 */
    timezone: string | undefined;
    /** 这个字段只用于比较用户的时区与默认时区 */
    timezoneForComparison: string | undefined;
}

export enum ValidateCodeType {
    Number = <any>"Number", 
    English = <any>"English", 
    NumberAndLetter = <any>"NumberAndLetter", 
    Hanzi = <any>"Hanzi", 
}

/** 网站全局管理设置 */
export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    /** 是否必须验证邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean;
    /** 是否启用短信验证 */
    smsVerificationEnabled: boolean;
    /** 是否启用Cookie内容 */
    isCookieConsentEnabled: boolean;
    /** 宿主用户登陆使用验证码 */
    useCaptchaOnUserLogin: boolean;
    captchaOnUserLoginType: ValidateCodeType;
    /** 宿主用户登陆验证码长度 */
    captchaOnUserLoginLength: number;
    isQuickThemeSelectEnabled: boolean;
    externalLoginProviders: string[] | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
            this.captchaOnUserLoginType = data["captchaOnUserLoginType"];
            this.captchaOnUserLoginLength = data["captchaOnUserLoginLength"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            if (data["externalLoginProviders"] && data["externalLoginProviders"].constructor === Array) {
                this.externalLoginProviders = [] as any;
                for (let item of data["externalLoginProviders"])
                    this.externalLoginProviders.push(item);
            }
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        data["captchaOnUserLoginType"] = this.captchaOnUserLoginType;
        data["captchaOnUserLoginLength"] = this.captchaOnUserLoginLength;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        if (this.externalLoginProviders && this.externalLoginProviders.constructor === Array) {
            data["externalLoginProviders"] = [];
            for (let item of this.externalLoginProviders)
                data["externalLoginProviders"].push(item);
        }
        return data; 
    }

    clone(): HostUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new HostUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

/** 网站全局管理设置 */
export interface IHostUserManagementSettingsEditDto {
    /** 是否必须验证邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean;
    /** 是否启用短信验证 */
    smsVerificationEnabled: boolean;
    /** 是否启用Cookie内容 */
    isCookieConsentEnabled: boolean;
    /** 宿主用户登陆使用验证码 */
    useCaptchaOnUserLogin: boolean;
    captchaOnUserLoginType: ValidateCodeType;
    /** 宿主用户登陆验证码长度 */
    captchaOnUserLoginLength: number;
    isQuickThemeSelectEnabled: boolean;
    externalLoginProviders: string[] | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort: number;
    /** 发件人校验名称 */
    smtpUserName: string | undefined;
    /** 发件人校验密码 */
    smtpPassword: string | undefined;
    /** 发件人 */
    smtpDomain: string | undefined;
    /** 使用ssl */
    smtpEnableSsl: boolean;
    /** 使用默认凭据 */
    smtpUseDefaultCredentials: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }

    clone(): EmailSettingsEditDto {
        const json = this.toJSON();
        let result = new EmailSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IEmailSettingsEditDto {
    /** 默认发件人邮箱地址 */
    defaultFromAddress: string | undefined;
    /** 邮箱显示名称 */
    defaultFromDisplayName: string | undefined;
    /** 发件人邮箱SMTP服务器Host */
    smtpHost: string | undefined;
    /** 发件人邮箱SMTP服务器端口 */
    smtpPort: number;
    /** 发件人校验名称 */
    smtpUserName: string | undefined;
    /** 发件人校验密码 */
    smtpPassword: string | undefined;
    /** 发件人 */
    smtpDomain: string | undefined;
    /** 使用ssl */
    smtpEnableSsl: boolean;
    /** 使用默认凭据 */
    smtpUseDefaultCredentials: boolean;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    /** 允许注册 */
    allowSelfRegistration: boolean;
    /** 注册租户默认激活 */
    isNewRegisteredTenantActiveByDefault: boolean;
    /** 宿主租户注册使用验证码 */
    useCaptchaOnTenantRegistration: boolean;
    captchaOnTenantRegistrationType: ValidateCodeType;
    /** 宿主租户注册验证码长度 */
    captchaOnTenantRegistrationLength: number;
    /** 默认版本id */
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnTenantRegistration = data["useCaptchaOnTenantRegistration"];
            this.captchaOnTenantRegistrationType = data["captchaOnTenantRegistrationType"];
            this.captchaOnTenantRegistrationLength = data["captchaOnTenantRegistrationLength"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnTenantRegistration"] = this.useCaptchaOnTenantRegistration;
        data["captchaOnTenantRegistrationType"] = this.captchaOnTenantRegistrationType;
        data["captchaOnTenantRegistrationLength"] = this.captchaOnTenantRegistrationLength;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }

    clone(): TenantManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantManagementSettingsEditDto {
    /** 允许注册 */
    allowSelfRegistration: boolean;
    /** 注册租户默认激活 */
    isNewRegisteredTenantActiveByDefault: boolean;
    /** 宿主租户注册使用验证码 */
    useCaptchaOnTenantRegistration: boolean;
    captchaOnTenantRegistrationType: ValidateCodeType;
    /** 宿主租户注册验证码长度 */
    captchaOnTenantRegistrationLength: number;
    /** 默认版本id */
    defaultEditionId: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }

    clone(): PasswordComplexitySetting {
        const json = this.toJSON();
        let result = new PasswordComplexitySetting();
        result.init(json);
        return result;
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    /** 是否启用 */
    isEnabled: boolean;
    /** 登陆校验错误锁定账户最大次数 */
    maxFailedAccessAttemptsBeforeLockout: number;
    /** 默认锁定时间 */
    defaultAccountLockoutSeconds: number;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }

    clone(): UserLockOutSettingsEditDto {
        const json = this.toJSON();
        let result = new UserLockOutSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IUserLockOutSettingsEditDto {
    /** 是否启用 */
    isEnabled: boolean;
    /** 登陆校验错误锁定账户最大次数 */
    maxFailedAccessAttemptsBeforeLockout: number;
    /** 默认锁定时间 */
    defaultAccountLockoutSeconds: number;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    /** 是否启用 */
    isEnabled: boolean;
    /** 邮箱启用 */
    isEmailProviderEnabled: boolean;
    /** 短信启用 */
    isSmsProviderEnabled: boolean;
    /** 浏览器‘记住我’启用 */
    isRememberBrowserEnabled: boolean;
    /** google校验启用 */
    isGoogleAuthenticatorEnabled: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }

    clone(): TwoFactorLoginSettingsEditDto {
        const json = this.toJSON();
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    /** 是否启用 */
    isEnabled: boolean;
    /** 邮箱启用 */
    isEmailProviderEnabled: boolean;
    /** 短信启用 */
    isSmsProviderEnabled: boolean;
    /** 浏览器‘记住我’启用 */
    isRememberBrowserEnabled: boolean;
    /** google校验启用 */
    isGoogleAuthenticatorEnabled: boolean;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    /** 使用默认密码校验设置 */
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }

    clone(): SecuritySettingsEditDto {
        const json = this.toJSON();
        let result = new SecuritySettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ISecuritySettingsEditDto {
    /** 使用默认密码校验设置 */
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }

    clone(): HostBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new HostBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): HostSettingsEditDto {
        const json = this.toJSON();
        let result = new HostSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    /** 邮箱地址 */
    emailAddress: string | undefined;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }

    clone(): SendTestEmailInput {
        const json = this.toJSON();
        let result = new SendTestEmailInput();
        result.init(json);
        return result;
    }
}

export interface ISendTestEmailInput {
    /** 邮箱地址 */
    emailAddress: string | undefined;
}

export class ImportUserDto implements IImportUserDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    /** comma separated list */
    assignedRoleNames: string[] | undefined;
    /** Can be set when reading data from excel or when importing user */
    exception: string | undefined;

    constructor(data?: IImportUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.exception = data["exception"];
        }
    }

    static fromJS(data: any): ImportUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["exception"] = this.exception;
        return data; 
    }

    clone(): ImportUserDto {
        const json = this.toJSON();
        let result = new ImportUserDto();
        result.init(json);
        return result;
    }
}

export interface IImportUserDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    /** comma separated list */
    assignedRoleNames: string[] | undefined;
    /** Can be set when reading data from excel or when importing user */
    exception: string | undefined;
}

export class LanguageEditDto implements ILanguageEditDto {
    id: number | undefined;
    name: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;

    constructor(data?: ILanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): LanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): LanguageEditDto {
        const json = this.toJSON();
        let result = new LanguageEditDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageEditDto {
    id: number | undefined;
    name: string | undefined;
    icon: string | undefined;
    isEnabled: boolean;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: LanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new LanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? LanguageEditDto.fromJS(data["language"]) : new LanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateLanguageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: LanguageEditDto;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }

    clone(): ComboboxItemDto {
        const json = this.toJSON();
        let result = new ComboboxItemDto();
        result.init(json);
        return result;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: LanguageEditDto;
    /** 所有的语言名称 */
    languageNames: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? LanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguageForEditOutput {
        const json = this.toJSON();
        let result = new GetLanguageForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguageForEditOutput {
    language: LanguageEditDto;
    /** 所有的语言名称 */
    languageNames: ComboboxItemDto[] | undefined;
    /** 所有的国旗 */
    flags: ComboboxItemDto[] | undefined;
}

export class LanguageListDto implements ILanguageListDto {
    tenantId: number | undefined;
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 图标 */
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ILanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): LanguageListDto {
        const json = this.toJSON();
        let result = new LanguageListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageListDto {
    tenantId: number | undefined;
    /** 名称 */
    name: string | undefined;
    /** 显示名称 */
    displayName: string | undefined;
    /** 图标 */
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName: string | undefined;
    items: LanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetLanguagesOutput {
        const json = this.toJSON();
        let result = new GetLanguagesOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLanguagesOutput {
    /** 默认语言名称 */
    defaultLanguageName: string | undefined;
    items: LanguageListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    /** 键 */
    key: string | undefined;
    /** 原始值 */
    baseValue: string | undefined;
    /** 目标值 */
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }

    clone(): LanguageTextListDto {
        const json = this.toJSON();
        let result = new LanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface ILanguageTextListDto {
    /** 键 */
    key: string | undefined;
    /** 原始值 */
    baseValue: string | undefined;
    /** 目标值 */
    targetValue: string | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLanguageTextListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string | undefined;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }

    clone(): SetDefaultLanguageInput {
        const json = this.toJSON();
        let result = new SetDefaultLanguageInput();
        result.init(json);
        return result;
    }
}

export interface ISetDefaultLanguageInput {
    name: string | undefined;
}

/** 更新语言输入信息 */
export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string | undefined;
    sourceName: string | undefined;
    /** 键 */
    key: string | undefined;
    /** 值 */
    value: string | undefined;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): UpdateLanguageTextInput {
        const json = this.toJSON();
        let result = new UpdateLanguageTextInput();
        result.init(json);
        return result;
    }
}

/** 更新语言输入信息 */
export interface IUpdateLanguageTextInput {
    languageName: string | undefined;
    sourceName: string | undefined;
    /** 键 */
    key: string | undefined;
    /** 值 */
    value: string | undefined;
}

export enum CardTypeEnum {
    HotSpringCard = <any>"HotSpringCard", 
    YearCard = <any>"YearCard", 
    QuarterlyCard = <any>"QuarterlyCard", 
    MonthlyCard = <any>"MonthlyCard", 
    SubCard = <any>"SubCard", 
}

/** 的列表DTO Yozeev.BusinessLogic.Member */
export class MemberEditDto implements IMemberEditDto {
    /** Id */
    id: number | undefined;
    /** MemberName */
    memberName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** CardNo */
    cardNo: string | undefined;
    cardType: CardTypeEnum;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** CertificatesNum */
    certificatesNum: string | undefined;
    /** FacePictures */
    facePictures: string | undefined;
    /** DocumentPhoto */
    documentPhoto: string | undefined;
    /** CreatedTime */
    createdTime: moment.Moment | undefined;

    constructor(data?: IMemberEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.memberName = data["memberName"];
            this.mobile = data["mobile"];
            this.cardNo = data["cardNo"];
            this.cardType = data["cardType"];
            this.sex = data["sex"];
            this.verifiableType = data["verifiableType"];
            this.certificatesNum = data["certificatesNum"];
            this.facePictures = data["facePictures"];
            this.documentPhoto = data["documentPhoto"];
            this.createdTime = data["createdTime"] ? moment(data["createdTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): MemberEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["memberName"] = this.memberName;
        data["mobile"] = this.mobile;
        data["cardNo"] = this.cardNo;
        data["cardType"] = this.cardType;
        data["sex"] = this.sex;
        data["verifiableType"] = this.verifiableType;
        data["certificatesNum"] = this.certificatesNum;
        data["facePictures"] = this.facePictures;
        data["documentPhoto"] = this.documentPhoto;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): MemberEditDto {
        const json = this.toJSON();
        let result = new MemberEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Member */
export interface IMemberEditDto {
    /** Id */
    id: number | undefined;
    /** MemberName */
    memberName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** CardNo */
    cardNo: string | undefined;
    cardType: CardTypeEnum;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** CertificatesNum */
    certificatesNum: string | undefined;
    /** FacePictures */
    facePictures: string | undefined;
    /** DocumentPhoto */
    documentPhoto: string | undefined;
    /** CreatedTime */
    createdTime: moment.Moment | undefined;
}

export class CreateOrUpdateMemberInput implements ICreateOrUpdateMemberInput {
    member: MemberEditDto;

    constructor(data?: ICreateOrUpdateMemberInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.member = new MemberEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.member = data["member"] ? MemberEditDto.fromJS(data["member"]) : new MemberEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateMemberInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMemberInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateMemberInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMemberInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMemberInput {
    member: MemberEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Member */
export class MemberListDto implements IMemberListDto {
    /** MemberName */
    memberName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** CardNo */
    cardNo: string | undefined;
    cardType: CardTypeEnum;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** CertificatesNum */
    certificatesNum: string | undefined;
    /** FacePictures */
    facePictures: string | undefined;
    /** DocumentPhoto */
    documentPhoto: string | undefined;
    /** CreatedTime */
    createdTime: moment.Moment | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMemberListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.memberName = data["memberName"];
            this.mobile = data["mobile"];
            this.cardNo = data["cardNo"];
            this.cardType = data["cardType"];
            this.sex = data["sex"];
            this.verifiableType = data["verifiableType"];
            this.certificatesNum = data["certificatesNum"];
            this.facePictures = data["facePictures"];
            this.documentPhoto = data["documentPhoto"];
            this.createdTime = data["createdTime"] ? moment(data["createdTime"].toString()) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MemberListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MemberListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberName"] = this.memberName;
        data["mobile"] = this.mobile;
        data["cardNo"] = this.cardNo;
        data["cardType"] = this.cardType;
        data["sex"] = this.sex;
        data["verifiableType"] = this.verifiableType;
        data["certificatesNum"] = this.certificatesNum;
        data["facePictures"] = this.facePictures;
        data["documentPhoto"] = this.documentPhoto;
        data["createdTime"] = this.createdTime ? this.createdTime.toISOString() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MemberListDto {
        const json = this.toJSON();
        let result = new MemberListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Member */
export interface IMemberListDto {
    /** MemberName */
    memberName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** CardNo */
    cardNo: string | undefined;
    cardType: CardTypeEnum;
    sex: SexEnum;
    verifiableType: VerifiableTypeEnum;
    /** CertificatesNum */
    certificatesNum: string | undefined;
    /** FacePictures */
    facePictures: string | undefined;
    /** DocumentPhoto */
    documentPhoto: string | undefined;
    /** CreatedTime */
    createdTime: moment.Moment | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetMemberForEditOutput implements IGetMemberForEditOutput {
    member: MemberEditDto;
    cardTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetMemberForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.member = data["member"] ? MemberEditDto.fromJS(data["member"]) : <any>undefined;
            if (data["cardTypeEnumTypeEnum"] && data["cardTypeEnumTypeEnum"].constructor === Array) {
                this.cardTypeEnumTypeEnum = [] as any;
                for (let item of data["cardTypeEnumTypeEnum"])
                    this.cardTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["sexEnumTypeEnum"] && data["sexEnumTypeEnum"].constructor === Array) {
                this.sexEnumTypeEnum = [] as any;
                for (let item of data["sexEnumTypeEnum"])
                    this.sexEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["verifiableTypeEnumTypeEnum"] && data["verifiableTypeEnumTypeEnum"].constructor === Array) {
                this.verifiableTypeEnumTypeEnum = [] as any;
                for (let item of data["verifiableTypeEnumTypeEnum"])
                    this.verifiableTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["member"] = this.member ? this.member.toJSON() : <any>undefined;
        if (this.cardTypeEnumTypeEnum && this.cardTypeEnumTypeEnum.constructor === Array) {
            data["cardTypeEnumTypeEnum"] = [];
            for (let item of this.cardTypeEnumTypeEnum)
                data["cardTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.sexEnumTypeEnum && this.sexEnumTypeEnum.constructor === Array) {
            data["sexEnumTypeEnum"] = [];
            for (let item of this.sexEnumTypeEnum)
                data["sexEnumTypeEnum"].push(item.toJSON());
        }
        if (this.verifiableTypeEnumTypeEnum && this.verifiableTypeEnumTypeEnum.constructor === Array) {
            data["verifiableTypeEnumTypeEnum"] = [];
            for (let item of this.verifiableTypeEnumTypeEnum)
                data["verifiableTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetMemberForEditOutput {
        const json = this.toJSON();
        let result = new GetMemberForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetMemberForEditOutput {
    member: MemberEditDto;
    cardTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    sexEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    verifiableTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfMemberListDto implements IPagedResultDtoOfMemberListDto {
    totalCount: number;
    items: MemberListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMemberListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MemberListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMemberListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMemberListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMemberListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMemberListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMemberListDto {
    totalCount: number;
    items: MemberListDto[] | undefined;
}

export enum PowerTypeEnum {
    OPERATE = <any>"OPERATE", 
    Data = <any>"Data", 
    MENU = <any>"MENU", 
}

export class RoleClaim implements IRoleClaim {
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRoleClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.roleId = data["roleId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleClaim {
        data = typeof data === 'object' ? data : {};
        let result = new RoleClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["roleId"] = this.roleId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleClaim {
        const json = this.toJSON();
        let result = new RoleClaim();
        result.init(json);
        return result;
    }
}

export interface IRoleClaim {
    tenantId: number | undefined;
    roleId: number;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class RolePermissionSetting implements IRolePermissionSetting {
    roleId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRolePermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RolePermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new RolePermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RolePermissionSetting {
        const json = this.toJSON();
        let result = new RolePermissionSetting();
        result.init(json);
        return result;
    }
}

export interface IRolePermissionSetting {
    roleId: number;
    tenantId: number | undefined;
    name: string | undefined;
    isGranted: boolean;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Role implements IRole {
    description: string | undefined;
    normalizedName: string | undefined;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.normalizedName = data["normalizedName"];
            if (data["claims"] && data["claims"].constructor === Array) {
                this.claims = [] as any;
                for (let item of data["claims"])
                    this.claims.push(RoleClaim.fromJS(item));
            }
            this.concurrencyStamp = data["concurrencyStamp"];
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(RolePermissionSetting.fromJS(item));
            }
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["normalizedName"] = this.normalizedName;
        if (this.claims && this.claims.constructor === Array) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Role {
        const json = this.toJSON();
        let result = new Role();
        result.init(json);
        return result;
    }
}

export interface IRole {
    description: string | undefined;
    normalizedName: string | undefined;
    claims: RoleClaim[] | undefined;
    concurrencyStamp: string | undefined;
    deleterUser: User;
    creatorUser: User;
    lastModifierUser: User;
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    permissions: RolePermissionSetting[] | undefined;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class PowerRole implements IPowerRole {
    roleId: number;
    role: Role;
    powerId: number;
    power: Power;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPowerRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.powerId = data["powerId"];
            this.power = data["power"] ? Power.fromJS(data["power"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerRole {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["powerId"] = this.powerId;
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerRole {
        const json = this.toJSON();
        let result = new PowerRole();
        result.init(json);
        return result;
    }
}

export interface IPowerRole {
    roleId: number;
    role: Role;
    powerId: number;
    power: Power;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Power implements IPower {
    menuId: number;
    menu: Menu;
    menuPath: string | undefined;
    powerCode: string | undefined;
    powerName: string | undefined;
    method: string | undefined;
    params: string | undefined;
    groupName: string | undefined;
    sort: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    isEnabled: boolean;
    powerRoles: PowerRole[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPower) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
            if (data["powerRoles"] && data["powerRoles"].constructor === Array) {
                this.powerRoles = [] as any;
                for (let item of data["powerRoles"])
                    this.powerRoles.push(PowerRole.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Power {
        data = typeof data === 'object' ? data : {};
        let result = new Power();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        if (this.powerRoles && this.powerRoles.constructor === Array) {
            data["powerRoles"] = [];
            for (let item of this.powerRoles)
                data["powerRoles"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Power {
        const json = this.toJSON();
        let result = new Power();
        result.init(json);
        return result;
    }
}

export interface IPower {
    menuId: number;
    menu: Menu;
    menuPath: string | undefined;
    powerCode: string | undefined;
    powerName: string | undefined;
    method: string | undefined;
    params: string | undefined;
    groupName: string | undefined;
    sort: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    isEnabled: boolean;
    powerRoles: PowerRole[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class Menu implements IMenu {
    parentId: number | undefined;
    parent: Menu;
    menuName: string | undefined;
    menuCode: string | undefined;
    navigateUrl: string | undefined;
    sort: number | undefined;
    level: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    isEnabled: boolean;
    powers: Power[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Menu.fromJS(data["parent"]) : <any>undefined;
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
            if (data["powers"] && data["powers"].constructor === Array) {
                this.powers = [] as any;
                for (let item of data["powers"])
                    this.powers.push(Power.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Menu {
        data = typeof data === 'object' ? data : {};
        let result = new Menu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        if (this.powers && this.powers.constructor === Array) {
            data["powers"] = [];
            for (let item of this.powers)
                data["powers"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): Menu {
        const json = this.toJSON();
        let result = new Menu();
        result.init(json);
        return result;
    }
}

export interface IMenu {
    parentId: number | undefined;
    parent: Menu;
    menuName: string | undefined;
    menuCode: string | undefined;
    navigateUrl: string | undefined;
    sort: number | undefined;
    level: number | undefined;
    iocName: string | undefined;
    iocClassName: string | undefined;
    isEnabled: boolean;
    powers: Power[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.SystemConfig.Menu */
export class MenuEditDto implements IMenuEditDto {
    /** Id */
    id: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: Menu;
    /** MenuName */
    menuName: string | undefined;
    /** MenuCode */
    menuCode: string | undefined;
    /** NavigateUrl */
    navigateUrl: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Powers */
    powers: Power[] | undefined;

    constructor(data?: IMenuEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Menu.fromJS(data["parent"]) : <any>undefined;
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
            if (data["powers"] && data["powers"].constructor === Array) {
                this.powers = [] as any;
                for (let item of data["powers"])
                    this.powers.push(Power.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        if (this.powers && this.powers.constructor === Array) {
            data["powers"] = [];
            for (let item of this.powers)
                data["powers"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MenuEditDto {
        const json = this.toJSON();
        let result = new MenuEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.Menu */
export interface IMenuEditDto {
    /** Id */
    id: number | undefined;
    /** ParentId */
    parentId: number | undefined;
    parent: Menu;
    /** MenuName */
    menuName: string | undefined;
    /** MenuCode */
    menuCode: string | undefined;
    /** NavigateUrl */
    navigateUrl: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Powers */
    powers: Power[] | undefined;
}

export class CreateOrUpdateMenuInput implements ICreateOrUpdateMenuInput {
    menu: MenuEditDto;

    constructor(data?: ICreateOrUpdateMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.menu = new MenuEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? MenuEditDto.fromJS(data["menu"]) : new MenuEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateMenuInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateMenuInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateMenuInput {
    menu: MenuEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.Menu */
export class MenuListDto implements IMenuListDto {
    /** ParentId */
    parentId: number | undefined;
    parent: Menu;
    /** MenuName */
    menuName: string | undefined;
    /** MenuCode */
    menuCode: string | undefined;
    /** NavigateUrl */
    navigateUrl: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Powers */
    powers: Power[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IMenuListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? Menu.fromJS(data["parent"]) : <any>undefined;
            this.menuName = data["menuName"];
            this.menuCode = data["menuCode"];
            this.navigateUrl = data["navigateUrl"];
            this.sort = data["sort"];
            this.level = data["level"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.isEnabled = data["isEnabled"];
            if (data["powers"] && data["powers"].constructor === Array) {
                this.powers = [] as any;
                for (let item of data["powers"])
                    this.powers.push(Power.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MenuListDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["menuName"] = this.menuName;
        data["menuCode"] = this.menuCode;
        data["navigateUrl"] = this.navigateUrl;
        data["sort"] = this.sort;
        data["level"] = this.level;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["isEnabled"] = this.isEnabled;
        if (this.powers && this.powers.constructor === Array) {
            data["powers"] = [];
            for (let item of this.powers)
                data["powers"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): MenuListDto {
        const json = this.toJSON();
        let result = new MenuListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.Menu */
export interface IMenuListDto {
    /** ParentId */
    parentId: number | undefined;
    parent: Menu;
    /** MenuName */
    menuName: string | undefined;
    /** MenuCode */
    menuCode: string | undefined;
    /** NavigateUrl */
    navigateUrl: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** Level */
    level: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Powers */
    powers: Power[] | undefined;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetMenuForEditOutput implements IGetMenuForEditOutput {
    menu: MenuEditDto;

    constructor(data?: IGetMenuForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? MenuEditDto.fromJS(data["menu"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMenuForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMenuForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetMenuForEditOutput {
        const json = this.toJSON();
        let result = new GetMenuForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetMenuForEditOutput {
    menu: MenuEditDto;
}

export class MenuDropDownDto implements IMenuDropDownDto {
    /** key */
    key: string | undefined;
    /** title */
    title: string | undefined;
    /** 子菜单列表 */
    children: MenuDropDownDto[] | undefined;
    /** isLeaf */
    isLeaf: boolean;

    constructor(data?: IMenuDropDownDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.title = data["title"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children.push(MenuDropDownDto.fromJS(item));
            }
            this.isLeaf = data["isLeaf"];
        }
    }

    static fromJS(data: any): MenuDropDownDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuDropDownDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["title"] = this.title;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["isLeaf"] = this.isLeaf;
        return data; 
    }

    clone(): MenuDropDownDto {
        const json = this.toJSON();
        let result = new MenuDropDownDto();
        result.init(json);
        return result;
    }
}

export interface IMenuDropDownDto {
    /** key */
    key: string | undefined;
    /** title */
    title: string | undefined;
    /** 子菜单列表 */
    children: MenuDropDownDto[] | undefined;
    /** isLeaf */
    isLeaf: boolean;
}

export class MenuTreeDto implements IMenuTreeDto {
    /** id */
    id: string | undefined;
    /** text */
    text: string | undefined;
    /** i18n */
    i18n: string | undefined;
    /** link */
    link: string | undefined;
    /** icon */
    icon: string | undefined;
    /** acl */
    acl: string | undefined;
    /** 子菜单列表 */
    childrens: MenuTreeDto[] | undefined;
    /** 是否显示所有操作 */
    isAllOperation: boolean | undefined;
    /** 可用操作名称列表 */
    operationNames: string[] | undefined;

    constructor(data?: IMenuTreeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.text = data["text"];
            this.i18n = data["i18n"];
            this.link = data["link"];
            this.icon = data["icon"];
            this.acl = data["acl"];
            if (data["childrens"] && data["childrens"].constructor === Array) {
                this.childrens = [] as any;
                for (let item of data["childrens"])
                    this.childrens.push(MenuTreeDto.fromJS(item));
            }
            this.isAllOperation = data["isAllOperation"];
            if (data["operationNames"] && data["operationNames"].constructor === Array) {
                this.operationNames = [] as any;
                for (let item of data["operationNames"])
                    this.operationNames.push(item);
            }
        }
    }

    static fromJS(data: any): MenuTreeDto {
        data = typeof data === 'object' ? data : {};
        let result = new MenuTreeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["i18n"] = this.i18n;
        data["link"] = this.link;
        data["icon"] = this.icon;
        data["acl"] = this.acl;
        if (this.childrens && this.childrens.constructor === Array) {
            data["childrens"] = [];
            for (let item of this.childrens)
                data["childrens"].push(item.toJSON());
        }
        data["isAllOperation"] = this.isAllOperation;
        if (this.operationNames && this.operationNames.constructor === Array) {
            data["operationNames"] = [];
            for (let item of this.operationNames)
                data["operationNames"].push(item);
        }
        return data; 
    }

    clone(): MenuTreeDto {
        const json = this.toJSON();
        let result = new MenuTreeDto();
        result.init(json);
        return result;
    }
}

export interface IMenuTreeDto {
    /** id */
    id: string | undefined;
    /** text */
    text: string | undefined;
    /** i18n */
    i18n: string | undefined;
    /** link */
    link: string | undefined;
    /** icon */
    icon: string | undefined;
    /** acl */
    acl: string | undefined;
    /** 子菜单列表 */
    childrens: MenuTreeDto[] | undefined;
    /** 是否显示所有操作 */
    isAllOperation: boolean | undefined;
    /** 可用操作名称列表 */
    operationNames: string[] | undefined;
}

export class PagedResultDtoOfMenuListDto implements IPagedResultDtoOfMenuListDto {
    totalCount: number;
    items: MenuListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMenuListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MenuListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMenuListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMenuListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMenuListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMenuListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMenuListDto {
    totalCount: number;
    items: MenuListDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string | undefined;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionWithDisplayNameDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string | undefined;
    isSubscribed: boolean;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationSettingsOutput {
        const json = this.toJSON();
        let result = new GetNotificationSettingsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export enum UserNotificationState {
    Unread = <any>"Unread", 
    Read = <any>"Read", 
}

export class NotificationData implements INotificationData {
    readonly type: string | undefined;
    properties: { [key: string] : Anonymous3; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key] ? Anonymous3.fromJS(data["properties"][key]) : new Anonymous3();
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key] ? this.properties[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): NotificationData {
        const json = this.toJSON();
        let result = new NotificationData();
        result.init(json);
        return result;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : Anonymous3; } | undefined;
}

export enum NotificationSeverity {
    Info = <any>"Info", 
    Success = <any>"Success", 
    Warn = <any>"Warn", 
    Error = <any>"Error", 
    Fatal = <any>"Fatal", 
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: EntityId | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"] ? EntityId.fromJS(data["entityId"]) : <any>undefined;
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId ? this.entityId.toJSON() : <any>undefined;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantNotification {
        const json = this.toJSON();
        let result = new TenantNotification();
        result.init(json);
        return result;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: EntityId | undefined;
    severity: NotificationSeverity;
    creationTime: moment.Moment;
    id: string;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserNotification {
        const json = this.toJSON();
        let result = new UserNotification();
        result.init(json);
        return result;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    id: string;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    /** 未阅读消息数量 */
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetNotificationsOutput {
        const json = this.toJSON();
        let result = new GetNotificationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetNotificationsOutput {
    /** 未阅读消息数量 */
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfGuid {
        const json = this.toJSON();
        let result = new EntityDtoOfGuid();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string | undefined;
    isSubscribed: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }

    clone(): NotificationSubscriptionDto {
        const json = this.toJSON();
        let result = new NotificationSubscriptionDto();
        result.init(json);
        return result;
    }
}

export interface INotificationSubscriptionDto {
    name: string | undefined;
    isSubscribed: boolean;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateNotificationSettingsInput {
        const json = this.toJSON();
        let result = new UpdateNotificationSettingsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Organization */
export class OrganizationEditDto implements IOrganizationEditDto {
    /** Id */
    id: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Remand */
    remand: string | undefined;
    /** Discount */
    discount: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IOrganizationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.groupName = data["groupName"];
            this.contacts = data["contacts"];
            this.mobile = data["mobile"];
            this.remand = data["remand"];
            this.discount = data["discount"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): OrganizationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupName"] = this.groupName;
        data["contacts"] = this.contacts;
        data["mobile"] = this.mobile;
        data["remand"] = this.remand;
        data["discount"] = this.discount;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): OrganizationEditDto {
        const json = this.toJSON();
        let result = new OrganizationEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Organization */
export interface IOrganizationEditDto {
    /** Id */
    id: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Remand */
    remand: string | undefined;
    /** Discount */
    discount: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdateOrganizationInput implements ICreateOrUpdateOrganizationInput {
    organization: OrganizationEditDto;

    constructor(data?: ICreateOrUpdateOrganizationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.organization = new OrganizationEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"] ? OrganizationEditDto.fromJS(data["organization"]) : new OrganizationEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateOrganizationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateOrganizationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateOrganizationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateOrganizationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateOrganizationInput {
    organization: OrganizationEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Organization */
export class OrganizationListDto implements IOrganizationListDto {
    /** BranchId */
    branchId: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Remand */
    remand: string | undefined;
    /** Discount */
    discount: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOrganizationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.groupName = data["groupName"];
            this.contacts = data["contacts"];
            this.mobile = data["mobile"];
            this.remand = data["remand"];
            this.discount = data["discount"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["groupName"] = this.groupName;
        data["contacts"] = this.contacts;
        data["mobile"] = this.mobile;
        data["remand"] = this.remand;
        data["discount"] = this.discount;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationListDto {
        const json = this.toJSON();
        let result = new OrganizationListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Organization */
export interface IOrganizationListDto {
    /** BranchId */
    branchId: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Remand */
    remand: string | undefined;
    /** Discount */
    discount: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetOrganizationForEditOutput implements IGetOrganizationForEditOutput {
    organization: OrganizationEditDto;

    constructor(data?: IGetOrganizationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"] ? OrganizationEditDto.fromJS(data["organization"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOrganizationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetOrganizationForEditOutput {
        const json = this.toJSON();
        let result = new GetOrganizationForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetOrganizationForEditOutput {
    organization: OrganizationEditDto;
}

/** 获取的传入参数Dto */
export class GetOrganizationsInput implements IGetOrganizationsInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetOrganizationsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetOrganizationsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrganizationsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetOrganizationsInput {
        const json = this.toJSON();
        let result = new GetOrganizationsInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetOrganizationsInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfOrganizationListDto implements IPagedResultDtoOfOrganizationListDto {
    totalCount: number;
    items: OrganizationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationListDto {
    totalCount: number;
    items: OrganizationListDto[] | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["roleIds"] && data["roleIds"].constructor === Array) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.roleIds && this.roleIds.constructor === Array) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RolesToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RolesToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UsersToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UsersToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string | undefined;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): CreateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new CreateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string | undefined;
}

/** 组织机构列表Dto */
export class OrganizationUnitListDto implements IOrganizationUnitListDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IOrganizationUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitListDto();
        result.init(json);
        return result;
    }
}

/** 组织机构列表Dto */
export interface IOrganizationUnitListDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class FindUsersInput implements IFindUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filterText: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filterText = data["filterText"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filterText"] = this.filterText;
        return data; 
    }

    clone(): FindUsersInput {
        const json = this.toJSON();
        let result = new FindUsersInput();
        result.init(json);
        return result;
    }
}

export interface IFindUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filterText: string | undefined;
}

export class ListResultDtoOfOrganizationUnitListDto implements IListResultDtoOfOrganizationUnitListDto {
    items: OrganizationUnitListDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfOrganizationUnitListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfOrganizationUnitListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfOrganizationUnitListDto {
    items: OrganizationUnitListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    userName: string | undefined;
    addedTime: moment.Moment;
    id: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): OrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new OrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IOrganizationUnitUserListDto {
    userName: string | undefined;
    addedTime: moment.Moment;
    id: number;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfOrganizationUnitUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class UserToOrganizationUnitInput implements IUserToOrganizationUnitInput {
    userId: number;
    organizationUnitId: number;

    constructor(data?: IUserToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UserToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UserToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): UserToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UserToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUserToOrganizationUnitInput {
    userId: number;
    organizationUnitId: number;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }

    clone(): MoveOrganizationUnitInput {
        const json = this.toJSON();
        let result = new MoveOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class RoleToOrganizationUnitInput implements IRoleToOrganizationUnitInput {
    roleId: number;
    organizationUnitId: number;

    constructor(data?: IRoleToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RoleToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RoleToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }

    clone(): RoleToOrganizationUnitInput {
        const json = this.toJSON();
        let result = new RoleToOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IRoleToOrganizationUnitInput {
    roleId: number;
    organizationUnitId: number;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number;
    displayName: string | undefined;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): UpdateOrganizationUnitInput {
        const json = this.toJSON();
        let result = new UpdateOrganizationUnitInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string | undefined;
}

/** 的列表DTO Yozeev.SystemConfig.PayMethod */
export class PayMethodEditDto implements IPayMethodEditDto {
    /** Id */
    id: number | undefined;
    /** PayName */
    payName: string | undefined;
    /** PayCode */
    payCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IPayMethodEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): PayMethodEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethodEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): PayMethodEditDto {
        const json = this.toJSON();
        let result = new PayMethodEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.PayMethod */
export interface IPayMethodEditDto {
    /** Id */
    id: number | undefined;
    /** PayName */
    payName: string | undefined;
    /** PayCode */
    payCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdatePayMethodInput implements ICreateOrUpdatePayMethodInput {
    payMethod: PayMethodEditDto;

    constructor(data?: ICreateOrUpdatePayMethodInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.payMethod = new PayMethodEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethodEditDto.fromJS(data["payMethod"]) : new PayMethodEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePayMethodInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePayMethodInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePayMethodInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePayMethodInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePayMethodInput {
    payMethod: PayMethodEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.PayMethod */
export class PayMethodListDto implements IPayMethodListDto {
    /** PayName */
    payName: string | undefined;
    /** PayCode */
    payCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPayMethodListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payName = data["payName"];
            this.payCode = data["payCode"];
            this.sort = data["sort"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PayMethodListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayMethodListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payName"] = this.payName;
        data["payCode"] = this.payCode;
        data["sort"] = this.sort;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PayMethodListDto {
        const json = this.toJSON();
        let result = new PayMethodListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.PayMethod */
export interface IPayMethodListDto {
    /** PayName */
    payName: string | undefined;
    /** PayCode */
    payCode: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetPayMethodForEditOutput implements IGetPayMethodForEditOutput {
    payMethod: PayMethodEditDto;

    constructor(data?: IGetPayMethodForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethodEditDto.fromJS(data["payMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPayMethodForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPayMethodForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPayMethodForEditOutput {
        const json = this.toJSON();
        let result = new GetPayMethodForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetPayMethodForEditOutput {
    payMethod: PayMethodEditDto;
}

export class PagedResultDtoOfPayMethodListDto implements IPagedResultDtoOfPayMethodListDto {
    totalCount: number;
    items: PayMethodListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPayMethodListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PayMethodListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPayMethodListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPayMethodListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPayMethodListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPayMethodListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPayMethodListDto {
    totalCount: number;
    items: PayMethodListDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new FlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfFlatPermissionWithLevelDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class TreePermissionDto implements ITreePermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    children: TreePermissionDto[] | undefined;
    checked: boolean;

    constructor(data?: ITreePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            if (data["children"] && data["children"].constructor === Array) {
                this.children = [] as any;
                for (let item of data["children"])
                    this.children.push(TreePermissionDto.fromJS(item));
            }
            this.checked = data["checked"];
        }
    }

    static fromJS(data: any): TreePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new TreePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        if (this.children && this.children.constructor === Array) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["checked"] = this.checked;
        return data; 
    }

    clone(): TreePermissionDto {
        const json = this.toJSON();
        let result = new TreePermissionDto();
        result.init(json);
        return result;
    }
}

export interface ITreePermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    children: TreePermissionDto[] | undefined;
    checked: boolean;
}

export class ListResultDtoOfTreePermissionDto implements IListResultDtoOfTreePermissionDto {
    items: TreePermissionDto[] | undefined;

    constructor(data?: IListResultDtoOfTreePermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TreePermissionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfTreePermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfTreePermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfTreePermissionDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfTreePermissionDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfTreePermissionDto {
    items: TreePermissionDto[] | undefined;
}

/** 的列表DTO Yozeev.SystemConfig.Power */
export class PowerEditDto implements IPowerEditDto {
    /** Id */
    id: number | undefined;
    /** MenuId */
    menuId: number;
    menu: Menu;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string | undefined;
    /** PowerName */
    powerName: string | undefined;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** PowerRoles */
    powerRoles: PowerRole[] | undefined;

    constructor(data?: IPowerEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
            if (data["powerRoles"] && data["powerRoles"].constructor === Array) {
                this.powerRoles = [] as any;
                for (let item of data["powerRoles"])
                    this.powerRoles.push(PowerRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PowerEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        if (this.powerRoles && this.powerRoles.constructor === Array) {
            data["powerRoles"] = [];
            for (let item of this.powerRoles)
                data["powerRoles"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PowerEditDto {
        const json = this.toJSON();
        let result = new PowerEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.Power */
export interface IPowerEditDto {
    /** Id */
    id: number | undefined;
    /** MenuId */
    menuId: number;
    menu: Menu;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string | undefined;
    /** PowerName */
    powerName: string | undefined;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** PowerRoles */
    powerRoles: PowerRole[] | undefined;
}

export class CreateOrUpdatePowerInput implements ICreateOrUpdatePowerInput {
    power: PowerEditDto;

    constructor(data?: ICreateOrUpdatePowerInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.power = new PowerEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.power = data["power"] ? PowerEditDto.fromJS(data["power"]) : new PowerEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePowerInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePowerInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePowerInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePowerInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePowerInput {
    power: PowerEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.Power */
export class PowerListDto implements IPowerListDto {
    /** MenuId */
    menuId: number;
    menu: Menu;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string | undefined;
    /** PowerName */
    powerName: string | undefined;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** PowerRoles */
    powerRoles: PowerRole[] | undefined;
    /** 是否使用 */
    isCheck: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPowerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menuId = data["menuId"];
            this.menu = data["menu"] ? Menu.fromJS(data["menu"]) : <any>undefined;
            this.menuPath = data["menuPath"];
            this.powerCode = data["powerCode"];
            this.powerName = data["powerName"];
            this.method = data["method"];
            this.params = data["params"];
            this.groupName = data["groupName"];
            this.sort = data["sort"];
            this.iocName = data["iocName"];
            this.iocClassName = data["iocClassName"];
            this.category = data["category"];
            this.isEnabled = data["isEnabled"];
            if (data["powerRoles"] && data["powerRoles"].constructor === Array) {
                this.powerRoles = [] as any;
                for (let item of data["powerRoles"])
                    this.powerRoles.push(PowerRole.fromJS(item));
            }
            this.isCheck = data["isCheck"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menuId"] = this.menuId;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["menuPath"] = this.menuPath;
        data["powerCode"] = this.powerCode;
        data["powerName"] = this.powerName;
        data["method"] = this.method;
        data["params"] = this.params;
        data["groupName"] = this.groupName;
        data["sort"] = this.sort;
        data["iocName"] = this.iocName;
        data["iocClassName"] = this.iocClassName;
        data["category"] = this.category;
        data["isEnabled"] = this.isEnabled;
        if (this.powerRoles && this.powerRoles.constructor === Array) {
            data["powerRoles"] = [];
            for (let item of this.powerRoles)
                data["powerRoles"].push(item.toJSON());
        }
        data["isCheck"] = this.isCheck;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerListDto {
        const json = this.toJSON();
        let result = new PowerListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.Power */
export interface IPowerListDto {
    /** MenuId */
    menuId: number;
    menu: Menu;
    /** MenuPath */
    menuPath: string | undefined;
    /** PowerCode */
    powerCode: string | undefined;
    /** PowerName */
    powerName: string | undefined;
    /** Method */
    method: string | undefined;
    /** Params */
    params: string | undefined;
    /** GroupName */
    groupName: string | undefined;
    /** Sort */
    sort: number | undefined;
    /** IocName */
    iocName: string | undefined;
    /** IocClassName */
    iocClassName: string | undefined;
    category: PowerTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** PowerRoles */
    powerRoles: PowerRole[] | undefined;
    /** 是否使用 */
    isCheck: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetPowerForEditOutput implements IGetPowerForEditOutput {
    power: PowerEditDto;
    powerTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetPowerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.power = data["power"] ? PowerEditDto.fromJS(data["power"]) : <any>undefined;
            if (data["powerTypeEnumTypeEnum"] && data["powerTypeEnumTypeEnum"].constructor === Array) {
                this.powerTypeEnumTypeEnum = [] as any;
                for (let item of data["powerTypeEnumTypeEnum"])
                    this.powerTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPowerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPowerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        if (this.powerTypeEnumTypeEnum && this.powerTypeEnumTypeEnum.constructor === Array) {
            data["powerTypeEnumTypeEnum"] = [];
            for (let item of this.powerTypeEnumTypeEnum)
                data["powerTypeEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetPowerForEditOutput {
        const json = this.toJSON();
        let result = new GetPowerForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetPowerForEditOutput {
    power: PowerEditDto;
    powerTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfPowerListDto implements IPagedResultDtoOfPowerListDto {
    totalCount: number;
    items: PowerListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPowerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PowerListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPowerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPowerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPowerListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPowerListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPowerListDto {
    totalCount: number;
    items: PowerListDto[] | undefined;
}

/** 的列表DTO Yozeev.SystemConfig.PowerRole */
export class PowerRoleEditDto implements IPowerRoleEditDto {
    /** Id */
    id: number | undefined;
    /** RoleId */
    roleId: number;
    role: Role;
    /** PowerId */
    powerId: number;
    power: Power;

    constructor(data?: IPowerRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.powerId = data["powerId"];
            this.power = data["power"] ? Power.fromJS(data["power"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PowerRoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["powerId"] = this.powerId;
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        return data; 
    }

    clone(): PowerRoleEditDto {
        const json = this.toJSON();
        let result = new PowerRoleEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.SystemConfig.PowerRole */
export interface IPowerRoleEditDto {
    /** Id */
    id: number | undefined;
    /** RoleId */
    roleId: number;
    role: Role;
    /** PowerId */
    powerId: number;
    power: Power;
}

export class CreateOrUpdatePowerRoleInput implements ICreateOrUpdatePowerRoleInput {
    powerRole: PowerRoleEditDto;

    constructor(data?: ICreateOrUpdatePowerRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.powerRole = new PowerRoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.powerRole = data["powerRole"] ? PowerRoleEditDto.fromJS(data["powerRole"]) : new PowerRoleEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePowerRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePowerRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerRole"] = this.powerRole ? this.powerRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePowerRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePowerRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePowerRoleInput {
    powerRole: PowerRoleEditDto;
}

/** 的编辑DTO Yozeev.SystemConfig.PowerRole */
export class PowerRoleListDto implements IPowerRoleListDto {
    /** RoleId */
    roleId: number;
    role: Role;
    /** PowerId */
    powerId: number;
    power: Power;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPowerRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.powerId = data["powerId"];
            this.power = data["power"] ? Power.fromJS(data["power"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PowerRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PowerRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["powerId"] = this.powerId;
        data["power"] = this.power ? this.power.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PowerRoleListDto {
        const json = this.toJSON();
        let result = new PowerRoleListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.SystemConfig.PowerRole */
export interface IPowerRoleListDto {
    /** RoleId */
    roleId: number;
    role: Role;
    /** PowerId */
    powerId: number;
    power: Power;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetPowerRoleForEditOutput implements IGetPowerRoleForEditOutput {
    powerRole: PowerRoleEditDto;

    constructor(data?: IGetPowerRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.powerRole = data["powerRole"] ? PowerRoleEditDto.fromJS(data["powerRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPowerRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPowerRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["powerRole"] = this.powerRole ? this.powerRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetPowerRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetPowerRoleForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetPowerRoleForEditOutput {
    powerRole: PowerRoleEditDto;
}

export class PagedResultDtoOfPowerRoleListDto implements IPagedResultDtoOfPowerRoleListDto {
    totalCount: number;
    items: PowerRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPowerRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PowerRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPowerRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPowerRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPowerRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPowerRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPowerRoleListDto {
    totalCount: number;
    items: PowerRoleListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.PriceAudit */
export class PriceAuditEditDto implements IPriceAuditEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** OrgTicketPriceId */
    orgTicketPriceId: number | undefined;
    orgTicketPrice: TicketPrice;
    /** IsEnabled */
    isEnabled: boolean;
    /** Price */
    price: number;
    /** Discount */
    discount: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    auditStatus: AuditStatusEnum;
    /** TicketName */
    ticketName: string | undefined;

    constructor(data?: IPriceAuditEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.orgTicketPriceId = data["orgTicketPriceId"];
            this.orgTicketPrice = data["orgTicketPrice"] ? TicketPrice.fromJS(data["orgTicketPrice"]) : <any>undefined;
            this.isEnabled = data["isEnabled"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.auditStatus = data["auditStatus"];
            this.ticketName = data["ticketName"];
        }
    }

    static fromJS(data: any): PriceAuditEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAuditEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["orgTicketPriceId"] = this.orgTicketPriceId;
        data["orgTicketPrice"] = this.orgTicketPrice ? this.orgTicketPrice.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        data["ticketName"] = this.ticketName;
        return data; 
    }

    clone(): PriceAuditEditDto {
        const json = this.toJSON();
        let result = new PriceAuditEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.PriceAudit */
export interface IPriceAuditEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** OrgTicketPriceId */
    orgTicketPriceId: number | undefined;
    orgTicketPrice: TicketPrice;
    /** IsEnabled */
    isEnabled: boolean;
    /** Price */
    price: number;
    /** Discount */
    discount: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    auditStatus: AuditStatusEnum;
    /** TicketName */
    ticketName: string | undefined;
}

export class CreateOrUpdatePriceAuditInput implements ICreateOrUpdatePriceAuditInput {
    priceAudit: PriceAuditEditDto;

    constructor(data?: ICreateOrUpdatePriceAuditInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.priceAudit = new PriceAuditEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.priceAudit = data["priceAudit"] ? PriceAuditEditDto.fromJS(data["priceAudit"]) : new PriceAuditEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePriceAuditInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePriceAuditInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceAudit"] = this.priceAudit ? this.priceAudit.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePriceAuditInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePriceAuditInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePriceAuditInput {
    priceAudit: PriceAuditEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.PriceAudit */
export class PriceAuditListDto implements IPriceAuditListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** OrgTicketPriceId */
    orgTicketPriceId: number | undefined;
    orgTicketPrice: TicketPrice;
    /** IsEnabled */
    isEnabled: boolean;
    /** Price */
    price: number;
    /** Discount */
    discount: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    auditStatus: AuditStatusEnum;
    /** TicketName */
    ticketName: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPriceAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.orgTicketPriceId = data["orgTicketPriceId"];
            this.orgTicketPrice = data["orgTicketPrice"] ? TicketPrice.fromJS(data["orgTicketPrice"]) : <any>undefined;
            this.isEnabled = data["isEnabled"];
            this.price = data["price"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.auditStatus = data["auditStatus"];
            this.ticketName = data["ticketName"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PriceAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriceAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["orgTicketPriceId"] = this.orgTicketPriceId;
        data["orgTicketPrice"] = this.orgTicketPrice ? this.orgTicketPrice.toJSON() : <any>undefined;
        data["isEnabled"] = this.isEnabled;
        data["price"] = this.price;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["auditStatus"] = this.auditStatus;
        data["ticketName"] = this.ticketName;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PriceAuditListDto {
        const json = this.toJSON();
        let result = new PriceAuditListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.PriceAudit */
export interface IPriceAuditListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** OrgTicketPriceId */
    orgTicketPriceId: number | undefined;
    orgTicketPrice: TicketPrice;
    /** IsEnabled */
    isEnabled: boolean;
    /** Price */
    price: number;
    /** Discount */
    discount: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment | undefined;
    auditStatus: AuditStatusEnum;
    /** TicketName */
    ticketName: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetPriceAuditForEditOutput implements IGetPriceAuditForEditOutput {
    priceAudit: PriceAuditEditDto;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetPriceAuditForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priceAudit = data["priceAudit"] ? PriceAuditEditDto.fromJS(data["priceAudit"]) : <any>undefined;
            if (data["auditStatusEnumTypeEnum"] && data["auditStatusEnumTypeEnum"].constructor === Array) {
                this.auditStatusEnumTypeEnum = [] as any;
                for (let item of data["auditStatusEnumTypeEnum"])
                    this.auditStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPriceAuditForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPriceAuditForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priceAudit"] = this.priceAudit ? this.priceAudit.toJSON() : <any>undefined;
        if (this.auditStatusEnumTypeEnum && this.auditStatusEnumTypeEnum.constructor === Array) {
            data["auditStatusEnumTypeEnum"] = [];
            for (let item of this.auditStatusEnumTypeEnum)
                data["auditStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetPriceAuditForEditOutput {
        const json = this.toJSON();
        let result = new GetPriceAuditForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetPriceAuditForEditOutput {
    priceAudit: PriceAuditEditDto;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfPriceAuditListDto implements IPagedResultDtoOfPriceAuditListDto {
    totalCount: number;
    items: PriceAuditListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPriceAuditListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PriceAuditListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPriceAuditListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPriceAuditListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPriceAuditListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPriceAuditListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPriceAuditListDto {
    totalCount: number;
    items: PriceAuditListDto[] | undefined;
}

export enum PrintTypeEnum {
    Test = <any>"Test", 
    QrCode = <any>"QrCode", 
}

/** 的列表DTO Yozeev.BusinessLogic.PrintElement */
export class PrintElementEditDto implements IPrintElementEditDto {
    /** Id */
    id: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    printType: PrintTypeEnum;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;

    constructor(data?: IPrintElementEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.groupName = data["groupName"];
            this.printType = data["printType"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
        }
    }

    static fromJS(data: any): PrintElementEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintElementEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["groupName"] = this.groupName;
        data["printType"] = this.printType;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        return data; 
    }

    clone(): PrintElementEditDto {
        const json = this.toJSON();
        let result = new PrintElementEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.PrintElement */
export interface IPrintElementEditDto {
    /** Id */
    id: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    printType: PrintTypeEnum;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
}

export class CreateOrUpdatePrintElementInput implements ICreateOrUpdatePrintElementInput {
    printElement: PrintElementEditDto;

    constructor(data?: ICreateOrUpdatePrintElementInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.printElement = new PrintElementEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.printElement = data["printElement"] ? PrintElementEditDto.fromJS(data["printElement"]) : new PrintElementEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdatePrintElementInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdatePrintElementInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["printElement"] = this.printElement ? this.printElement.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdatePrintElementInput {
        const json = this.toJSON();
        let result = new CreateOrUpdatePrintElementInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdatePrintElementInput {
    printElement: PrintElementEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.PrintElement */
export class PrintElementListDto implements IPrintElementListDto {
    /** BranchId */
    branchId: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    printType: PrintTypeEnum;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IPrintElementListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.groupName = data["groupName"];
            this.printType = data["printType"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): PrintElementListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PrintElementListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["groupName"] = this.groupName;
        data["printType"] = this.printType;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): PrintElementListDto {
        const json = this.toJSON();
        let result = new PrintElementListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.PrintElement */
export interface IPrintElementListDto {
    /** BranchId */
    branchId: number | undefined;
    /** GroupName */
    groupName: string | undefined;
    printType: PrintTypeEnum;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetPrintElementForEditOutput implements IGetPrintElementForEditOutput {
    printElement: PrintElementEditDto;
    printTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketModeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetPrintElementForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.printElement = data["printElement"] ? PrintElementEditDto.fromJS(data["printElement"]) : <any>undefined;
            if (data["printTypeEnumTypeEnum"] && data["printTypeEnumTypeEnum"].constructor === Array) {
                this.printTypeEnumTypeEnum = [] as any;
                for (let item of data["printTypeEnumTypeEnum"])
                    this.printTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["ticketModeEnumTypeEnum"] && data["ticketModeEnumTypeEnum"].constructor === Array) {
                this.ticketModeEnumTypeEnum = [] as any;
                for (let item of data["ticketModeEnumTypeEnum"])
                    this.ticketModeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["ticketTypeEnumTypeEnum"] && data["ticketTypeEnumTypeEnum"].constructor === Array) {
                this.ticketTypeEnumTypeEnum = [] as any;
                for (let item of data["ticketTypeEnumTypeEnum"])
                    this.ticketTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["checkMethodEnumTypeEnum"] && data["checkMethodEnumTypeEnum"].constructor === Array) {
                this.checkMethodEnumTypeEnum = [] as any;
                for (let item of data["checkMethodEnumTypeEnum"])
                    this.checkMethodEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["auditStatusEnumTypeEnum"] && data["auditStatusEnumTypeEnum"].constructor === Array) {
                this.auditStatusEnumTypeEnum = [] as any;
                for (let item of data["auditStatusEnumTypeEnum"])
                    this.auditStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPrintElementForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPrintElementForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["printElement"] = this.printElement ? this.printElement.toJSON() : <any>undefined;
        if (this.printTypeEnumTypeEnum && this.printTypeEnumTypeEnum.constructor === Array) {
            data["printTypeEnumTypeEnum"] = [];
            for (let item of this.printTypeEnumTypeEnum)
                data["printTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.ticketModeEnumTypeEnum && this.ticketModeEnumTypeEnum.constructor === Array) {
            data["ticketModeEnumTypeEnum"] = [];
            for (let item of this.ticketModeEnumTypeEnum)
                data["ticketModeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.ticketTypeEnumTypeEnum && this.ticketTypeEnumTypeEnum.constructor === Array) {
            data["ticketTypeEnumTypeEnum"] = [];
            for (let item of this.ticketTypeEnumTypeEnum)
                data["ticketTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.checkMethodEnumTypeEnum && this.checkMethodEnumTypeEnum.constructor === Array) {
            data["checkMethodEnumTypeEnum"] = [];
            for (let item of this.checkMethodEnumTypeEnum)
                data["checkMethodEnumTypeEnum"].push(item.toJSON());
        }
        if (this.auditStatusEnumTypeEnum && this.auditStatusEnumTypeEnum.constructor === Array) {
            data["auditStatusEnumTypeEnum"] = [];
            for (let item of this.auditStatusEnumTypeEnum)
                data["auditStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetPrintElementForEditOutput {
        const json = this.toJSON();
        let result = new GetPrintElementForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetPrintElementForEditOutput {
    printElement: PrintElementEditDto;
    printTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketModeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfPrintElementListDto implements IPagedResultDtoOfPrintElementListDto {
    totalCount: number;
    items: PrintElementListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfPrintElementListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(PrintElementListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfPrintElementListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfPrintElementListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfPrintElementListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfPrintElementListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfPrintElementListDto {
    totalCount: number;
    items: PrintElementListDto[] | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string | undefined;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }

    clone(): ChangeUserLanguageDto {
        const json = this.toJSON();
        let result = new ChangeUserLanguageDto();
        result.init(json);
        return result;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string | undefined;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }

    clone(): ChangePasswordInput {
        const json = this.toJSON();
        let result = new ChangePasswordInput();
        result.init(json);
        return result;
    }
}

export interface IChangePasswordInput {
    currentPassword: string | undefined;
    newPassword: string | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    userName: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    /** 时区 */
    timezone: string | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.fullName = data["fullName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["fullName"] = this.fullName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        return data; 
    }

    clone(): CurrentUserProfileEditDto {
        const json = this.toJSON();
        let result = new CurrentUserProfileEditDto();
        result.init(json);
        return result;
    }
}

export interface ICurrentUserProfileEditDto {
    userName: string | undefined;
    fullName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    /** 时区 */
    timezone: string | undefined;
}

/** 用户头像输出 */
export class GetProfilePictureOutputDto implements IGetProfilePictureOutputDto {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutputDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }

    clone(): GetProfilePictureOutputDto {
        const json = this.toJSON();
        let result = new GetProfilePictureOutputDto();
        result.init(json);
        return result;
    }
}

/** 用户头像输出 */
export interface IGetProfilePictureOutputDto {
    profilePicture: string | undefined;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }

    clone(): UpdateProfilePictureInput {
        const json = this.toJSON();
        let result = new UpdateProfilePictureInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    x: number;
    y: number;
    width: number;
    height: number;
}

export class PurchasePayInput implements IPurchasePayInput {
    /** 订单编码 */
    orderCode: string | undefined;

    constructor(data?: IPurchasePayInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
        }
    }

    static fromJS(data: any): PurchasePayInput {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasePayInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        return data; 
    }

    clone(): PurchasePayInput {
        const json = this.toJSON();
        let result = new PurchasePayInput();
        result.init(json);
        return result;
    }
}

export interface IPurchasePayInput {
    /** 订单编码 */
    orderCode: string | undefined;
}

export enum RechargeStatusEnum {
    Wait = <any>"Wait", 
    Complete = <any>"Complete", 
    Cancel = <any>"Cancel", 
}

/** 的列表DTO Yozeev.BusinessLogic.RechargeRecord */
export class RechargeRecordEditDto implements IRechargeRecordEditDto {
    /** Id */
    id: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number;
    travelAgency: TravelAgency;
    /** Amount */
    amount: number;
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;

    constructor(data?: IRechargeRecordEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            this.amount = data["amount"];
            this.rechargeStatus = data["rechargeStatus"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RechargeRecordEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeRecordEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["rechargeStatus"] = this.rechargeStatus;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        return data; 
    }

    clone(): RechargeRecordEditDto {
        const json = this.toJSON();
        let result = new RechargeRecordEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.RechargeRecord */
export interface IRechargeRecordEditDto {
    /** Id */
    id: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number;
    travelAgency: TravelAgency;
    /** Amount */
    amount: number;
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
}

export class CreateOrUpdateRechargeRecordInput implements ICreateOrUpdateRechargeRecordInput {
    rechargeRecord: RechargeRecordEditDto;

    constructor(data?: ICreateOrUpdateRechargeRecordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.rechargeRecord = new RechargeRecordEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.rechargeRecord = data["rechargeRecord"] ? RechargeRecordEditDto.fromJS(data["rechargeRecord"]) : new RechargeRecordEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateRechargeRecordInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRechargeRecordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rechargeRecord"] = this.rechargeRecord ? this.rechargeRecord.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateRechargeRecordInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRechargeRecordInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRechargeRecordInput {
    rechargeRecord: RechargeRecordEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.RechargeRecord */
export class RechargeRecordListDto implements IRechargeRecordListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number;
    travelAgency: TravelAgency;
    /** Amount */
    amount: number;
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IRechargeRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.travelAgency = data["travelAgency"] ? TravelAgency.fromJS(data["travelAgency"]) : <any>undefined;
            this.amount = data["amount"];
            this.rechargeStatus = data["rechargeStatus"];
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RechargeRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RechargeRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        data["amount"] = this.amount;
        data["rechargeStatus"] = this.rechargeStatus;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): RechargeRecordListDto {
        const json = this.toJSON();
        let result = new RechargeRecordListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.RechargeRecord */
export interface IRechargeRecordListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TravelAgencyId */
    travelAgencyId: number;
    travelAgency: TravelAgency;
    /** Amount */
    amount: number;
    rechargeStatus: RechargeStatusEnum;
    /** PayMethodId */
    payMethodId: number;
    payMethod: PayMethod;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetRechargeRecordForEditOutput implements IGetRechargeRecordForEditOutput {
    rechargeRecord: RechargeRecordEditDto;
    rechargeStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetRechargeRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rechargeRecord = data["rechargeRecord"] ? RechargeRecordEditDto.fromJS(data["rechargeRecord"]) : <any>undefined;
            if (data["rechargeStatusEnumTypeEnum"] && data["rechargeStatusEnumTypeEnum"].constructor === Array) {
                this.rechargeStatusEnumTypeEnum = [] as any;
                for (let item of data["rechargeStatusEnumTypeEnum"])
                    this.rechargeStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRechargeRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRechargeRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rechargeRecord"] = this.rechargeRecord ? this.rechargeRecord.toJSON() : <any>undefined;
        if (this.rechargeStatusEnumTypeEnum && this.rechargeStatusEnumTypeEnum.constructor === Array) {
            data["rechargeStatusEnumTypeEnum"] = [];
            for (let item of this.rechargeStatusEnumTypeEnum)
                data["rechargeStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetRechargeRecordForEditOutput {
        const json = this.toJSON();
        let result = new GetRechargeRecordForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetRechargeRecordForEditOutput {
    rechargeRecord: RechargeRecordEditDto;
    rechargeStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfRechargeRecordListDto implements IPagedResultDtoOfRechargeRecordListDto {
    totalCount: number;
    items: RechargeRecordListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRechargeRecordListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RechargeRecordListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRechargeRecordListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRechargeRecordListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRechargeRecordListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRechargeRecordListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRechargeRecordListDto {
    totalCount: number;
    items: RechargeRecordListDto[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string | undefined;
    isDefault: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }

    clone(): RoleEditDto {
        const json = this.toJSON();
        let result = new RoleEditDto();
        result.init(json);
        return result;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string | undefined;
    isDefault: boolean;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): CreateOrUpdateRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }

    clone(): RoleListDto {
        const json = this.toJSON();
        let result = new RoleListDto();
        result.init(json);
        return result;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: moment.Moment;
    id: number;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }

    clone(): FlatPermissionDto {
        const json = this.toJSON();
        let result = new FlatPermissionDto();
        result.init(json);
        return result;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    /** 票价Id列表 */
    ticketPriceIds: number[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
            if (data["ticketPriceIds"] && data["ticketPriceIds"].constructor === Array) {
                this.ticketPriceIds = [] as any;
                for (let item of data["ticketPriceIds"])
                    this.ticketPriceIds.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        if (this.ticketPriceIds && this.ticketPriceIds.constructor === Array) {
            data["ticketPriceIds"] = [];
            for (let item of this.ticketPriceIds)
                data["ticketPriceIds"].push(item);
        }
        return data; 
    }

    clone(): GetRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetRoleForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
    /** 票价Id列表 */
    ticketPriceIds: number[] | undefined;
}

export class PagedResultDtoOfRoleListDto implements IPagedResultDtoOfRoleListDto {
    totalCount: number;
    items: RoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfRoleListDto {
    totalCount: number;
    items: RoleListDto[] | undefined;
}

export class UpdateRolePermissionsInput implements IUpdateRolePermissionsInput {
    roleId: number;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IUpdateRolePermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateRolePermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRolePermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateRolePermissionsInput {
        const json = this.toJSON();
        let result = new UpdateRolePermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateRolePermissionsInput {
    roleId: number;
    grantedPermissionNames: string[] | undefined;
}

export class ScenicSpot implements IScenicSpot {
    branchId: number | undefined;
    scenicSpotName: string | undefined;
    parentId: number | undefined;
    parent: ScenicSpot;
    scenicSpotInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IScenicSpot) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? ScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.scenicSpotInfo = data["scenicSpotInfo"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScenicSpot {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpot();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScenicSpot {
        const json = this.toJSON();
        let result = new ScenicSpot();
        result.init(json);
        return result;
    }
}

export interface IScenicSpot {
    branchId: number | undefined;
    scenicSpotName: string | undefined;
    parentId: number | undefined;
    parent: ScenicSpot;
    scenicSpotInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.ScenicSpot */
export class ScenicSpotEditDto implements IScenicSpotEditDto {
    /** Id */
    id: number | undefined;
    /** 景区名称 */
    scenicSpotName: string | undefined;
    /** 上级景区 */
    parentId: number | undefined;
    parent: ScenicSpot;
    /** 景区说明 */
    scenicSpotInfo: string | undefined;

    constructor(data?: IScenicSpotEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? ScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.scenicSpotInfo = data["scenicSpotInfo"];
        }
    }

    static fromJS(data: any): ScenicSpotEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpotEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        return data; 
    }

    clone(): ScenicSpotEditDto {
        const json = this.toJSON();
        let result = new ScenicSpotEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.ScenicSpot */
export interface IScenicSpotEditDto {
    /** Id */
    id: number | undefined;
    /** 景区名称 */
    scenicSpotName: string | undefined;
    /** 上级景区 */
    parentId: number | undefined;
    parent: ScenicSpot;
    /** 景区说明 */
    scenicSpotInfo: string | undefined;
}

export class CreateOrUpdateScenicSpotInput implements ICreateOrUpdateScenicSpotInput {
    scenicSpot: ScenicSpotEditDto;

    constructor(data?: ICreateOrUpdateScenicSpotInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.scenicSpot = new ScenicSpotEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.scenicSpot = data["scenicSpot"] ? ScenicSpotEditDto.fromJS(data["scenicSpot"]) : new ScenicSpotEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateScenicSpotInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateScenicSpotInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateScenicSpotInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateScenicSpotInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateScenicSpotInput {
    scenicSpot: ScenicSpotEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.ScenicSpot */
export class ScenicSpotListDto implements IScenicSpotListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 景区名称 */
    scenicSpotName: string | undefined;
    /** 上级景区 */
    parentId: number | undefined;
    parent: ScenicSpot;
    /** 景区说明 */
    scenicSpotInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? ScenicSpot.fromJS(data["parent"]) : <any>undefined;
            this.scenicSpotInfo = data["scenicSpotInfo"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["scenicSpotInfo"] = this.scenicSpotInfo;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): ScenicSpotListDto {
        const json = this.toJSON();
        let result = new ScenicSpotListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.ScenicSpot */
export interface IScenicSpotListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 景区名称 */
    scenicSpotName: string | undefined;
    /** 上级景区 */
    parentId: number | undefined;
    parent: ScenicSpot;
    /** 景区说明 */
    scenicSpotInfo: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetScenicSpotForEditOutput implements IGetScenicSpotForEditOutput {
    scenicSpot: ScenicSpotEditDto;

    constructor(data?: IGetScenicSpotForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scenicSpot = data["scenicSpot"] ? ScenicSpotEditDto.fromJS(data["scenicSpot"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetScenicSpotForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetScenicSpotForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetScenicSpotForEditOutput {
        const json = this.toJSON();
        let result = new GetScenicSpotForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetScenicSpotForEditOutput {
    scenicSpot: ScenicSpotEditDto;
}

export class PagedResultDtoOfScenicSpotListDto implements IPagedResultDtoOfScenicSpotListDto {
    totalCount: number;
    items: ScenicSpotListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(ScenicSpotListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfScenicSpotListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfScenicSpotListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfScenicSpotListDto {
    totalCount: number;
    items: ScenicSpotListDto[] | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserLoginInfoDto {
        const json = this.toJSON();
        let result = new UserLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    id: number;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }

    clone(): EditionInfoDto {
        const json = this.toJSON();
        let result = new EditionInfoDto();
        result.init(json);
        return result;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    creationTimeString: string | undefined;
    id: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantLoginInfoDto {
        const json = this.toJSON();
        let result = new TenantLoginInfoDto();
        result.init(json);
        return result;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    edition: EditionInfoDto;
    creationTime: moment.Moment;
    creationTimeString: string | undefined;
    id: number;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }

    clone(): ApplicationInfoDto {
        const json = this.toJSON();
        let result = new ApplicationInfoDto();
        result.init(json);
        return result;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment;
    features: { [key: string] : boolean; } | undefined;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetCurrentLoginInformationsOutput {
        const json = this.toJSON();
        let result = new GetCurrentLoginInformationsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
}

export enum MultiTenancySides {
    Tenant = <any>"Tenant", 
    Host = <any>"Host", 
}

export class AbpMultiTenancySidesConfigDto implements IAbpMultiTenancySidesConfigDto {
    host: MultiTenancySides;
    tenant: MultiTenancySides;

    constructor(data?: IAbpMultiTenancySidesConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.host = data["host"];
            this.tenant = data["tenant"];
        }
    }

    static fromJS(data: any): AbpMultiTenancySidesConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["tenant"] = this.tenant;
        return data; 
    }

    clone(): AbpMultiTenancySidesConfigDto {
        const json = this.toJSON();
        let result = new AbpMultiTenancySidesConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpMultiTenancySidesConfigDto {
    host: MultiTenancySides;
    tenant: MultiTenancySides;
}

export class AbpMultiTenancyConfigDto implements IAbpMultiTenancyConfigDto {
    isEnabled: boolean;
    ignoreFeatureCheckForHostUsers: boolean;
    sides: AbpMultiTenancySidesConfigDto;

    constructor(data?: IAbpMultiTenancyConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.ignoreFeatureCheckForHostUsers = data["ignoreFeatureCheckForHostUsers"];
            this.sides = data["sides"] ? AbpMultiTenancySidesConfigDto.fromJS(data["sides"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpMultiTenancyConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpMultiTenancyConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["ignoreFeatureCheckForHostUsers"] = this.ignoreFeatureCheckForHostUsers;
        data["sides"] = this.sides ? this.sides.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpMultiTenancyConfigDto {
        const json = this.toJSON();
        let result = new AbpMultiTenancyConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpMultiTenancyConfigDto {
    isEnabled: boolean;
    ignoreFeatureCheckForHostUsers: boolean;
    sides: AbpMultiTenancySidesConfigDto;
}

export class AbpUserSessionConfigDto implements IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides;

    constructor(data?: IAbpUserSessionConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.multiTenancySide = data["multiTenancySide"];
        }
    }

    static fromJS(data: any): AbpUserSessionConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSessionConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["multiTenancySide"] = this.multiTenancySide;
        return data; 
    }

    clone(): AbpUserSessionConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSessionConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSessionConfigDto {
    userId: number | undefined;
    tenantId: number | undefined;
    impersonatorUserId: number | undefined;
    impersonatorTenantId: number | undefined;
    multiTenancySide: MultiTenancySides;
}

export class AbpUserCurrentCultureConfigDto implements IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;

    constructor(data?: IAbpUserCurrentCultureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AbpUserCurrentCultureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        return data; 
    }

    clone(): AbpUserCurrentCultureConfigDto {
        const json = this.toJSON();
        let result = new AbpUserCurrentCultureConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserCurrentCultureConfigDto {
    name: string | undefined;
    displayName: string | undefined;
}

export class LanguageInfo implements ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean;
    isDisabled: boolean;
    readonly isRightToLeft: boolean;

    constructor(data?: ILanguageInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDefault = data["isDefault"];
            this.isDisabled = data["isDisabled"];
            (<any>this).isRightToLeft = data["isRightToLeft"];
        }
    }

    static fromJS(data: any): LanguageInfo {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDefault"] = this.isDefault;
        data["isDisabled"] = this.isDisabled;
        data["isRightToLeft"] = this.isRightToLeft;
        return data; 
    }

    clone(): LanguageInfo {
        const json = this.toJSON();
        let result = new LanguageInfo();
        result.init(json);
        return result;
    }
}

export interface ILanguageInfo {
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDefault: boolean;
    isDisabled: boolean;
    isRightToLeft: boolean;
}

export class AbpLocalizationSourceDto implements IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;

    constructor(data?: IAbpLocalizationSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.type = data["type"];
        }
    }

    static fromJS(data: any): AbpLocalizationSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpLocalizationSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["type"] = this.type;
        return data; 
    }

    clone(): AbpLocalizationSourceDto {
        const json = this.toJSON();
        let result = new AbpLocalizationSourceDto();
        result.init(json);
        return result;
    }
}

export interface IAbpLocalizationSourceDto {
    name: string | undefined;
    type: string | undefined;
}

export class AbpUserLocalizationConfigDto implements IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string] : { [key: string] : string; }; } | undefined;

    constructor(data?: IAbpUserLocalizationConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentCulture = data["currentCulture"] ? AbpUserCurrentCultureConfigDto.fromJS(data["currentCulture"]) : <any>undefined;
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages.push(LanguageInfo.fromJS(item));
            }
            this.currentLanguage = data["currentLanguage"] ? LanguageInfo.fromJS(data["currentLanguage"]) : <any>undefined;
            if (data["sources"] && data["sources"].constructor === Array) {
                this.sources = [] as any;
                for (let item of data["sources"])
                    this.sources.push(AbpLocalizationSourceDto.fromJS(item));
            }
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key] !== undefined ? data["values"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): AbpUserLocalizationConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserLocalizationConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentCulture"] = this.currentCulture ? this.currentCulture.toJSON() : <any>undefined;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        data["currentLanguage"] = this.currentLanguage ? this.currentLanguage.toJSON() : <any>undefined;
        if (this.sources && this.sources.constructor === Array) {
            data["sources"] = [];
            for (let item of this.sources)
                data["sources"].push(item.toJSON());
        }
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }

    clone(): AbpUserLocalizationConfigDto {
        const json = this.toJSON();
        let result = new AbpUserLocalizationConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserLocalizationConfigDto {
    currentCulture: AbpUserCurrentCultureConfigDto;
    languages: LanguageInfo[] | undefined;
    currentLanguage: LanguageInfo;
    sources: AbpLocalizationSourceDto[] | undefined;
    values: { [key: string] : { [key: string] : string; }; } | undefined;
}

export class AbpStringValueDto implements IAbpStringValueDto {
    value: string | undefined;

    constructor(data?: IAbpStringValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): AbpStringValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpStringValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        return data; 
    }

    clone(): AbpStringValueDto {
        const json = this.toJSON();
        let result = new AbpStringValueDto();
        result.init(json);
        return result;
    }
}

export interface IAbpStringValueDto {
    value: string | undefined;
}

export class AbpUserFeatureConfigDto implements IAbpUserFeatureConfigDto {
    allFeatures: { [key: string] : AbpStringValueDto; } | undefined;

    constructor(data?: IAbpUserFeatureConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"]) {
                this.allFeatures = {} as any;
                for (let key in data["allFeatures"]) {
                    if (data["allFeatures"].hasOwnProperty(key))
                        this.allFeatures[key] = data["allFeatures"][key] ? AbpStringValueDto.fromJS(data["allFeatures"][key]) : new AbpStringValueDto();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserFeatureConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserFeatureConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures) {
            data["allFeatures"] = {};
            for (let key in this.allFeatures) {
                if (this.allFeatures.hasOwnProperty(key))
                    data["allFeatures"][key] = this.allFeatures[key] ? this.allFeatures[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): AbpUserFeatureConfigDto {
        const json = this.toJSON();
        let result = new AbpUserFeatureConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserFeatureConfigDto {
    allFeatures: { [key: string] : AbpStringValueDto; } | undefined;
}

export class AbpUserAuthConfigDto implements IAbpUserAuthConfigDto {
    allPermissions: { [key: string] : string; } | undefined;
    grantedPermissions: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserAuthConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allPermissions"]) {
                this.allPermissions = {} as any;
                for (let key in data["allPermissions"]) {
                    if (data["allPermissions"].hasOwnProperty(key))
                        this.allPermissions[key] = data["allPermissions"][key];
                }
            }
            if (data["grantedPermissions"]) {
                this.grantedPermissions = {} as any;
                for (let key in data["grantedPermissions"]) {
                    if (data["grantedPermissions"].hasOwnProperty(key))
                        this.grantedPermissions[key] = data["grantedPermissions"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserAuthConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAuthConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allPermissions) {
            data["allPermissions"] = {};
            for (let key in this.allPermissions) {
                if (this.allPermissions.hasOwnProperty(key))
                    data["allPermissions"][key] = this.allPermissions[key];
            }
        }
        if (this.grantedPermissions) {
            data["grantedPermissions"] = {};
            for (let key in this.grantedPermissions) {
                if (this.grantedPermissions.hasOwnProperty(key))
                    data["grantedPermissions"][key] = this.grantedPermissions[key];
            }
        }
        return data; 
    }

    clone(): AbpUserAuthConfigDto {
        const json = this.toJSON();
        let result = new AbpUserAuthConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserAuthConfigDto {
    allPermissions: { [key: string] : string; } | undefined;
    grantedPermissions: { [key: string] : string; } | undefined;
}

export class UserMenuItem implements IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number;
    url: string | undefined;
    customData: CustomData | undefined;
    target: string | undefined;
    isEnabled: boolean;
    isVisible: boolean;
    items: UserMenuItem[] | undefined;

    constructor(data?: IUserMenuItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.icon = data["icon"];
            this.displayName = data["displayName"];
            this.order = data["order"];
            this.url = data["url"];
            this.customData = data["customData"] ? CustomData.fromJS(data["customData"]) : <any>undefined;
            this.target = data["target"];
            this.isEnabled = data["isEnabled"];
            this.isVisible = data["isVisible"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenuItem {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenuItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["displayName"] = this.displayName;
        data["order"] = this.order;
        data["url"] = this.url;
        data["customData"] = this.customData ? this.customData.toJSON() : <any>undefined;
        data["target"] = this.target;
        data["isEnabled"] = this.isEnabled;
        data["isVisible"] = this.isVisible;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserMenuItem {
        const json = this.toJSON();
        let result = new UserMenuItem();
        result.init(json);
        return result;
    }
}

export interface IUserMenuItem {
    name: string | undefined;
    icon: string | undefined;
    displayName: string | undefined;
    order: number;
    url: string | undefined;
    customData: CustomData | undefined;
    target: string | undefined;
    isEnabled: boolean;
    isVisible: boolean;
    items: UserMenuItem[] | undefined;
}

export class UserMenu implements IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: CustomData2 | undefined;
    items: UserMenuItem[] | undefined;

    constructor(data?: IUserMenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.customData = data["customData"] ? CustomData2.fromJS(data["customData"]) : <any>undefined;
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserMenuItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserMenu {
        data = typeof data === 'object' ? data : {};
        let result = new UserMenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["customData"] = this.customData ? this.customData.toJSON() : <any>undefined;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UserMenu {
        const json = this.toJSON();
        let result = new UserMenu();
        result.init(json);
        return result;
    }
}

export interface IUserMenu {
    name: string | undefined;
    displayName: string | undefined;
    customData: CustomData2 | undefined;
    items: UserMenuItem[] | undefined;
}

export class AbpUserNavConfigDto implements IAbpUserNavConfigDto {
    menus: { [key: string] : UserMenu; } | undefined;

    constructor(data?: IAbpUserNavConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["menus"]) {
                this.menus = {} as any;
                for (let key in data["menus"]) {
                    if (data["menus"].hasOwnProperty(key))
                        this.menus[key] = data["menus"][key] ? UserMenu.fromJS(data["menus"][key]) : new UserMenu();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserNavConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserNavConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.menus) {
            data["menus"] = {};
            for (let key in this.menus) {
                if (this.menus.hasOwnProperty(key))
                    data["menus"][key] = this.menus[key] ? this.menus[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): AbpUserNavConfigDto {
        const json = this.toJSON();
        let result = new AbpUserNavConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserNavConfigDto {
    menus: { [key: string] : UserMenu; } | undefined;
}

export class AbpUserSettingConfigDto implements IAbpUserSettingConfigDto {
    values: { [key: string] : string; } | undefined;

    constructor(data?: IAbpUserSettingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["values"]) {
                this.values = {} as any;
                for (let key in data["values"]) {
                    if (data["values"].hasOwnProperty(key))
                        this.values[key] = data["values"][key];
                }
            }
        }
    }

    static fromJS(data: any): AbpUserSettingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSettingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.values) {
            data["values"] = {};
            for (let key in this.values) {
                if (this.values.hasOwnProperty(key))
                    data["values"][key] = this.values[key];
            }
        }
        return data; 
    }

    clone(): AbpUserSettingConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSettingConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSettingConfigDto {
    values: { [key: string] : string; } | undefined;
}

export class AbpUserClockConfigDto implements IAbpUserClockConfigDto {
    provider: string | undefined;

    constructor(data?: IAbpUserClockConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): AbpUserClockConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserClockConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["provider"] = this.provider;
        return data; 
    }

    clone(): AbpUserClockConfigDto {
        const json = this.toJSON();
        let result = new AbpUserClockConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserClockConfigDto {
    provider: string | undefined;
}

export class AbpUserWindowsTimeZoneConfigDto implements IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number;
    currentUtcOffsetInMilliseconds: number;
    isDaylightSavingTimeNow: boolean;

    constructor(data?: IAbpUserWindowsTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
            this.baseUtcOffsetInMilliseconds = data["baseUtcOffsetInMilliseconds"];
            this.currentUtcOffsetInMilliseconds = data["currentUtcOffsetInMilliseconds"];
            this.isDaylightSavingTimeNow = data["isDaylightSavingTimeNow"];
        }
    }

    static fromJS(data: any): AbpUserWindowsTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        data["baseUtcOffsetInMilliseconds"] = this.baseUtcOffsetInMilliseconds;
        data["currentUtcOffsetInMilliseconds"] = this.currentUtcOffsetInMilliseconds;
        data["isDaylightSavingTimeNow"] = this.isDaylightSavingTimeNow;
        return data; 
    }

    clone(): AbpUserWindowsTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserWindowsTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserWindowsTimeZoneConfigDto {
    timeZoneId: string | undefined;
    baseUtcOffsetInMilliseconds: number;
    currentUtcOffsetInMilliseconds: number;
    isDaylightSavingTimeNow: boolean;
}

export class AbpUserIanaTimeZoneConfigDto implements IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;

    constructor(data?: IAbpUserIanaTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneId = data["timeZoneId"];
        }
    }

    static fromJS(data: any): AbpUserIanaTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneId"] = this.timeZoneId;
        return data; 
    }

    clone(): AbpUserIanaTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserIanaTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserIanaTimeZoneConfigDto {
    timeZoneId: string | undefined;
}

export class AbpUserTimeZoneConfigDto implements IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto;
    iana: AbpUserIanaTimeZoneConfigDto;

    constructor(data?: IAbpUserTimeZoneConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.windows = data["windows"] ? AbpUserWindowsTimeZoneConfigDto.fromJS(data["windows"]) : <any>undefined;
            this.iana = data["iana"] ? AbpUserIanaTimeZoneConfigDto.fromJS(data["iana"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimeZoneConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimeZoneConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["windows"] = this.windows ? this.windows.toJSON() : <any>undefined;
        data["iana"] = this.iana ? this.iana.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserTimeZoneConfigDto {
        const json = this.toJSON();
        let result = new AbpUserTimeZoneConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserTimeZoneConfigDto {
    windows: AbpUserWindowsTimeZoneConfigDto;
    iana: AbpUserIanaTimeZoneConfigDto;
}

export class AbpUserTimingConfigDto implements IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto;

    constructor(data?: IAbpUserTimingConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timeZoneInfo = data["timeZoneInfo"] ? AbpUserTimeZoneConfigDto.fromJS(data["timeZoneInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserTimingConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserTimingConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timeZoneInfo"] = this.timeZoneInfo ? this.timeZoneInfo.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserTimingConfigDto {
        const json = this.toJSON();
        let result = new AbpUserTimingConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserTimingConfigDto {
    timeZoneInfo: AbpUserTimeZoneConfigDto;
}

export class AbpUserAntiForgeryConfigDto implements IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;

    constructor(data?: IAbpUserAntiForgeryConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tokenCookieName = data["tokenCookieName"];
            this.tokenHeaderName = data["tokenHeaderName"];
        }
    }

    static fromJS(data: any): AbpUserAntiForgeryConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tokenCookieName"] = this.tokenCookieName;
        data["tokenHeaderName"] = this.tokenHeaderName;
        return data; 
    }

    clone(): AbpUserAntiForgeryConfigDto {
        const json = this.toJSON();
        let result = new AbpUserAntiForgeryConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserAntiForgeryConfigDto {
    tokenCookieName: string | undefined;
    tokenHeaderName: string | undefined;
}

export class AbpUserSecurityConfigDto implements IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto;

    constructor(data?: IAbpUserSecurityConfigDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.antiForgery = data["antiForgery"] ? AbpUserAntiForgeryConfigDto.fromJS(data["antiForgery"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AbpUserSecurityConfigDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserSecurityConfigDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["antiForgery"] = this.antiForgery ? this.antiForgery.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AbpUserSecurityConfigDto {
        const json = this.toJSON();
        let result = new AbpUserSecurityConfigDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserSecurityConfigDto {
    antiForgery: AbpUserAntiForgeryConfigDto;
}

export class AbpUserConfigurationDto implements IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto;
    session: AbpUserSessionConfigDto;
    localization: AbpUserLocalizationConfigDto;
    features: AbpUserFeatureConfigDto;
    auth: AbpUserAuthConfigDto;
    nav: AbpUserNavConfigDto;
    setting: AbpUserSettingConfigDto;
    clock: AbpUserClockConfigDto;
    timing: AbpUserTimingConfigDto;
    security: AbpUserSecurityConfigDto;
    custom: { [key: string] : Anonymous4; } | undefined;

    constructor(data?: IAbpUserConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.multiTenancy = data["multiTenancy"] ? AbpMultiTenancyConfigDto.fromJS(data["multiTenancy"]) : <any>undefined;
            this.session = data["session"] ? AbpUserSessionConfigDto.fromJS(data["session"]) : <any>undefined;
            this.localization = data["localization"] ? AbpUserLocalizationConfigDto.fromJS(data["localization"]) : <any>undefined;
            this.features = data["features"] ? AbpUserFeatureConfigDto.fromJS(data["features"]) : <any>undefined;
            this.auth = data["auth"] ? AbpUserAuthConfigDto.fromJS(data["auth"]) : <any>undefined;
            this.nav = data["nav"] ? AbpUserNavConfigDto.fromJS(data["nav"]) : <any>undefined;
            this.setting = data["setting"] ? AbpUserSettingConfigDto.fromJS(data["setting"]) : <any>undefined;
            this.clock = data["clock"] ? AbpUserClockConfigDto.fromJS(data["clock"]) : <any>undefined;
            this.timing = data["timing"] ? AbpUserTimingConfigDto.fromJS(data["timing"]) : <any>undefined;
            this.security = data["security"] ? AbpUserSecurityConfigDto.fromJS(data["security"]) : <any>undefined;
            if (data["custom"]) {
                this.custom = {} as any;
                for (let key in data["custom"]) {
                    if (data["custom"].hasOwnProperty(key))
                        this.custom[key] = data["custom"][key] ? Anonymous4.fromJS(data["custom"][key]) : new Anonymous4();
                }
            }
        }
    }

    static fromJS(data: any): AbpUserConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AbpUserConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multiTenancy"] = this.multiTenancy ? this.multiTenancy.toJSON() : <any>undefined;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["localization"] = this.localization ? this.localization.toJSON() : <any>undefined;
        data["features"] = this.features ? this.features.toJSON() : <any>undefined;
        data["auth"] = this.auth ? this.auth.toJSON() : <any>undefined;
        data["nav"] = this.nav ? this.nav.toJSON() : <any>undefined;
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        data["clock"] = this.clock ? this.clock.toJSON() : <any>undefined;
        data["timing"] = this.timing ? this.timing.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        if (this.custom) {
            data["custom"] = {};
            for (let key in this.custom) {
                if (this.custom.hasOwnProperty(key))
                    data["custom"][key] = this.custom[key] ? this.custom[key].toJSON() : <any>undefined;
            }
        }
        return data; 
    }

    clone(): AbpUserConfigurationDto {
        const json = this.toJSON();
        let result = new AbpUserConfigurationDto();
        result.init(json);
        return result;
    }
}

export interface IAbpUserConfigurationDto {
    multiTenancy: AbpMultiTenancyConfigDto;
    session: AbpUserSessionConfigDto;
    localization: AbpUserLocalizationConfigDto;
    features: AbpUserFeatureConfigDto;
    auth: AbpUserAuthConfigDto;
    nav: AbpUserNavConfigDto;
    setting: AbpUserSettingConfigDto;
    clock: AbpUserClockConfigDto;
    timing: AbpUserTimingConfigDto;
    security: AbpUserSecurityConfigDto;
    custom: { [key: string] : Anonymous4; } | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }

    clone(): UpdateUserSignInTokenOutput {
        const json = this.toJSON();
        let result = new UpdateUserSignInTokenOutput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Source */
export class SourceEditDto implements ISourceEditDto {
    /** Id */
    id: number | undefined;
    /** 销售源名称 */
    sourceName: string | undefined;
    /** 销售源编码 */
    sourceCode: string | undefined;
    /** 折扣 */
    discount: number;
    /** 退费折扣 */
    rDiscount: number;

    constructor(data?: ISourceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
        }
    }

    static fromJS(data: any): SourceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        return data; 
    }

    clone(): SourceEditDto {
        const json = this.toJSON();
        let result = new SourceEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Source */
export interface ISourceEditDto {
    /** Id */
    id: number | undefined;
    /** 销售源名称 */
    sourceName: string | undefined;
    /** 销售源编码 */
    sourceCode: string | undefined;
    /** 折扣 */
    discount: number;
    /** 退费折扣 */
    rDiscount: number;
}

export class CreateOrUpdateSourceInput implements ICreateOrUpdateSourceInput {
    source: SourceEditDto;

    constructor(data?: ICreateOrUpdateSourceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.source = new SourceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? SourceEditDto.fromJS(data["source"]) : new SourceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateSourceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateSourceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateSourceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateSourceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateSourceInput {
    source: SourceEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Source */
export class SourceListDto implements ISourceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 销售源名称 */
    sourceName: string | undefined;
    /** 销售源编码 */
    sourceCode: string | undefined;
    /** 折扣 */
    discount: number;
    /** 退费折扣 */
    rDiscount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ISourceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.sourceName = data["sourceName"];
            this.sourceCode = data["sourceCode"];
            this.discount = data["discount"];
            this.rDiscount = data["rDiscount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SourceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SourceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["sourceName"] = this.sourceName;
        data["sourceCode"] = this.sourceCode;
        data["discount"] = this.discount;
        data["rDiscount"] = this.rDiscount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): SourceListDto {
        const json = this.toJSON();
        let result = new SourceListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Source */
export interface ISourceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 销售源名称 */
    sourceName: string | undefined;
    /** 销售源编码 */
    sourceCode: string | undefined;
    /** 折扣 */
    discount: number;
    /** 退费折扣 */
    rDiscount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetSourceForEditOutput implements IGetSourceForEditOutput {
    source: SourceEditDto;

    constructor(data?: IGetSourceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? SourceEditDto.fromJS(data["source"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSourceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSourceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetSourceForEditOutput {
        const json = this.toJSON();
        let result = new GetSourceForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetSourceForEditOutput {
    source: SourceEditDto;
}

export class PagedResultDtoOfSourceListDto implements IPagedResultDtoOfSourceListDto {
    totalCount: number;
    items: SourceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSourceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SourceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSourceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSourceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfSourceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfSourceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfSourceListDto {
    totalCount: number;
    items: SourceListDto[] | undefined;
}

export class EntityDto implements IEntityDto {
    id: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDto {
        const json = this.toJSON();
        let result = new EntityDto();
        result.init(json);
        return result;
    }
}

export interface IEntityDto {
    id: number;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }

    clone(): CreateTenantInput {
        const json = this.toJSON();
        let result = new CreateTenantInput();
        result.init(json);
        return result;
    }
}

export interface ICreateTenantInput {
    tenancyName: string | undefined;
    name: string | undefined;
    adminEmailAddress: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string | undefined;
    name: string | undefined;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantEditDto {
        const json = this.toJSON();
        let result = new TenantEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantEditDto {
    tenancyName: string | undefined;
    name: string | undefined;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndUtc: moment.Moment | undefined;
    editionId: number | undefined;
    id: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndUtc = data["subscriptionEndUtc"] ? moment(data["subscriptionEndUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndUtc"] = this.subscriptionEndUtc ? this.subscriptionEndUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TenantListDto {
        const json = this.toJSON();
        let result = new TenantListDto();
        result.init(json);
        return result;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: moment.Moment;
    subscriptionEndUtc: moment.Moment | undefined;
    editionId: number | undefined;
    id: number;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTenantListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTenantListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTenantFeaturesEditOutput {
        const json = this.toJSON();
        let result = new GetTenantFeaturesEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }

    clone(): UpdateTenantFeaturesInput {
        const json = this.toJSON();
        let result = new UpdateTenantFeaturesInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[] | undefined;
}

/** 创建租户的DTO信息 */
export class CreateTenantDto implements ICreateTenantDto {
    /** 全局唯一的租户Id */
    tenancyName: string | undefined;
    /** 租户名称 */
    name: string | undefined;
    userName: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    /** 验证码 */
    verificationCode: string | undefined;
    /** 租户管理员密码 */
    tenantAdminPassword: string | undefined;

    constructor(data?: ICreateTenantDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.verificationCode = data["verificationCode"];
            this.tenantAdminPassword = data["tenantAdminPassword"];
        }
    }

    static fromJS(data: any): CreateTenantDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["verificationCode"] = this.verificationCode;
        data["tenantAdminPassword"] = this.tenantAdminPassword;
        return data; 
    }

    clone(): CreateTenantDto {
        const json = this.toJSON();
        let result = new CreateTenantDto();
        result.init(json);
        return result;
    }
}

/** 创建租户的DTO信息 */
export interface ICreateTenantDto {
    /** 全局唯一的租户Id */
    tenancyName: string | undefined;
    /** 租户名称 */
    name: string | undefined;
    userName: string | undefined;
    adminEmailAddress: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    /** 验证码 */
    verificationCode: string | undefined;
    /** 租户管理员密码 */
    tenantAdminPassword: string | undefined;
}

export class RegisterTenantResultDto implements IRegisterTenantResultDto {
    /** 租户Id */
    tenantId: number;
    /** 租户是否激活 */
    isActive: boolean;
    /** 租户启用了用户登陆验证码 */
    useCaptchaOnUserLogin: boolean;

    constructor(data?: IRegisterTenantResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.isActive = data["isActive"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
        }
    }

    static fromJS(data: any): RegisterTenantResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["isActive"] = this.isActive;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        return data; 
    }

    clone(): RegisterTenantResultDto {
        const json = this.toJSON();
        let result = new RegisterTenantResultDto();
        result.init(json);
        return result;
    }
}

export interface IRegisterTenantResultDto {
    /** 租户Id */
    tenantId: number;
    /** 租户是否激活 */
    isActive: boolean;
    /** 租户启用了用户登陆验证码 */
    useCaptchaOnUserLogin: boolean;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    /** 是否启用注册 */
    allowSelfRegistration: boolean;
    /** 是否新注册用户默认激活 */
    isNewRegisteredUserActiveByDefault: boolean;
    /** 是否必须校验邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean;
    /** 是否注册使用验证码 */
    useCaptchaOnUserRegistration: boolean;
    captchaOnUserRegistrationType: ValidateCodeType;
    /** 注册验证码长度 */
    captchaOnUserRegistrationLength: number;
    /** 是否登陆使用验证码 */
    useCaptchaOnUserLogin: boolean;
    captchaOnUserLoginType: ValidateCodeType;
    /** 登陆验证码长度 */
    captchaOnUserLoginLength: number;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnUserRegistration = data["useCaptchaOnUserRegistration"];
            this.captchaOnUserRegistrationType = data["captchaOnUserRegistrationType"];
            this.captchaOnUserRegistrationLength = data["captchaOnUserRegistrationLength"];
            this.useCaptchaOnUserLogin = data["useCaptchaOnUserLogin"];
            this.captchaOnUserLoginType = data["captchaOnUserLoginType"];
            this.captchaOnUserLoginLength = data["captchaOnUserLoginLength"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnUserRegistration"] = this.useCaptchaOnUserRegistration;
        data["captchaOnUserRegistrationType"] = this.captchaOnUserRegistrationType;
        data["captchaOnUserRegistrationLength"] = this.captchaOnUserRegistrationLength;
        data["useCaptchaOnUserLogin"] = this.useCaptchaOnUserLogin;
        data["captchaOnUserLoginType"] = this.captchaOnUserLoginType;
        data["captchaOnUserLoginLength"] = this.captchaOnUserLoginLength;
        return data; 
    }

    clone(): TenantUserManagementSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantUserManagementSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    /** 是否启用注册 */
    allowSelfRegistration: boolean;
    /** 是否新注册用户默认激活 */
    isNewRegisteredUserActiveByDefault: boolean;
    /** 是否必须校验邮箱才能登陆 */
    isEmailConfirmationRequiredForLogin: boolean;
    /** 是否注册使用验证码 */
    useCaptchaOnUserRegistration: boolean;
    captchaOnUserRegistrationType: ValidateCodeType;
    /** 注册验证码长度 */
    captchaOnUserRegistrationLength: number;
    /** 是否登陆使用验证码 */
    useCaptchaOnUserLogin: boolean;
    captchaOnUserLoginType: ValidateCodeType;
    /** 登陆验证码长度 */
    captchaOnUserLoginLength: number;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    /** 模块启用 */
    isModuleEnabled: boolean;
    /** 启用 */
    isEnabled: boolean;
    domain: string | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 密码 */
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }

    clone(): LdapSettingsEditDto {
        const json = this.toJSON();
        let result = new LdapSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ILdapSettingsEditDto {
    /** 模块启用 */
    isModuleEnabled: boolean;
    /** 启用 */
    isEnabled: boolean;
    domain: string | undefined;
    /** 用户名 */
    userName: string | undefined;
    /** 密码 */
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }

    clone(): TenantBillingSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantBillingSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TenantSettingsEditDto {
        const json = this.toJSON();
        let result = new TenantSettingsEditDto();
        result.init(json);
        return result;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
}

/** 的列表DTO Yozeev.BusinessLogic.Ticket */
export class TicketEditDto implements ITicketEditDto {
    /** Id */
    id: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;

    constructor(data?: ITicketEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): TicketEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["group"] = this.group;
        return data; 
    }

    clone(): TicketEditDto {
        const json = this.toJSON();
        let result = new TicketEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Ticket */
export interface ITicketEditDto {
    /** Id */
    id: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
}

export class CreateOrUpdateTicketInput implements ICreateOrUpdateTicketInput {
    ticket: TicketEditDto;

    constructor(data?: ICreateOrUpdateTicketInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticket = new TicketEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? TicketEditDto.fromJS(data["ticket"]) : new TicketEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketInput {
    ticket: TicketEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Ticket */
export class TicketListDto implements ITicketListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketName = data["ticketName"];
            this.ticketCode = data["ticketCode"];
            this.ticketMode = data["ticketMode"];
            this.ticketType = data["ticketType"];
            this.checkMethod = data["checkMethod"];
            this.ticketClassify = data["ticketClassify"];
            this.checkNum = data["checkNum"];
            this.effectiveLong = data["effectiveLong"];
            this.unitPrice = data["unitPrice"];
            this.ticketLength = data["ticketLength"];
            this.upperLimit = data["upperLimit"];
            this.lowerLimit = data["lowerLimit"];
            this.audioName = data["audioName"];
            this.auditStatus = data["auditStatus"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.group = data["group"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketName"] = this.ticketName;
        data["ticketCode"] = this.ticketCode;
        data["ticketMode"] = this.ticketMode;
        data["ticketType"] = this.ticketType;
        data["checkMethod"] = this.checkMethod;
        data["ticketClassify"] = this.ticketClassify;
        data["checkNum"] = this.checkNum;
        data["effectiveLong"] = this.effectiveLong;
        data["unitPrice"] = this.unitPrice;
        data["ticketLength"] = this.ticketLength;
        data["upperLimit"] = this.upperLimit;
        data["lowerLimit"] = this.lowerLimit;
        data["audioName"] = this.audioName;
        data["auditStatus"] = this.auditStatus;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["group"] = this.group;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketListDto {
        const json = this.toJSON();
        let result = new TicketListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Ticket */
export interface ITicketListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** TicketCode */
    ticketCode: string | undefined;
    ticketMode: TicketModeEnum;
    ticketType: TicketTypeEnum;
    checkMethod: CheckMethodEnum;
    ticketClassify: TicketClassifyEnum;
    /** CheckNum */
    checkNum: number | undefined;
    /** EffectiveLong */
    effectiveLong: number | undefined;
    /** UnitPrice */
    unitPrice: number;
    /** TicketLength */
    ticketLength: number | undefined;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** LowerLimit */
    lowerLimit: number | undefined;
    /** AudioName */
    audioName: string | undefined;
    auditStatus: AuditStatusEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketForEditOutput implements IGetTicketForEditOutput {
    ticket: TicketEditDto;
    ticketModeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketClassifyEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetTicketForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticket = data["ticket"] ? TicketEditDto.fromJS(data["ticket"]) : <any>undefined;
            if (data["ticketModeEnumTypeEnum"] && data["ticketModeEnumTypeEnum"].constructor === Array) {
                this.ticketModeEnumTypeEnum = [] as any;
                for (let item of data["ticketModeEnumTypeEnum"])
                    this.ticketModeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["ticketTypeEnumTypeEnum"] && data["ticketTypeEnumTypeEnum"].constructor === Array) {
                this.ticketTypeEnumTypeEnum = [] as any;
                for (let item of data["ticketTypeEnumTypeEnum"])
                    this.ticketTypeEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["checkMethodEnumTypeEnum"] && data["checkMethodEnumTypeEnum"].constructor === Array) {
                this.checkMethodEnumTypeEnum = [] as any;
                for (let item of data["checkMethodEnumTypeEnum"])
                    this.checkMethodEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["ticketClassifyEnumTypeEnum"] && data["ticketClassifyEnumTypeEnum"].constructor === Array) {
                this.ticketClassifyEnumTypeEnum = [] as any;
                for (let item of data["ticketClassifyEnumTypeEnum"])
                    this.ticketClassifyEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["auditStatusEnumTypeEnum"] && data["auditStatusEnumTypeEnum"].constructor === Array) {
                this.auditStatusEnumTypeEnum = [] as any;
                for (let item of data["auditStatusEnumTypeEnum"])
                    this.auditStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        if (this.ticketModeEnumTypeEnum && this.ticketModeEnumTypeEnum.constructor === Array) {
            data["ticketModeEnumTypeEnum"] = [];
            for (let item of this.ticketModeEnumTypeEnum)
                data["ticketModeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.ticketTypeEnumTypeEnum && this.ticketTypeEnumTypeEnum.constructor === Array) {
            data["ticketTypeEnumTypeEnum"] = [];
            for (let item of this.ticketTypeEnumTypeEnum)
                data["ticketTypeEnumTypeEnum"].push(item.toJSON());
        }
        if (this.checkMethodEnumTypeEnum && this.checkMethodEnumTypeEnum.constructor === Array) {
            data["checkMethodEnumTypeEnum"] = [];
            for (let item of this.checkMethodEnumTypeEnum)
                data["checkMethodEnumTypeEnum"].push(item.toJSON());
        }
        if (this.ticketClassifyEnumTypeEnum && this.ticketClassifyEnumTypeEnum.constructor === Array) {
            data["ticketClassifyEnumTypeEnum"] = [];
            for (let item of this.ticketClassifyEnumTypeEnum)
                data["ticketClassifyEnumTypeEnum"].push(item.toJSON());
        }
        if (this.auditStatusEnumTypeEnum && this.auditStatusEnumTypeEnum.constructor === Array) {
            data["auditStatusEnumTypeEnum"] = [];
            for (let item of this.auditStatusEnumTypeEnum)
                data["auditStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTicketForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketForEditOutput {
    ticket: TicketEditDto;
    ticketModeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketTypeEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketClassifyEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    auditStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfTicketListDto implements IPagedResultDtoOfTicketListDto {
    totalCount: number;
    items: TicketListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketListDto {
    totalCount: number;
    items: TicketListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Account */
export class AccountEditDto implements IAccountEditDto {
    /** Id */
    id: number | undefined;
    /** AccountNo */
    accountNo: string | undefined;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    accountStatus: AccountStatusEnum;
    /** CollectiorId */
    collectiorId: number | undefined;
    collectior: User;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** PayMethodId */
    payMethodId: number | undefined;
    payMethod: PayMethod;
    /** Remark */
    remark: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** RAmount */
    rAmount: number;
    /** TotalAmount */
    totalAmount: number;
    /** RQuantity */
    rQuantity: number;
    /** TotalQuantity */
    totalQuantity: number;

    constructor(data?: IAccountEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectior = data["collectior"] ? User.fromJS(data["collectior"]) : <any>undefined;
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
        }
    }

    static fromJS(data: any): AccountEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectior"] = this.collectior ? this.collectior.toJSON() : <any>undefined;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        return data; 
    }

    clone(): AccountEditDto {
        const json = this.toJSON();
        let result = new AccountEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Account */
export interface IAccountEditDto {
    /** Id */
    id: number | undefined;
    /** AccountNo */
    accountNo: string | undefined;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    accountStatus: AccountStatusEnum;
    /** CollectiorId */
    collectiorId: number | undefined;
    collectior: User;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** PayMethodId */
    payMethodId: number | undefined;
    payMethod: PayMethod;
    /** Remark */
    remark: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** RAmount */
    rAmount: number;
    /** TotalAmount */
    totalAmount: number;
    /** RQuantity */
    rQuantity: number;
    /** TotalQuantity */
    totalQuantity: number;
}

export class CreateOrUpdateAccountInput implements ICreateOrUpdateAccountInput {
    account: AccountEditDto;

    constructor(data?: ICreateOrUpdateAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.account = new AccountEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountEditDto.fromJS(data["account"]) : new AccountEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateAccountInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateAccountInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateAccountInput {
    account: AccountEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Account */
export class AccountListDto implements IAccountListDto {
    /** BranchId */
    branchId: number | undefined;
    /** AccountNo */
    accountNo: string | undefined;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    accountStatus: AccountStatusEnum;
    /** CollectiorId */
    collectiorId: number | undefined;
    collectior: User;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** PayMethodId */
    payMethodId: number | undefined;
    payMethod: PayMethod;
    /** Remark */
    remark: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** RAmount */
    rAmount: number;
    /** TotalAmount */
    totalAmount: number;
    /** RQuantity */
    rQuantity: number;
    /** TotalQuantity */
    totalQuantity: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.accountNo = data["accountNo"];
            this.accountDate = data["accountDate"] ? moment(data["accountDate"].toString()) : <any>undefined;
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.accountStatus = data["accountStatus"];
            this.collectiorId = data["collectiorId"];
            this.collectior = data["collectior"] ? User.fromJS(data["collectior"]) : <any>undefined;
            this.collectionTime = data["collectionTime"] ? moment(data["collectionTime"].toString()) : <any>undefined;
            this.payMethodId = data["payMethodId"];
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.remark = data["remark"];
            this.voucherNo = data["voucherNo"];
            this.rAmount = data["rAmount"];
            this.totalAmount = data["totalAmount"];
            this.rQuantity = data["rQuantity"];
            this.totalQuantity = data["totalQuantity"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["accountNo"] = this.accountNo;
        data["accountDate"] = this.accountDate ? this.accountDate.toISOString() : <any>undefined;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["accountStatus"] = this.accountStatus;
        data["collectiorId"] = this.collectiorId;
        data["collectior"] = this.collectior ? this.collectior.toJSON() : <any>undefined;
        data["collectionTime"] = this.collectionTime ? this.collectionTime.toISOString() : <any>undefined;
        data["payMethodId"] = this.payMethodId;
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["voucherNo"] = this.voucherNo;
        data["rAmount"] = this.rAmount;
        data["totalAmount"] = this.totalAmount;
        data["rQuantity"] = this.rQuantity;
        data["totalQuantity"] = this.totalQuantity;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): AccountListDto {
        const json = this.toJSON();
        let result = new AccountListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Account */
export interface IAccountListDto {
    /** BranchId */
    branchId: number | undefined;
    /** AccountNo */
    accountNo: string | undefined;
    /** AccountDate */
    accountDate: moment.Moment;
    /** Quantity */
    quantity: number;
    /** Amount */
    amount: number;
    accountStatus: AccountStatusEnum;
    /** CollectiorId */
    collectiorId: number | undefined;
    collectior: User;
    /** CollectionTime */
    collectionTime: moment.Moment | undefined;
    /** PayMethodId */
    payMethodId: number | undefined;
    payMethod: PayMethod;
    /** Remark */
    remark: string | undefined;
    /** VoucherNo */
    voucherNo: string | undefined;
    /** RAmount */
    rAmount: number;
    /** TotalAmount */
    totalAmount: number;
    /** RQuantity */
    rQuantity: number;
    /** TotalQuantity */
    totalQuantity: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetAccountForEditOutput implements IGetAccountForEditOutput {
    account: AccountEditDto;
    accountStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetAccountForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.account = data["account"] ? AccountEditDto.fromJS(data["account"]) : <any>undefined;
            if (data["accountStatusEnumTypeEnum"] && data["accountStatusEnumTypeEnum"].constructor === Array) {
                this.accountStatusEnumTypeEnum = [] as any;
                for (let item of data["accountStatusEnumTypeEnum"])
                    this.accountStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAccountForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAccountForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["account"] = this.account ? this.account.toJSON() : <any>undefined;
        if (this.accountStatusEnumTypeEnum && this.accountStatusEnumTypeEnum.constructor === Array) {
            data["accountStatusEnumTypeEnum"] = [];
            for (let item of this.accountStatusEnumTypeEnum)
                data["accountStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetAccountForEditOutput {
        const json = this.toJSON();
        let result = new GetAccountForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetAccountForEditOutput {
    account: AccountEditDto;
    accountStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfAccountListDto implements IPagedResultDtoOfAccountListDto {
    totalCount: number;
    items: AccountListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAccountListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(AccountListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAccountListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAccountListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfAccountListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfAccountListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfAccountListDto {
    totalCount: number;
    items: AccountListDto[] | undefined;
}

export enum TicketStatusEnum {
    Activate = <any>"Activate", 
    Used = <any>"Used", 
    TicketRefund = <any>"TicketRefund", 
}

/** 的列表DTO Yozeev.BusinessLogic.TicketDetail */
export class TicketDetailEditDto implements ITicketDetailEditDto {
    /** Id */
    id: number | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    /** ActivityId */
    activityId: number;
    /** OrgActivityDetailId */
    orgActivityDetailId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    /** TicketId */
    ticketId: number;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number;
    /** CheckedQuantity */
    checkedQuantity: number;
    /** StartDateTime */
    startDateTime: moment.Moment;
    /** EndDateTime */
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;

    constructor(data?: ITicketDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
            this.group = data["group"];
        }
    }

    static fromJS(data: any): TicketDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        data["group"] = this.group;
        return data; 
    }

    clone(): TicketDetailEditDto {
        const json = this.toJSON();
        let result = new TicketDetailEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketDetail */
export interface ITicketDetailEditDto {
    /** Id */
    id: number | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    /** ActivityId */
    activityId: number;
    /** OrgActivityDetailId */
    orgActivityDetailId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    /** TicketId */
    ticketId: number;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number;
    /** CheckedQuantity */
    checkedQuantity: number;
    /** StartDateTime */
    startDateTime: moment.Moment;
    /** EndDateTime */
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
}

export class CreateOrUpdateTicketDetailInput implements ICreateOrUpdateTicketDetailInput {
    ticketDetail: TicketDetailEditDto;

    constructor(data?: ICreateOrUpdateTicketDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketDetail = new TicketDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetail = data["ticketDetail"] ? TicketDetailEditDto.fromJS(data["ticketDetail"]) : new TicketDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketDetailInput {
    ticketDetail: TicketDetailEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketDetail */
export class TicketDetailListDto implements ITicketDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    /** ActivityId */
    activityId: number;
    /** OrgActivityDetailId */
    orgActivityDetailId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    /** TicketId */
    ticketId: number;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number;
    /** CheckedQuantity */
    checkedQuantity: number;
    /** StartDateTime */
    startDateTime: moment.Moment;
    /** EndDateTime */
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
            this.group = data["group"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        data["group"] = this.group;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetailListDto {
        const json = this.toJSON();
        let result = new TicketDetailListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketDetail */
export interface ITicketDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketNo */
    ticketNo: string | undefined;
    /** ActivityDetailId */
    activityDetailId: number;
    activityDetail: ActivityDetail;
    /** ActivityId */
    activityId: number;
    /** OrgActivityDetailId */
    orgActivityDetailId: number | undefined;
    /** OrgActivityId */
    orgActivityId: number | undefined;
    /** CustomerId */
    customerId: number;
    customer: Customer;
    /** TicketId */
    ticketId: number;
    /** QRCode */
    qrCode: string | undefined;
    /** CheckingQuantity */
    checkingQuantity: number;
    /** CheckedQuantity */
    checkedQuantity: number;
    /** StartDateTime */
    startDateTime: moment.Moment;
    /** EndDateTime */
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    /** CheckTime */
    checkTime: moment.Moment | undefined;
    /** IsPrint */
    isPrint: boolean;
    /** 0.散客票
1.团体票
2.卡类 */
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketDetailForEditOutput implements IGetTicketDetailForEditOutput {
    ticketDetail: TicketDetailEditDto;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetTicketDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetail = data["ticketDetail"] ? TicketDetailEditDto.fromJS(data["ticketDetail"]) : <any>undefined;
            if (data["checkMethodEnumTypeEnum"] && data["checkMethodEnumTypeEnum"].constructor === Array) {
                this.checkMethodEnumTypeEnum = [] as any;
                for (let item of data["checkMethodEnumTypeEnum"])
                    this.checkMethodEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
            if (data["ticketStatusEnumTypeEnum"] && data["ticketStatusEnumTypeEnum"].constructor === Array) {
                this.ticketStatusEnumTypeEnum = [] as any;
                for (let item of data["ticketStatusEnumTypeEnum"])
                    this.ticketStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        if (this.checkMethodEnumTypeEnum && this.checkMethodEnumTypeEnum.constructor === Array) {
            data["checkMethodEnumTypeEnum"] = [];
            for (let item of this.checkMethodEnumTypeEnum)
                data["checkMethodEnumTypeEnum"].push(item.toJSON());
        }
        if (this.ticketStatusEnumTypeEnum && this.ticketStatusEnumTypeEnum.constructor === Array) {
            data["ticketStatusEnumTypeEnum"] = [];
            for (let item of this.ticketStatusEnumTypeEnum)
                data["ticketStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTicketDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketDetailForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketDetailForEditOutput {
    ticketDetail: TicketDetailEditDto;
    checkMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
    ticketStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetTicketDetailsInput implements IGetTicketDetailsInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetTicketDetailsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketDetailsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketDetailsInput {
        const json = this.toJSON();
        let result = new GetTicketDetailsInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetTicketDetailsInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfTicketDetailListDto implements IPagedResultDtoOfTicketDetailListDto {
    totalCount: number;
    items: TicketDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketDetailListDto {
    totalCount: number;
    items: TicketDetailListDto[] | undefined;
}

export class TicketDetail implements ITicketDetail {
    branchId: number | undefined;
    ticketNo: string | undefined;
    activityDetailId: number;
    activityDetail: ActivityDetail;
    activityId: number;
    activity: Activity;
    orgActivityDetailId: number | undefined;
    orgActivityId: number | undefined;
    customerId: number | undefined;
    customer: Customer;
    ticketId: number;
    ticket: Ticket;
    qrCode: string | undefined;
    checkingQuantity: number;
    checkedQuantity: number;
    startDateTime: moment.Moment;
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    checkTime: moment.Moment | undefined;
    isPrint: boolean;
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketNo = data["ticketNo"];
            this.activityDetailId = data["activityDetailId"];
            this.activityDetail = data["activityDetail"] ? ActivityDetail.fromJS(data["activityDetail"]) : <any>undefined;
            this.activityId = data["activityId"];
            this.activity = data["activity"] ? Activity.fromJS(data["activity"]) : <any>undefined;
            this.orgActivityDetailId = data["orgActivityDetailId"];
            this.orgActivityId = data["orgActivityId"];
            this.customerId = data["customerId"];
            this.customer = data["customer"] ? Customer.fromJS(data["customer"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.qrCode = data["qrCode"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkMethod = data["checkMethod"];
            this.ticketStatus = data["ticketStatus"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.isPrint = data["isPrint"];
            this.group = data["group"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetail {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketNo"] = this.ticketNo;
        data["activityDetailId"] = this.activityDetailId;
        data["activityDetail"] = this.activityDetail ? this.activityDetail.toJSON() : <any>undefined;
        data["activityId"] = this.activityId;
        data["activity"] = this.activity ? this.activity.toJSON() : <any>undefined;
        data["orgActivityDetailId"] = this.orgActivityDetailId;
        data["orgActivityId"] = this.orgActivityId;
        data["customerId"] = this.customerId;
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["qrCode"] = this.qrCode;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkMethod"] = this.checkMethod;
        data["ticketStatus"] = this.ticketStatus;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["isPrint"] = this.isPrint;
        data["group"] = this.group;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetail {
        const json = this.toJSON();
        let result = new TicketDetail();
        result.init(json);
        return result;
    }
}

export interface ITicketDetail {
    branchId: number | undefined;
    ticketNo: string | undefined;
    activityDetailId: number;
    activityDetail: ActivityDetail;
    activityId: number;
    activity: Activity;
    orgActivityDetailId: number | undefined;
    orgActivityId: number | undefined;
    customerId: number | undefined;
    customer: Customer;
    ticketId: number;
    ticket: Ticket;
    qrCode: string | undefined;
    checkingQuantity: number;
    checkedQuantity: number;
    startDateTime: moment.Moment;
    endDateTime: moment.Moment;
    checkMethod: CheckMethodEnum;
    ticketStatus: TicketStatusEnum;
    checkTime: moment.Moment | undefined;
    isPrint: boolean;
    group: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export enum CheckStatusEnum {
    CheckSuccess = <any>"CheckSuccess", 
    CheckFalse = <any>"CheckFalse", 
}

/** 的列表DTO Yozeev.BusinessLogic.TicketDetailHistory */
export class TicketDetailHistoryEditDto implements ITicketDetailHistoryEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: number;
    ticketDetail: TicketDetail;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: number;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    statusCode: CheckStatusEnum;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment;
    /** Year */
    year: number;
    /** Month */
    month: number;
    /** Day */
    day: number;
    /** Hour */
    hour: number;
    /** Minute */
    minute: number;
    /** YearWeek */
    yearWeek: number;
    /** WeekDay */
    weekDay: number;
    /** CheckTime */
    checkTime: moment.Moment;
    /** CheckerId */
    checkerId: number | undefined;
    checker: User;
    /** CheckCount */
    checkCount: number;

    constructor(data?: ITicketDetailHistoryEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.deviceName = data["deviceName"];
            this.ticketDetailId = data["ticketDetailId"];
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.ticketNo = data["ticketNo"];
            this.customerId = data["customerId"];
            this.visitValue = data["visitValue"];
            this.validationType = data["validationType"];
            this.ticketName = data["ticketName"];
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
            this.year = data["year"];
            this.month = data["month"];
            this.day = data["day"];
            this.hour = data["hour"];
            this.minute = data["minute"];
            this.yearWeek = data["yearWeek"];
            this.weekDay = data["weekDay"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.checkerId = data["checkerId"];
            this.checker = data["checker"] ? User.fromJS(data["checker"]) : <any>undefined;
            this.checkCount = data["checkCount"];
        }
    }

    static fromJS(data: any): TicketDetailHistoryEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailHistoryEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["deviceName"] = this.deviceName;
        data["ticketDetailId"] = this.ticketDetailId;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["ticketNo"] = this.ticketNo;
        data["customerId"] = this.customerId;
        data["visitValue"] = this.visitValue;
        data["validationType"] = this.validationType;
        data["ticketName"] = this.ticketName;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["yearWeek"] = this.yearWeek;
        data["weekDay"] = this.weekDay;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["checkerId"] = this.checkerId;
        data["checker"] = this.checker ? this.checker.toJSON() : <any>undefined;
        data["checkCount"] = this.checkCount;
        return data; 
    }

    clone(): TicketDetailHistoryEditDto {
        const json = this.toJSON();
        let result = new TicketDetailHistoryEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketDetailHistory */
export interface ITicketDetailHistoryEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: number;
    ticketDetail: TicketDetail;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: number;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    statusCode: CheckStatusEnum;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment;
    /** Year */
    year: number;
    /** Month */
    month: number;
    /** Day */
    day: number;
    /** Hour */
    hour: number;
    /** Minute */
    minute: number;
    /** YearWeek */
    yearWeek: number;
    /** WeekDay */
    weekDay: number;
    /** CheckTime */
    checkTime: moment.Moment;
    /** CheckerId */
    checkerId: number | undefined;
    checker: User;
    /** CheckCount */
    checkCount: number;
}

export class CreateOrUpdateTicketDetailHistoryInput implements ICreateOrUpdateTicketDetailHistoryInput {
    ticketDetailHistory: TicketDetailHistoryEditDto;

    constructor(data?: ICreateOrUpdateTicketDetailHistoryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketDetailHistory = new TicketDetailHistoryEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetailHistory = data["ticketDetailHistory"] ? TicketDetailHistoryEditDto.fromJS(data["ticketDetailHistory"]) : new TicketDetailHistoryEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketDetailHistoryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketDetailHistoryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetailHistory"] = this.ticketDetailHistory ? this.ticketDetailHistory.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketDetailHistoryInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketDetailHistoryInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketDetailHistoryInput {
    ticketDetailHistory: TicketDetailHistoryEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketDetailHistory */
export class TicketDetailHistoryListDto implements ITicketDetailHistoryListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: number;
    ticketDetail: TicketDetail;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: number;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    statusCode: CheckStatusEnum;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment;
    /** Year */
    year: number;
    /** Month */
    month: number;
    /** Day */
    day: number;
    /** Hour */
    hour: number;
    /** Minute */
    minute: number;
    /** YearWeek */
    yearWeek: number;
    /** WeekDay */
    weekDay: number;
    /** CheckTime */
    checkTime: moment.Moment;
    /** CheckerId */
    checkerId: number | undefined;
    checker: User;
    /** CheckCount */
    checkCount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketDetailHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.deviceName = data["deviceName"];
            this.ticketDetailId = data["ticketDetailId"];
            this.ticketDetail = data["ticketDetail"] ? TicketDetail.fromJS(data["ticketDetail"]) : <any>undefined;
            this.ticketNo = data["ticketNo"];
            this.customerId = data["customerId"];
            this.visitValue = data["visitValue"];
            this.validationType = data["validationType"];
            this.ticketName = data["ticketName"];
            this.statusCode = data["statusCode"];
            this.statusText = data["statusText"];
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
            this.year = data["year"];
            this.month = data["month"];
            this.day = data["day"];
            this.hour = data["hour"];
            this.minute = data["minute"];
            this.yearWeek = data["yearWeek"];
            this.weekDay = data["weekDay"];
            this.checkTime = data["checkTime"] ? moment(data["checkTime"].toString()) : <any>undefined;
            this.checkerId = data["checkerId"];
            this.checker = data["checker"] ? User.fromJS(data["checker"]) : <any>undefined;
            this.checkCount = data["checkCount"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketDetailHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketDetailHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["deviceName"] = this.deviceName;
        data["ticketDetailId"] = this.ticketDetailId;
        data["ticketDetail"] = this.ticketDetail ? this.ticketDetail.toJSON() : <any>undefined;
        data["ticketNo"] = this.ticketNo;
        data["customerId"] = this.customerId;
        data["visitValue"] = this.visitValue;
        data["validationType"] = this.validationType;
        data["ticketName"] = this.ticketName;
        data["statusCode"] = this.statusCode;
        data["statusText"] = this.statusText;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        data["year"] = this.year;
        data["month"] = this.month;
        data["day"] = this.day;
        data["hour"] = this.hour;
        data["minute"] = this.minute;
        data["yearWeek"] = this.yearWeek;
        data["weekDay"] = this.weekDay;
        data["checkTime"] = this.checkTime ? this.checkTime.toISOString() : <any>undefined;
        data["checkerId"] = this.checkerId;
        data["checker"] = this.checker ? this.checker.toJSON() : <any>undefined;
        data["checkCount"] = this.checkCount;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketDetailHistoryListDto {
        const json = this.toJSON();
        let result = new TicketDetailHistoryListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketDetailHistory */
export interface ITicketDetailHistoryListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    /** DeviceId */
    deviceId: number;
    device: Device;
    /** DeviceName */
    deviceName: string | undefined;
    /** TicketDetailId */
    ticketDetailId: number;
    ticketDetail: TicketDetail;
    /** TicketNo */
    ticketNo: string | undefined;
    /** CustomerId */
    customerId: number;
    /** VisitValue */
    visitValue: string | undefined;
    /** ValidationType */
    validationType: string | undefined;
    /** TicketName */
    ticketName: string | undefined;
    statusCode: CheckStatusEnum;
    /** StatusText */
    statusText: string | undefined;
    /** CheckDate */
    checkDate: moment.Moment;
    /** Year */
    year: number;
    /** Month */
    month: number;
    /** Day */
    day: number;
    /** Hour */
    hour: number;
    /** Minute */
    minute: number;
    /** YearWeek */
    yearWeek: number;
    /** WeekDay */
    weekDay: number;
    /** CheckTime */
    checkTime: moment.Moment;
    /** CheckerId */
    checkerId: number | undefined;
    checker: User;
    /** CheckCount */
    checkCount: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketDetailHistoryForEditOutput implements IGetTicketDetailHistoryForEditOutput {
    ticketDetailHistory: TicketDetailHistoryEditDto;
    checkStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetTicketDetailHistoryForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketDetailHistory = data["ticketDetailHistory"] ? TicketDetailHistoryEditDto.fromJS(data["ticketDetailHistory"]) : <any>undefined;
            if (data["checkStatusEnumTypeEnum"] && data["checkStatusEnumTypeEnum"].constructor === Array) {
                this.checkStatusEnumTypeEnum = [] as any;
                for (let item of data["checkStatusEnumTypeEnum"])
                    this.checkStatusEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketDetailHistoryForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailHistoryForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketDetailHistory"] = this.ticketDetailHistory ? this.ticketDetailHistory.toJSON() : <any>undefined;
        if (this.checkStatusEnumTypeEnum && this.checkStatusEnumTypeEnum.constructor === Array) {
            data["checkStatusEnumTypeEnum"] = [];
            for (let item of this.checkStatusEnumTypeEnum)
                data["checkStatusEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTicketDetailHistoryForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketDetailHistoryForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketDetailHistoryForEditOutput {
    ticketDetailHistory: TicketDetailHistoryEditDto;
    checkStatusEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetTicketDetailHistorysInput implements IGetTicketDetailHistorysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetTicketDetailHistorysInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketDetailHistorysInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketDetailHistorysInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketDetailHistorysInput {
        const json = this.toJSON();
        let result = new GetTicketDetailHistorysInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetTicketDetailHistorysInput {
    /** DeviceCode,DeviceName,Port */
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfTicketDetailHistoryListDto implements IPagedResultDtoOfTicketDetailHistoryListDto {
    totalCount: number;
    items: TicketDetailHistoryListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketDetailHistoryListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketDetailHistoryListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketDetailHistoryListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketDetailHistoryListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketDetailHistoryListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketDetailHistoryListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketDetailHistoryListDto {
    totalCount: number;
    items: TicketDetailHistoryListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketIntroduce */
export class TicketIntroduceEditDto implements ITicketIntroduceEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean;

    constructor(data?: ITicketIntroduceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.tradeName = data["tradeName"];
            this.tradeInfo = data["tradeInfo"];
            this.address = data["address"];
            this.coverMap = data["coverMap"];
            this.abstract = data["abstract"];
            this.notice = data["notice"];
            this.refundRule = data["refundRule"];
            this.isOnLine = data["isOnLine"];
        }
    }

    static fromJS(data: any): TicketIntroduceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketIntroduceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["tradeName"] = this.tradeName;
        data["tradeInfo"] = this.tradeInfo;
        data["address"] = this.address;
        data["coverMap"] = this.coverMap;
        data["abstract"] = this.abstract;
        data["notice"] = this.notice;
        data["refundRule"] = this.refundRule;
        data["isOnLine"] = this.isOnLine;
        return data; 
    }

    clone(): TicketIntroduceEditDto {
        const json = this.toJSON();
        let result = new TicketIntroduceEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketIntroduce */
export interface ITicketIntroduceEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean;
}

export class CreateOrUpdateTicketIntroduceInput implements ICreateOrUpdateTicketIntroduceInput {
    ticketIntroduce: TicketIntroduceEditDto;

    constructor(data?: ICreateOrUpdateTicketIntroduceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketIntroduce = new TicketIntroduceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketIntroduce = data["ticketIntroduce"] ? TicketIntroduceEditDto.fromJS(data["ticketIntroduce"]) : new TicketIntroduceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketIntroduceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketIntroduceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketIntroduce"] = this.ticketIntroduce ? this.ticketIntroduce.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketIntroduceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketIntroduceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketIntroduceInput {
    ticketIntroduce: TicketIntroduceEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketIntroduce */
export class TicketIntroduceListDto implements ITicketIntroduceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketIntroduceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.tradeName = data["tradeName"];
            this.tradeInfo = data["tradeInfo"];
            this.address = data["address"];
            this.coverMap = data["coverMap"];
            this.abstract = data["abstract"];
            this.notice = data["notice"];
            this.refundRule = data["refundRule"];
            this.isOnLine = data["isOnLine"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketIntroduceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketIntroduceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["tradeName"] = this.tradeName;
        data["tradeInfo"] = this.tradeInfo;
        data["address"] = this.address;
        data["coverMap"] = this.coverMap;
        data["abstract"] = this.abstract;
        data["notice"] = this.notice;
        data["refundRule"] = this.refundRule;
        data["isOnLine"] = this.isOnLine;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketIntroduceListDto {
        const json = this.toJSON();
        let result = new TicketIntroduceListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketIntroduce */
export interface ITicketIntroduceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** TradeName */
    tradeName: string | undefined;
    /** TradeInfo */
    tradeInfo: string | undefined;
    /** Address */
    address: string | undefined;
    /** CoverMap */
    coverMap: string | undefined;
    /** Abstract */
    abstract: string | undefined;
    /** Notice */
    notice: string | undefined;
    /** RefundRule */
    refundRule: string | undefined;
    /** IsOnLine */
    isOnLine: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketIntroduceForEditOutput implements IGetTicketIntroduceForEditOutput {
    ticketIntroduce: TicketIntroduceEditDto;

    constructor(data?: IGetTicketIntroduceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketIntroduce = data["ticketIntroduce"] ? TicketIntroduceEditDto.fromJS(data["ticketIntroduce"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketIntroduceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketIntroduceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketIntroduce"] = this.ticketIntroduce ? this.ticketIntroduce.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketIntroduceForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketIntroduceForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketIntroduceForEditOutput {
    ticketIntroduce: TicketIntroduceEditDto;
}

export class PagedResultDtoOfTicketIntroduceListDto implements IPagedResultDtoOfTicketIntroduceListDto {
    totalCount: number;
    items: TicketIntroduceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketIntroduceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketIntroduceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketIntroduceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketIntroduceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketIntroduceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketIntroduceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketIntroduceListDto {
    totalCount: number;
    items: TicketIntroduceListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketLocation */
export class TicketLocationEditDto implements ITicketLocationEditDto {
    /** Id */
    id: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    /** DateDictionaryId */
    dateDictionaryId: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: ITicketLocationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.dateDictionaryId = data["dateDictionaryId"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): TicketLocationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketLocationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["dateDictionaryId"] = this.dateDictionaryId;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): TicketLocationEditDto {
        const json = this.toJSON();
        let result = new TicketLocationEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketLocation */
export interface ITicketLocationEditDto {
    /** Id */
    id: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    /** DateDictionaryId */
    dateDictionaryId: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdateTicketLocationInput implements ICreateOrUpdateTicketLocationInput {
    ticketLocation: TicketLocationEditDto;

    constructor(data?: ICreateOrUpdateTicketLocationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketLocation = new TicketLocationEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketLocation = data["ticketLocation"] ? TicketLocationEditDto.fromJS(data["ticketLocation"]) : new TicketLocationEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketLocationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketLocationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketLocation"] = this.ticketLocation ? this.ticketLocation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketLocationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketLocationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketLocationInput {
    ticketLocation: TicketLocationEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketLocation */
export class TicketLocationListDto implements ITicketLocationListDto {
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    /** DateDictionaryId */
    dateDictionaryId: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketLocationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.dateDictionaryId = data["dateDictionaryId"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketLocationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketLocationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["dateDictionaryId"] = this.dateDictionaryId;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketLocationListDto {
        const json = this.toJSON();
        let result = new TicketLocationListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketLocation */
export interface ITicketLocationListDto {
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    /** DateDictionaryId */
    dateDictionaryId: number | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketLocationForEditOutput implements IGetTicketLocationForEditOutput {
    ticketLocation: TicketLocationEditDto;

    constructor(data?: IGetTicketLocationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketLocation = data["ticketLocation"] ? TicketLocationEditDto.fromJS(data["ticketLocation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketLocationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketLocationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketLocation"] = this.ticketLocation ? this.ticketLocation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketLocationForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketLocationForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketLocationForEditOutput {
    ticketLocation: TicketLocationEditDto;
}

export class PagedResultDtoOfTicketLocationListDto implements IPagedResultDtoOfTicketLocationListDto {
    totalCount: number;
    items: TicketLocationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketLocationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketLocationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketLocationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketLocationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketLocationListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketLocationListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketLocationListDto {
    totalCount: number;
    items: TicketLocationListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketPrice */
export class TicketPriceEditDto implements ITicketPriceEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** Price */
    price: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    position: PositionEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** 所属景区的Id */
    weChatScenicSpotId: number | undefined;

    constructor(data?: ITicketPriceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.price = data["price"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            this.upperTimeStr = data["upperTimeStr"];
            this.lowerTimeStr = data["lowerTimeStr"];
            this.position = data["position"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.ticketName = data["ticketName"];
            this.weChatScenicSpotId = data["weChatScenicSpotId"];
        }
    }

    static fromJS(data: any): TicketPriceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPriceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["upperTimeStr"] = this.upperTimeStr;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["position"] = this.position;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["ticketName"] = this.ticketName;
        data["weChatScenicSpotId"] = this.weChatScenicSpotId;
        return data; 
    }

    clone(): TicketPriceEditDto {
        const json = this.toJSON();
        let result = new TicketPriceEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketPrice */
export interface ITicketPriceEditDto {
    /** Id */
    id: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** Price */
    price: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    position: PositionEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** 所属景区的Id */
    weChatScenicSpotId: number | undefined;
}

export class CreateOrUpdateTicketPriceInput implements ICreateOrUpdateTicketPriceInput {
    ticketPrice: TicketPriceEditDto;

    constructor(data?: ICreateOrUpdateTicketPriceInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketPrice = new TicketPriceEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPrice = data["ticketPrice"] ? TicketPriceEditDto.fromJS(data["ticketPrice"]) : new TicketPriceEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketPriceInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketPriceInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketPriceInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketPriceInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketPriceInput {
    ticketPrice: TicketPriceEditDto;
}

/** 票价DTO Yozeev.BusinessLogic.TicketPrice */
export class TicketPriceListDto implements ITicketPriceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** Price */
    price: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment;
    readonly upperTimeStr: string | undefined;
    readonly lowerTimeStr: string | undefined;
    readonly creationTimeStr: string | undefined;
    position: PositionEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** 所属景区 */
    weChatScenicSpotId: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketPriceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.price = data["price"];
            this.rDiscount = data["rDiscount"];
            this.upperTime = data["upperTime"] ? moment(data["upperTime"].toString()) : <any>undefined;
            this.lowerTime = data["lowerTime"] ? moment(data["lowerTime"].toString()) : <any>undefined;
            (<any>this).upperTimeStr = data["upperTimeStr"];
            (<any>this).lowerTimeStr = data["lowerTimeStr"];
            (<any>this).creationTimeStr = data["creationTimeStr"];
            this.position = data["position"];
            this.isEnabled = data["isEnabled"];
            this.sort = data["sort"];
            this.ticketName = data["ticketName"];
            this.weChatScenicSpotId = data["weChatScenicSpotId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketPriceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPriceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["price"] = this.price;
        data["rDiscount"] = this.rDiscount;
        data["upperTime"] = this.upperTime ? this.upperTime.toISOString() : <any>undefined;
        data["lowerTime"] = this.lowerTime ? this.lowerTime.toISOString() : <any>undefined;
        data["upperTimeStr"] = this.upperTimeStr;
        data["lowerTimeStr"] = this.lowerTimeStr;
        data["creationTimeStr"] = this.creationTimeStr;
        data["position"] = this.position;
        data["isEnabled"] = this.isEnabled;
        data["sort"] = this.sort;
        data["ticketName"] = this.ticketName;
        data["weChatScenicSpotId"] = this.weChatScenicSpotId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketPriceListDto {
        const json = this.toJSON();
        let result = new TicketPriceListDto();
        result.init(json);
        return result;
    }
}

/** 票价DTO Yozeev.BusinessLogic.TicketPrice */
export interface ITicketPriceListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    /** Price */
    price: number;
    /** RDiscount */
    rDiscount: number;
    /** UpperTime */
    upperTime: moment.Moment;
    /** LowerTime */
    lowerTime: moment.Moment;
    upperTimeStr: string | undefined;
    lowerTimeStr: string | undefined;
    creationTimeStr: string | undefined;
    position: PositionEnum;
    /** IsEnabled */
    isEnabled: boolean;
    /** Sort */
    sort: number | undefined;
    /** TicketName */
    ticketName: string | undefined;
    /** 所属景区 */
    weChatScenicSpotId: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketPriceForEditOutput implements IGetTicketPriceForEditOutput {
    ticketPrice: TicketPriceEditDto;
    positionEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetTicketPriceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPrice = data["ticketPrice"] ? TicketPriceEditDto.fromJS(data["ticketPrice"]) : <any>undefined;
            if (data["positionEnumTypeEnum"] && data["positionEnumTypeEnum"].constructor === Array) {
                this.positionEnumTypeEnum = [] as any;
                for (let item of data["positionEnumTypeEnum"])
                    this.positionEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTicketPriceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketPriceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        if (this.positionEnumTypeEnum && this.positionEnumTypeEnum.constructor === Array) {
            data["positionEnumTypeEnum"] = [];
            for (let item of this.positionEnumTypeEnum)
                data["positionEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTicketPriceForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketPriceForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketPriceForEditOutput {
    ticketPrice: TicketPriceEditDto;
    positionEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

/** 获取的传入参数Dto */
export class GetTicketPricesInput implements IGetTicketPricesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetTicketPricesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["queryData"] && data["queryData"].constructor === Array) {
                this.queryData = [] as any;
                for (let item of data["queryData"])
                    this.queryData.push(QueryData.fromJS(item));
            }
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketPricesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketPricesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.queryData && this.queryData.constructor === Array) {
            data["queryData"] = [];
            for (let item of this.queryData)
                data["queryData"].push(item.toJSON());
        }
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketPricesInput {
        const json = this.toJSON();
        let result = new GetTicketPricesInput();
        result.init(json);
        return result;
    }
}

/** 获取的传入参数Dto */
export interface IGetTicketPricesInput {
    queryData: QueryData[] | undefined;
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class PagedResultDtoOfTicketPriceListDto implements IPagedResultDtoOfTicketPriceListDto {
    totalCount: number;
    items: TicketPriceListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketPriceListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketPriceListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketPriceListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketPriceListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketPriceListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketPriceListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketPriceListDto {
    totalCount: number;
    items: TicketPriceListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketRole */
export class TicketRoleEditDto implements ITicketRoleEditDto {
    /** Id */
    id: number | undefined;
    /** RoleId */
    roleId: number;
    role: Role;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;

    constructor(data?: ITicketRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.roleId = data["roleId"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketRoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketRoleEditDto {
        const json = this.toJSON();
        let result = new TicketRoleEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketRole */
export interface ITicketRoleEditDto {
    /** Id */
    id: number | undefined;
    /** RoleId */
    roleId: number;
    role: Role;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
}

export class CreateOrUpdateTicketRoleInput implements ICreateOrUpdateTicketRoleInput {
    ticketRole: TicketRoleEditDto;

    constructor(data?: ICreateOrUpdateTicketRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketRole = new TicketRoleEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketRole = data["ticketRole"] ? TicketRoleEditDto.fromJS(data["ticketRole"]) : new TicketRoleEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketRole"] = this.ticketRole ? this.ticketRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketRoleInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketRoleInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketRoleInput {
    ticketRole: TicketRoleEditDto;
}

/** 读取可编辑的Dto */
export class GetTicketRoleForEditOutput implements IGetTicketRoleForEditOutput {
    ticketRole: TicketRoleEditDto;

    constructor(data?: IGetTicketRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketRole = data["ticketRole"] ? TicketRoleEditDto.fromJS(data["ticketRole"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketRole"] = this.ticketRole ? this.ticketRole.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketRoleForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketRoleForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketRoleForEditOutput {
    ticketRole: TicketRoleEditDto;
}

/** 票型票价 */
export class TicketPriceOutput implements ITicketPriceOutput {
    /** 票价ID */
    id: number;
    ticketPrice: TicketPrice;
    ticket: Ticket;
    /** 是否可售 */
    isAvailable: boolean;

    constructor(data?: ITicketPriceOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.isAvailable = data["isAvailable"];
        }
    }

    static fromJS(data: any): TicketPriceOutput {
        data = typeof data === 'object' ? data : {};
        let result = new TicketPriceOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["isAvailable"] = this.isAvailable;
        return data; 
    }

    clone(): TicketPriceOutput {
        const json = this.toJSON();
        let result = new TicketPriceOutput();
        result.init(json);
        return result;
    }
}

/** 票型票价 */
export interface ITicketPriceOutput {
    /** 票价ID */
    id: number;
    ticketPrice: TicketPrice;
    ticket: Ticket;
    /** 是否可售 */
    isAvailable: boolean;
}

/** 角色可售票型管理 - 编辑（参数） */
export class GetTicketRoleForUpdateOutput implements IGetTicketRoleForUpdateOutput {
    /** 角色ID */
    id: number;
    role: Role;
    /** 票型票价集合 */
    allTicketPrices: TicketPriceOutput[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;

    constructor(data?: IGetTicketRoleForUpdateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            if (data["allTicketPrices"] && data["allTicketPrices"].constructor === Array) {
                this.allTicketPrices = [] as any;
                for (let item of data["allTicketPrices"])
                    this.allTicketPrices.push(TicketPriceOutput.fromJS(item));
            }
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): GetTicketRoleForUpdateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketRoleForUpdateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.allTicketPrices && this.allTicketPrices.constructor === Array) {
            data["allTicketPrices"] = [];
            for (let item of this.allTicketPrices)
                data["allTicketPrices"].push(item.toJSON());
        }
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): GetTicketRoleForUpdateOutput {
        const json = this.toJSON();
        let result = new GetTicketRoleForUpdateOutput();
        result.init(json);
        return result;
    }
}

/** 角色可售票型管理 - 编辑（参数） */
export interface IGetTicketRoleForUpdateOutput {
    /** 角色ID */
    id: number;
    role: Role;
    /** 票型票价集合 */
    allTicketPrices: TicketPriceOutput[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;
}

/** 角色可售票型管理 - 查询（参数） */
export class GetTicketRolesInput implements IGetTicketRolesInput {
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetTicketRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filterText = data["filterText"];
            this.sorting = data["sorting"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetTicketRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filterText"] = this.filterText;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetTicketRolesInput {
        const json = this.toJSON();
        let result = new GetTicketRolesInput();
        result.init(json);
        return result;
    }
}

/** 角色可售票型管理 - 查询（参数） */
export interface IGetTicketRolesInput {
    filterText: string | undefined;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

/** 可售票型 */
export class AvailableTicketPriceDto implements IAvailableTicketPriceDto {
    ticketPrice: TicketPrice;
    ticket: Ticket;

    constructor(data?: IAvailableTicketPriceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AvailableTicketPriceDto {
        data = typeof data === 'object' ? data : {};
        let result = new AvailableTicketPriceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AvailableTicketPriceDto {
        const json = this.toJSON();
        let result = new AvailableTicketPriceDto();
        result.init(json);
        return result;
    }
}

/** 可售票型 */
export interface IAvailableTicketPriceDto {
    ticketPrice: TicketPrice;
    ticket: Ticket;
}

/** 角色可售票型管理 - 查询（结果） */
export class TicketRoleListDto implements ITicketRoleListDto {
    /** 角色ID */
    id: number;
    role: Role;
    /** 包含人员集合 */
    users: User[] | undefined;
    /** 可售票型集合 */
    availableTicketPrices: AvailableTicketPriceDto[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;

    constructor(data?: ITicketRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.role = data["role"] ? Role.fromJS(data["role"]) : <any>undefined;
            if (data["users"] && data["users"].constructor === Array) {
                this.users = [] as any;
                for (let item of data["users"])
                    this.users.push(User.fromJS(item));
            }
            if (data["availableTicketPrices"] && data["availableTicketPrices"].constructor === Array) {
                this.availableTicketPrices = [] as any;
                for (let item of data["availableTicketPrices"])
                    this.availableTicketPrices.push(AvailableTicketPriceDto.fromJS(item));
            }
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): TicketRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.users && this.users.constructor === Array) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        if (this.availableTicketPrices && this.availableTicketPrices.constructor === Array) {
            data["availableTicketPrices"] = [];
            for (let item of this.availableTicketPrices)
                data["availableTicketPrices"].push(item.toJSON());
        }
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): TicketRoleListDto {
        const json = this.toJSON();
        let result = new TicketRoleListDto();
        result.init(json);
        return result;
    }
}

/** 角色可售票型管理 - 查询（结果） */
export interface ITicketRoleListDto {
    /** 角色ID */
    id: number;
    role: Role;
    /** 包含人员集合 */
    users: User[] | undefined;
    /** 可售票型集合 */
    availableTicketPrices: AvailableTicketPriceDto[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;
}

export class PagedResultDtoOfTicketRoleListDto implements IPagedResultDtoOfTicketRoleListDto {
    totalCount: number;
    items: TicketRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketRoleListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketRoleListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketRoleListDto {
    totalCount: number;
    items: TicketRoleListDto[] | undefined;
}

/** 角色可售票型管理 - 编辑（参数） */
export class UpdateTicketRoleInput implements IUpdateTicketRoleInput {
    /** 角色ID */
    roleId: number;
    /** 可售票型ID集合 */
    availableTicketPriceIds: number[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;

    constructor(data?: IUpdateTicketRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            if (data["availableTicketPriceIds"] && data["availableTicketPriceIds"].constructor === Array) {
                this.availableTicketPriceIds = [] as any;
                for (let item of data["availableTicketPriceIds"])
                    this.availableTicketPriceIds.push(item);
            }
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): UpdateTicketRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTicketRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        if (this.availableTicketPriceIds && this.availableTicketPriceIds.constructor === Array) {
            data["availableTicketPriceIds"] = [];
            for (let item of this.availableTicketPriceIds)
                data["availableTicketPriceIds"].push(item);
        }
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): UpdateTicketRoleInput {
        const json = this.toJSON();
        let result = new UpdateTicketRoleInput();
        result.init(json);
        return result;
    }
}

/** 角色可售票型管理 - 编辑（参数） */
export interface IUpdateTicketRoleInput {
    /** 角色ID */
    roleId: number;
    /** 可售票型ID集合 */
    availableTicketPriceIds: number[] | undefined;
    /** 是否启用 */
    isEnabled: boolean;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketScheduleEnable */
export class TicketScheduleEnableEditDto implements ITicketScheduleEnableEditDto {
    /** Id */
    id: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;

    constructor(data?: ITicketScheduleEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketScheduleEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketScheduleEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketScheduleEnableEditDto {
        const json = this.toJSON();
        let result = new TicketScheduleEnableEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketScheduleEnable */
export interface ITicketScheduleEnableEditDto {
    /** Id */
    id: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
}

export class CreateOrUpdateTicketScheduleEnableInput implements ICreateOrUpdateTicketScheduleEnableInput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketScheduleEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketScheduleEnable = new TicketScheduleEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketScheduleEnable = data["ticketScheduleEnable"] ? TicketScheduleEnableEditDto.fromJS(data["ticketScheduleEnable"]) : new TicketScheduleEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketScheduleEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketScheduleEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketScheduleEnable"] = this.ticketScheduleEnable ? this.ticketScheduleEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketScheduleEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketScheduleEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketScheduleEnableInput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketScheduleEnable */
export class TicketScheduleEnableListDto implements ITicketScheduleEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketScheduleEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketScheduleEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketScheduleEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketScheduleEnableListDto {
        const json = this.toJSON();
        let result = new TicketScheduleEnableListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketScheduleEnable */
export interface ITicketScheduleEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TicketPriceId */
    ticketPriceId: number | undefined;
    ticketPrice: TicketPrice;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketScheduleEnableForEditOutput implements IGetTicketScheduleEnableForEditOutput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;

    constructor(data?: IGetTicketScheduleEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketScheduleEnable = data["ticketScheduleEnable"] ? TicketScheduleEnableEditDto.fromJS(data["ticketScheduleEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketScheduleEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketScheduleEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketScheduleEnable"] = this.ticketScheduleEnable ? this.ticketScheduleEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketScheduleEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketScheduleEnableForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketScheduleEnableForEditOutput {
    ticketScheduleEnable: TicketScheduleEnableEditDto;
}

export class PagedResultDtoOfTicketScheduleEnableListDto implements IPagedResultDtoOfTicketScheduleEnableListDto {
    totalCount: number;
    items: TicketScheduleEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketScheduleEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketScheduleEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketScheduleEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketScheduleEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketScheduleEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketScheduleEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketScheduleEnableListDto {
    totalCount: number;
    items: TicketScheduleEnableListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketStation */
export class TicketStationEditDto implements ITicketStationEditDto {
    /** Id */
    id: number | undefined;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;

    constructor(data?: ITicketStationEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.stationName = data["stationName"];
            this.remand = data["remand"];
        }
    }

    static fromJS(data: any): TicketStationEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        return data; 
    }

    clone(): TicketStationEditDto {
        const json = this.toJSON();
        let result = new TicketStationEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketStation */
export interface ITicketStationEditDto {
    /** Id */
    id: number | undefined;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
}

export class CreateOrUpdateTicketStationInput implements ICreateOrUpdateTicketStationInput {
    ticketStation: TicketStationEditDto;

    constructor(data?: ICreateOrUpdateTicketStationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketStation = new TicketStationEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStation = data["ticketStation"] ? TicketStationEditDto.fromJS(data["ticketStation"]) : new TicketStationEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketStationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketStationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStation"] = this.ticketStation ? this.ticketStation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketStationInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketStationInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketStationInput {
    ticketStation: TicketStationEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketStation */
export class TicketStationListDto implements ITicketStationListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketStationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.stationName = data["stationName"];
            this.remand = data["remand"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStationListDto {
        const json = this.toJSON();
        let result = new TicketStationListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketStation */
export interface ITicketStationListDto {
    /** BranchId */
    branchId: number | undefined;
    /** ScenicSpotId */
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    /** StationName */
    stationName: string | undefined;
    /** Remand */
    remand: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketStationForEditOutput implements IGetTicketStationForEditOutput {
    ticketStation: TicketStationEditDto;

    constructor(data?: IGetTicketStationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStation = data["ticketStation"] ? TicketStationEditDto.fromJS(data["ticketStation"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketStationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketStationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStation"] = this.ticketStation ? this.ticketStation.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketStationForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketStationForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketStationForEditOutput {
    ticketStation: TicketStationEditDto;
}

export class PagedResultDtoOfTicketStationListDto implements IPagedResultDtoOfTicketStationListDto {
    totalCount: number;
    items: TicketStationListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketStationListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketStationListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketStationListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketStationListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketStationListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketStationListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketStationListDto {
    totalCount: number;
    items: TicketStationListDto[] | undefined;
}

export class TicketStation implements ITicketStation {
    branchId: number | undefined;
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    stationName: string | undefined;
    remand: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketStation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotId = data["scenicSpotId"];
            this.scenicSpot = data["scenicSpot"] ? ScenicSpot.fromJS(data["scenicSpot"]) : <any>undefined;
            this.stationName = data["stationName"];
            this.remand = data["remand"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStation {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotId"] = this.scenicSpotId;
        data["scenicSpot"] = this.scenicSpot ? this.scenicSpot.toJSON() : <any>undefined;
        data["stationName"] = this.stationName;
        data["remand"] = this.remand;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStation {
        const json = this.toJSON();
        let result = new TicketStation();
        result.init(json);
        return result;
    }
}

export interface ITicketStation {
    branchId: number | undefined;
    scenicSpotId: number;
    scenicSpot: ScenicSpot;
    stationName: string | undefined;
    remand: string | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketStationEnable */
export class TicketStationEnableEditDto implements ITicketStationEnableEditDto {
    /** Id */
    id: number | undefined;
    /** StationId */
    stationId: number;
    station: TicketStation;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;

    constructor(data?: ITicketStationEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.stationId = data["stationId"];
            this.station = data["station"] ? TicketStation.fromJS(data["station"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketStationEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["stationId"] = this.stationId;
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketStationEnableEditDto {
        const json = this.toJSON();
        let result = new TicketStationEnableEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketStationEnable */
export interface ITicketStationEnableEditDto {
    /** Id */
    id: number | undefined;
    /** StationId */
    stationId: number;
    station: TicketStation;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
}

export class CreateOrUpdateTicketStationEnableInput implements ICreateOrUpdateTicketStationEnableInput {
    ticketStationEnable: TicketStationEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketStationEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketStationEnable = new TicketStationEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStationEnable = data["ticketStationEnable"] ? TicketStationEnableEditDto.fromJS(data["ticketStationEnable"]) : new TicketStationEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketStationEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketStationEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStationEnable"] = this.ticketStationEnable ? this.ticketStationEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketStationEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketStationEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketStationEnableInput {
    ticketStationEnable: TicketStationEnableEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketStationEnable */
export class TicketStationEnableListDto implements ITicketStationEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** StationId */
    stationId: number;
    station: TicketStation;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketStationEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.stationId = data["stationId"];
            this.station = data["station"] ? TicketStation.fromJS(data["station"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticket = data["ticket"] ? Ticket.fromJS(data["ticket"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketStationEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketStationEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["stationId"] = this.stationId;
        data["station"] = this.station ? this.station.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticket"] = this.ticket ? this.ticket.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketStationEnableListDto {
        const json = this.toJSON();
        let result = new TicketStationEnableListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketStationEnable */
export interface ITicketStationEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** StationId */
    stationId: number;
    station: TicketStation;
    /** TicketId */
    ticketId: number;
    ticket: Ticket;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketStationEnableForEditOutput implements IGetTicketStationEnableForEditOutput {
    ticketStationEnable: TicketStationEnableEditDto;

    constructor(data?: IGetTicketStationEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketStationEnable = data["ticketStationEnable"] ? TicketStationEnableEditDto.fromJS(data["ticketStationEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketStationEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketStationEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketStationEnable"] = this.ticketStationEnable ? this.ticketStationEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketStationEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketStationEnableForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketStationEnableForEditOutput {
    ticketStationEnable: TicketStationEnableEditDto;
}

export class PagedResultDtoOfTicketStationEnableListDto implements IPagedResultDtoOfTicketStationEnableListDto {
    totalCount: number;
    items: TicketStationEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketStationEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketStationEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketStationEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketStationEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketStationEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketStationEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketStationEnableListDto {
    totalCount: number;
    items: TicketStationEnableListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TicketUserEnable */
export class TicketUserEnableEditDto implements ITicketUserEnableEditDto {
    /** Id */
    id: number | undefined;
    /** SaleUserId */
    saleUserId: number;
    saleUser: User;
    /** TicketId */
    ticketId: number;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;

    constructor(data?: ITicketUserEnableEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.saleUserId = data["saleUserId"];
            this.saleUser = data["saleUser"] ? User.fromJS(data["saleUser"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TicketUserEnableEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUserEnableEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["saleUserId"] = this.saleUserId;
        data["saleUser"] = this.saleUser ? this.saleUser.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        return data; 
    }

    clone(): TicketUserEnableEditDto {
        const json = this.toJSON();
        let result = new TicketUserEnableEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TicketUserEnable */
export interface ITicketUserEnableEditDto {
    /** Id */
    id: number | undefined;
    /** SaleUserId */
    saleUserId: number;
    saleUser: User;
    /** TicketId */
    ticketId: number;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
}

export class CreateOrUpdateTicketUserEnableInput implements ICreateOrUpdateTicketUserEnableInput {
    ticketUserEnable: TicketUserEnableEditDto;

    constructor(data?: ICreateOrUpdateTicketUserEnableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ticketUserEnable = new TicketUserEnableEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketUserEnable = data["ticketUserEnable"] ? TicketUserEnableEditDto.fromJS(data["ticketUserEnable"]) : new TicketUserEnableEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTicketUserEnableInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTicketUserEnableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketUserEnable"] = this.ticketUserEnable ? this.ticketUserEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTicketUserEnableInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTicketUserEnableInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTicketUserEnableInput {
    ticketUserEnable: TicketUserEnableEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketUserEnable */
export class TicketUserEnableListDto implements ITicketUserEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** SaleUserId */
    saleUserId: number;
    saleUser: User;
    /** TicketId */
    ticketId: number;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITicketUserEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.saleUserId = data["saleUserId"];
            this.saleUser = data["saleUser"] ? User.fromJS(data["saleUser"]) : <any>undefined;
            this.ticketId = data["ticketId"];
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketPrice = data["ticketPrice"] ? TicketPrice.fromJS(data["ticketPrice"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TicketUserEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TicketUserEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["saleUserId"] = this.saleUserId;
        data["saleUser"] = this.saleUser ? this.saleUser.toJSON() : <any>undefined;
        data["ticketId"] = this.ticketId;
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketPrice"] = this.ticketPrice ? this.ticketPrice.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TicketUserEnableListDto {
        const json = this.toJSON();
        let result = new TicketUserEnableListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TicketUserEnable */
export interface ITicketUserEnableListDto {
    /** BranchId */
    branchId: number | undefined;
    /** SaleUserId */
    saleUserId: number;
    saleUser: User;
    /** TicketId */
    ticketId: number;
    /** TicketPriceId */
    ticketPriceId: number;
    ticketPrice: TicketPrice;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTicketUserEnableForEditOutput implements IGetTicketUserEnableForEditOutput {
    ticketUserEnable: TicketUserEnableEditDto;

    constructor(data?: IGetTicketUserEnableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketUserEnable = data["ticketUserEnable"] ? TicketUserEnableEditDto.fromJS(data["ticketUserEnable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTicketUserEnableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTicketUserEnableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketUserEnable"] = this.ticketUserEnable ? this.ticketUserEnable.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTicketUserEnableForEditOutput {
        const json = this.toJSON();
        let result = new GetTicketUserEnableForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTicketUserEnableForEditOutput {
    ticketUserEnable: TicketUserEnableEditDto;
}

export class PagedResultDtoOfTicketUserEnableListDto implements IPagedResultDtoOfTicketUserEnableListDto {
    totalCount: number;
    items: TicketUserEnableListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTicketUserEnableListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TicketUserEnableListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTicketUserEnableListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTicketUserEnableListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTicketUserEnableListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTicketUserEnableListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTicketUserEnableListDto {
    totalCount: number;
    items: TicketUserEnableListDto[] | undefined;
}

export enum SettingScopes {
    Application = <any>"Application", 
    Tenant = <any>"Tenant", 
    User = <any>"User", 
    All = <any>"All", 
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfNameValueDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfNameValueDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TravelAgency */
export class TravelAgencyEditDto implements ITravelAgencyEditDto {
    /** Id */
    id: number | undefined;
    /** TravelName */
    travelName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Discount */
    discount: number;
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** Lowerlimit */
    lowerlimit: number | undefined;

    constructor(data?: ITravelAgencyEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
        }
    }

    static fromJS(data: any): TravelAgencyEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgencyEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        return data; 
    }

    clone(): TravelAgencyEditDto {
        const json = this.toJSON();
        let result = new TravelAgencyEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TravelAgency */
export interface ITravelAgencyEditDto {
    /** Id */
    id: number | undefined;
    /** TravelName */
    travelName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Discount */
    discount: number;
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** Lowerlimit */
    lowerlimit: number | undefined;
}

export class CreateOrUpdateTravelAgencyInput implements ICreateOrUpdateTravelAgencyInput {
    travelAgency: TravelAgencyEditDto;

    constructor(data?: ICreateOrUpdateTravelAgencyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.travelAgency = new TravelAgencyEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.travelAgency = data["travelAgency"] ? TravelAgencyEditDto.fromJS(data["travelAgency"]) : new TravelAgencyEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTravelAgencyInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTravelAgencyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTravelAgencyInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTravelAgencyInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTravelAgencyInput {
    travelAgency: TravelAgencyEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TravelAgency */
export class TravelAgencyListDto implements ITravelAgencyListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TravelName */
    travelName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Discount */
    discount: number;
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** Lowerlimit */
    lowerlimit: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITravelAgencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.travelName = data["travelName"];
            this.mobile = data["mobile"];
            this.contacts = data["contacts"];
            this.isEnabled = data["isEnabled"];
            this.discount = data["discount"];
            this.payMethod = data["payMethod"];
            this.totalSum = data["totalSum"];
            this.prepaidAmount = data["prepaidAmount"];
            this.alarmAmount = data["alarmAmount"];
            this.upperLimit = data["upperLimit"];
            this.lowerlimit = data["lowerlimit"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelAgencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelAgencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["travelName"] = this.travelName;
        data["mobile"] = this.mobile;
        data["contacts"] = this.contacts;
        data["isEnabled"] = this.isEnabled;
        data["discount"] = this.discount;
        data["payMethod"] = this.payMethod;
        data["totalSum"] = this.totalSum;
        data["prepaidAmount"] = this.prepaidAmount;
        data["alarmAmount"] = this.alarmAmount;
        data["upperLimit"] = this.upperLimit;
        data["lowerlimit"] = this.lowerlimit;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelAgencyListDto {
        const json = this.toJSON();
        let result = new TravelAgencyListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TravelAgency */
export interface ITravelAgencyListDto {
    /** BranchId */
    branchId: number | undefined;
    /** TravelName */
    travelName: string | undefined;
    /** Mobile */
    mobile: string | undefined;
    /** Contacts */
    contacts: string | undefined;
    /** IsEnabled */
    isEnabled: boolean;
    /** Discount */
    discount: number;
    payMethod: PayMethodEnum;
    /** TotalSum */
    totalSum: number;
    /** PrepaidAmount */
    prepaidAmount: number;
    /** AlarmAmount */
    alarmAmount: number;
    /** UpperLimit */
    upperLimit: number | undefined;
    /** Lowerlimit */
    lowerlimit: number | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTravelAgencyForEditOutput implements IGetTravelAgencyForEditOutput {
    travelAgency: TravelAgencyEditDto;
    payMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetTravelAgencyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.travelAgency = data["travelAgency"] ? TravelAgencyEditDto.fromJS(data["travelAgency"]) : <any>undefined;
            if (data["payMethodEnumTypeEnum"] && data["payMethodEnumTypeEnum"].constructor === Array) {
                this.payMethodEnumTypeEnum = [] as any;
                for (let item of data["payMethodEnumTypeEnum"])
                    this.payMethodEnumTypeEnum.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTravelAgencyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelAgencyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelAgency"] = this.travelAgency ? this.travelAgency.toJSON() : <any>undefined;
        if (this.payMethodEnumTypeEnum && this.payMethodEnumTypeEnum.constructor === Array) {
            data["payMethodEnumTypeEnum"] = [];
            for (let item of this.payMethodEnumTypeEnum)
                data["payMethodEnumTypeEnum"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetTravelAgencyForEditOutput {
        const json = this.toJSON();
        let result = new GetTravelAgencyForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTravelAgencyForEditOutput {
    travelAgency: TravelAgencyEditDto;
    payMethodEnumTypeEnum: KeyValuePairOfStringString[] | undefined;
}

export class PagedResultDtoOfTravelAgencyListDto implements IPagedResultDtoOfTravelAgencyListDto {
    totalCount: number;
    items: TravelAgencyListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelAgencyListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TravelAgencyListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelAgencyListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelAgencyListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTravelAgencyListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTravelAgencyListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTravelAgencyListDto {
    totalCount: number;
    items: TravelAgencyListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.TravelTicketDetail */
export class TravelTicketDetailEditDto implements ITravelTicketDetailEditDto {
    /** Id */
    id: number | undefined;
    /** CustomerId */
    customerId: number;
    /** TravelAgencyId */
    travelAgencyId: number;
    /** ActivityTempId */
    activityTempId: number;
    /** ActivityTempDetailId */
    activityTempDetailId: number;

    constructor(data?: ITravelTicketDetailEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.customerId = data["customerId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.activityTempId = data["activityTempId"];
            this.activityTempDetailId = data["activityTempDetailId"];
        }
    }

    static fromJS(data: any): TravelTicketDetailEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelTicketDetailEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["customerId"] = this.customerId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["activityTempId"] = this.activityTempId;
        data["activityTempDetailId"] = this.activityTempDetailId;
        return data; 
    }

    clone(): TravelTicketDetailEditDto {
        const json = this.toJSON();
        let result = new TravelTicketDetailEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.TravelTicketDetail */
export interface ITravelTicketDetailEditDto {
    /** Id */
    id: number | undefined;
    /** CustomerId */
    customerId: number;
    /** TravelAgencyId */
    travelAgencyId: number;
    /** ActivityTempId */
    activityTempId: number;
    /** ActivityTempDetailId */
    activityTempDetailId: number;
}

export class CreateOrUpdateTravelTicketDetailInput implements ICreateOrUpdateTravelTicketDetailInput {
    travelTicketDetail: TravelTicketDetailEditDto;

    constructor(data?: ICreateOrUpdateTravelTicketDetailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.travelTicketDetail = new TravelTicketDetailEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.travelTicketDetail = data["travelTicketDetail"] ? TravelTicketDetailEditDto.fromJS(data["travelTicketDetail"]) : new TravelTicketDetailEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateTravelTicketDetailInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateTravelTicketDetailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelTicketDetail"] = this.travelTicketDetail ? this.travelTicketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateTravelTicketDetailInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateTravelTicketDetailInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateTravelTicketDetailInput {
    travelTicketDetail: TravelTicketDetailEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.TravelTicketDetail */
export class TravelTicketDetailListDto implements ITravelTicketDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** CustomerId */
    customerId: number;
    /** TravelAgencyId */
    travelAgencyId: number;
    /** ActivityTempId */
    activityTempId: number;
    /** ActivityTempDetailId */
    activityTempDetailId: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: ITravelTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.customerId = data["customerId"];
            this.travelAgencyId = data["travelAgencyId"];
            this.activityTempId = data["activityTempId"];
            this.activityTempDetailId = data["activityTempDetailId"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TravelTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["customerId"] = this.customerId;
        data["travelAgencyId"] = this.travelAgencyId;
        data["activityTempId"] = this.activityTempId;
        data["activityTempDetailId"] = this.activityTempDetailId;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): TravelTicketDetailListDto {
        const json = this.toJSON();
        let result = new TravelTicketDetailListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.TravelTicketDetail */
export interface ITravelTicketDetailListDto {
    /** BranchId */
    branchId: number | undefined;
    /** CustomerId */
    customerId: number;
    /** TravelAgencyId */
    travelAgencyId: number;
    /** ActivityTempId */
    activityTempId: number;
    /** ActivityTempDetailId */
    activityTempDetailId: number;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetTravelTicketDetailForEditOutput implements IGetTravelTicketDetailForEditOutput {
    travelTicketDetail: TravelTicketDetailEditDto;

    constructor(data?: IGetTravelTicketDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.travelTicketDetail = data["travelTicketDetail"] ? TravelTicketDetailEditDto.fromJS(data["travelTicketDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTravelTicketDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelTicketDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelTicketDetail"] = this.travelTicketDetail ? this.travelTicketDetail.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetTravelTicketDetailForEditOutput {
        const json = this.toJSON();
        let result = new GetTravelTicketDetailForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetTravelTicketDetailForEditOutput {
    travelTicketDetail: TravelTicketDetailEditDto;
}

export class PagedResultDtoOfTravelTicketDetailListDto implements IPagedResultDtoOfTravelTicketDetailListDto {
    totalCount: number;
    items: TravelTicketDetailListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelTicketDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(TravelTicketDetailListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelTicketDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelTicketDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfTravelTicketDetailListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfTravelTicketDetailListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfTravelTicketDetailListDto {
    totalCount: number;
    items: TravelTicketDetailListDto[] | undefined;
}

/** 用户信息编辑用Dto */
export class UserEditDto implements IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id: number | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    isLockoutEnabled: boolean;
    /** 需要修改密码 */
    needToChangeThePassword: boolean;
    /** 头像Id */
    profilePictureId: string | undefined;
    isTwoFactorEnabled: boolean;
    isActive: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.needToChangeThePassword = data["needToChangeThePassword"];
            this.profilePictureId = data["profilePictureId"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isActive = data["isActive"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["needToChangeThePassword"] = this.needToChangeThePassword;
        data["profilePictureId"] = this.profilePictureId;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isActive"] = this.isActive;
        return data; 
    }

    clone(): UserEditDto {
        const json = this.toJSON();
        let result = new UserEditDto();
        result.init(json);
        return result;
    }
}

/** 用户信息编辑用Dto */
export interface IUserEditDto {
    /** 根据id是否有值来判断是创建还是添加 */
    id: number | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    isLockoutEnabled: boolean;
    /** 需要修改密码 */
    needToChangeThePassword: boolean;
    /** 头像Id */
    profilePictureId: string | undefined;
    isTwoFactorEnabled: boolean;
    isActive: boolean;
}

/** 用户信息新增和编辑时用Dto */
export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    /** 授权的角色 */
    assignedRoleNames: string[] | undefined;
    /** 所在的组织机构的ID */
    organizationUnits: number[] | undefined;
    /** 发送激活邮件 */
    sendActivationEmail: boolean;
    /** 设置随机密码 */
    setRandomPassword: boolean;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        return data; 
    }

    clone(): CreateOrUpdateUserInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateUserInput();
        result.init(json);
        return result;
    }
}

/** 用户信息新增和编辑时用Dto */
export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    /** 授权的角色 */
    assignedRoleNames: string[] | undefined;
    /** 所在的组织机构的ID */
    organizationUnits: number[] | undefined;
    /** 发送激活邮件 */
    sendActivationEmail: boolean;
    /** 设置随机密码 */
    setRandomPassword: boolean;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }

    clone(): UserRoleDto {
        const json = this.toJSON();
        let result = new UserRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
}

export class GetUserForEditTreeOutput implements IGetUserForEditTreeOutput {
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditTreeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditTreeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditTreeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone(): GetUserForEditTreeOutput {
        const json = this.toJSON();
        let result = new GetUserForEditTreeOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditTreeOutput {
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }

    clone(): UserListRoleDto {
        const json = this.toJSON();
        let result = new UserListRoleDto();
        result.init(json);
        return result;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

/** 用户信息列表Dto */
export class UserListDto implements IUserListDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    isActive: boolean;
    id: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["id"] = this.id;
        return data; 
    }

    clone(): UserListDto {
        const json = this.toJSON();
        let result = new UserListDto();
        result.init(json);
        return result;
    }
}

/** 用户信息列表Dto */
export interface IUserListDto {
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    creationTime: moment.Moment;
    isActive: boolean;
    id: number;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfUserListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfUserListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class GetUserPermissionsTreeForEditOutput implements IGetUserPermissionsTreeForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsTreeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsTreeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsTreeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsTreeForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsTreeForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsTreeForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitListDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }

    clone(): GetUserForEditOutput {
        const json = this.toJSON();
        let result = new GetUserForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitListDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    /** 所有的权限 */
    permissions: FlatPermissionDto[] | undefined;
    /** 已有权限 */
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): GetUserPermissionsForEditOutput {
        const json = this.toJSON();
        let result = new GetUserPermissionsForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetUserPermissionsForEditOutput {
    /** 所有的权限 */
    permissions: FlatPermissionDto[] | undefined;
    /** 已有权限 */
    grantedPermissionNames: string[] | undefined;
}

export class NullableIdDtoOfInt64 implements INullableIdDtoOfInt64 {
    id: number | undefined;

    constructor(data?: INullableIdDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): NullableIdDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new NullableIdDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): NullableIdDtoOfInt64 {
        const json = this.toJSON();
        let result = new NullableIdDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface INullableIdDtoOfInt64 {
    id: number | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }

    clone(): EntityDtoOfInt64 {
        const json = this.toJSON();
        let result = new EntityDtoOfInt64();
        result.init(json);
        return result;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }

    clone(): UpdateUserPermissionsInput {
        const json = this.toJSON();
        let result = new UpdateUserPermissionsInput();
        result.init(json);
        return result;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }

    clone(): LinkedUserDto {
        const json = this.toJSON();
        let result = new LinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfLinkedUserDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }

    clone(): LinkToUserInput {
        const json = this.toJSON();
        let result = new LinkToUserInput();
        result.init(json);
        return result;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string | undefined;
    password: string | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): UnlinkUserInput {
        const json = this.toJSON();
        let result = new UnlinkUserInput();
        result.init(json);
        return result;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }

    clone(): UserLoginAttemptDto {
        const json = this.toJSON();
        let result = new UserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmailAddress: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): ListResultDtoOfUserLoginAttemptDto {
        const json = this.toJSON();
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(json);
        return result;
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.VerifiableSet */
export class VerifiableSetEditDto implements IVerifiableSetEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;

    constructor(data?: IVerifiableSetEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.verifiableType = data["verifiableType"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): VerifiableSetEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifiableSetEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verifiableType"] = this.verifiableType;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }

    clone(): VerifiableSetEditDto {
        const json = this.toJSON();
        let result = new VerifiableSetEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.VerifiableSet */
export interface IVerifiableSetEditDto {
    /** Id */
    id: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
}

export class CreateOrUpdateVerifiableSetInput implements ICreateOrUpdateVerifiableSetInput {
    verifiableSet: VerifiableSetEditDto;

    constructor(data?: ICreateOrUpdateVerifiableSetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.verifiableSet = new VerifiableSetEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.verifiableSet = data["verifiableSet"] ? VerifiableSetEditDto.fromJS(data["verifiableSet"]) : new VerifiableSetEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateVerifiableSetInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateVerifiableSetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifiableSet"] = this.verifiableSet ? this.verifiableSet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateVerifiableSetInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateVerifiableSetInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateVerifiableSetInput {
    verifiableSet: VerifiableSetEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.VerifiableSet */
export class VerifiableSetListDto implements IVerifiableSetListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IVerifiableSetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.deviceId = data["deviceId"];
            this.device = data["device"] ? Device.fromJS(data["device"]) : <any>undefined;
            this.verifiableType = data["verifiableType"];
            this.isEnabled = data["isEnabled"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VerifiableSetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifiableSetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["deviceId"] = this.deviceId;
        data["device"] = this.device ? this.device.toJSON() : <any>undefined;
        data["verifiableType"] = this.verifiableType;
        data["isEnabled"] = this.isEnabled;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): VerifiableSetListDto {
        const json = this.toJSON();
        let result = new VerifiableSetListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.VerifiableSet */
export interface IVerifiableSetListDto {
    /** BranchId */
    branchId: number | undefined;
    /** DeviceId */
    deviceId: number;
    device: Device;
    verifiableType: VerifiableTypeEnum;
    /** IsEnabled */
    isEnabled: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetVerifiableSetForEditOutput implements IGetVerifiableSetForEditOutput {
    verifiableSet: VerifiableSetEditDto;

    constructor(data?: IGetVerifiableSetForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.verifiableSet = data["verifiableSet"] ? VerifiableSetEditDto.fromJS(data["verifiableSet"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVerifiableSetForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVerifiableSetForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["verifiableSet"] = this.verifiableSet ? this.verifiableSet.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetVerifiableSetForEditOutput {
        const json = this.toJSON();
        let result = new GetVerifiableSetForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetVerifiableSetForEditOutput {
    verifiableSet: VerifiableSetEditDto;
}

export class PagedResultDtoOfVerifiableSetListDto implements IPagedResultDtoOfVerifiableSetListDto {
    totalCount: number;
    items: VerifiableSetListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVerifiableSetListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(VerifiableSetListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVerifiableSetListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVerifiableSetListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfVerifiableSetListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfVerifiableSetListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfVerifiableSetListDto {
    totalCount: number;
    items: VerifiableSetListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }

    clone(): GetLatestWebLogsOutput {
        const json = this.toJSON();
        let result = new GetLatestWebLogsOutput();
        result.init(json);
        return result;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export enum WechatAppTypeEnum {
    订阅号 = <any>"订阅号", 
    认证订阅号 = <any>"认证订阅号", 
    服务号 = <any>"服务号", 
    认证服务号 = <any>"认证服务号", 
}

export class WechatAppConfigEditDto implements IWechatAppConfigEditDto {
    /** Id */
    id: number | undefined;
    /** AppId */
    appId: string | undefined;
    /** AppSecret */
    appSecret: string | undefined;
    /** Token */
    token: string | undefined;
    /** EncodingAESKey */
    encodingAESKey: string | undefined;
    /** 公众号名称 */
    name: string | undefined;
    /** 公众号原始ID */
    appOrgId: string | undefined;
    appType: WechatAppTypeEnum;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;

    constructor(data?: IWechatAppConfigEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.appId = data["appId"];
            this.appSecret = data["appSecret"];
            this.token = data["token"];
            this.encodingAESKey = data["encodingAESKey"];
            this.name = data["name"];
            this.appOrgId = data["appOrgId"];
            this.appType = data["appType"];
            this.qrCodeUrl = data["qrCodeUrl"];
        }
    }

    static fromJS(data: any): WechatAppConfigEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatAppConfigEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        data["token"] = this.token;
        data["encodingAESKey"] = this.encodingAESKey;
        data["name"] = this.name;
        data["appOrgId"] = this.appOrgId;
        data["appType"] = this.appType;
        data["qrCodeUrl"] = this.qrCodeUrl;
        return data; 
    }

    clone(): WechatAppConfigEditDto {
        const json = this.toJSON();
        let result = new WechatAppConfigEditDto();
        result.init(json);
        return result;
    }
}

export interface IWechatAppConfigEditDto {
    /** Id */
    id: number | undefined;
    /** AppId */
    appId: string | undefined;
    /** AppSecret */
    appSecret: string | undefined;
    /** Token */
    token: string | undefined;
    /** EncodingAESKey */
    encodingAESKey: string | undefined;
    /** 公众号名称 */
    name: string | undefined;
    /** 公众号原始ID */
    appOrgId: string | undefined;
    appType: WechatAppTypeEnum;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
}

export class CreateOrUpdateWechatAppConfigInput implements ICreateOrUpdateWechatAppConfigInput {
    wechatAppConfig: WechatAppConfigEditDto;

    constructor(data?: ICreateOrUpdateWechatAppConfigInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.wechatAppConfig = new WechatAppConfigEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatAppConfig = data["wechatAppConfig"] ? WechatAppConfigEditDto.fromJS(data["wechatAppConfig"]) : new WechatAppConfigEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateWechatAppConfigInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWechatAppConfigInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatAppConfig"] = this.wechatAppConfig ? this.wechatAppConfig.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateWechatAppConfigInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWechatAppConfigInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWechatAppConfigInput {
    wechatAppConfig: WechatAppConfigEditDto;
}

export class WechatAppConfigListDto implements IWechatAppConfigListDto {
    /** AppId */
    appId: string | undefined;
    /** 公众号名称 */
    name: string | undefined;
    appType: WechatAppTypeEnum;
    /** 公众号类型中文名称 */
    appTypeStr: string | undefined;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
    /** 已注册到应用冲 */
    registered: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IWechatAppConfigListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.name = data["name"];
            this.appType = data["appType"];
            this.appTypeStr = data["appTypeStr"];
            this.qrCodeUrl = data["qrCodeUrl"];
            this.registered = data["registered"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WechatAppConfigListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WechatAppConfigListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["name"] = this.name;
        data["appType"] = this.appType;
        data["appTypeStr"] = this.appTypeStr;
        data["qrCodeUrl"] = this.qrCodeUrl;
        data["registered"] = this.registered;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WechatAppConfigListDto {
        const json = this.toJSON();
        let result = new WechatAppConfigListDto();
        result.init(json);
        return result;
    }
}

export interface IWechatAppConfigListDto {
    /** AppId */
    appId: string | undefined;
    /** 公众号名称 */
    name: string | undefined;
    appType: WechatAppTypeEnum;
    /** 公众号类型中文名称 */
    appTypeStr: string | undefined;
    /** QRCodeUrl */
    qrCodeUrl: string | undefined;
    /** 已注册到应用冲 */
    registered: boolean;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

export class KeyValuePairOfStringInt32 implements IKeyValuePairOfStringInt32 {
    readonly key: string | undefined;
    readonly value: number;

    constructor(data?: IKeyValuePairOfStringInt32) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).key = data["key"];
            (<any>this).value = data["value"];
        }
    }

    static fromJS(data: any): KeyValuePairOfStringInt32 {
        data = typeof data === 'object' ? data : {};
        let result = new KeyValuePairOfStringInt32();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }

    clone(): KeyValuePairOfStringInt32 {
        const json = this.toJSON();
        let result = new KeyValuePairOfStringInt32();
        result.init(json);
        return result;
    }
}

export interface IKeyValuePairOfStringInt32 {
    key: string | undefined;
    value: number;
}

export class GetWechatAppConfigForEditOutput implements IGetWechatAppConfigForEditOutput {
    wechatAppConfig: WechatAppConfigEditDto;
    wechatAppTypeList: KeyValuePairOfStringInt32[] | undefined;

    constructor(data?: IGetWechatAppConfigForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.wechatAppConfig = data["wechatAppConfig"] ? WechatAppConfigEditDto.fromJS(data["wechatAppConfig"]) : <any>undefined;
            if (data["wechatAppTypeList"] && data["wechatAppTypeList"].constructor === Array) {
                this.wechatAppTypeList = [] as any;
                for (let item of data["wechatAppTypeList"])
                    this.wechatAppTypeList.push(KeyValuePairOfStringInt32.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatAppConfigForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatAppConfigForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wechatAppConfig"] = this.wechatAppConfig ? this.wechatAppConfig.toJSON() : <any>undefined;
        if (this.wechatAppTypeList && this.wechatAppTypeList.constructor === Array) {
            data["wechatAppTypeList"] = [];
            for (let item of this.wechatAppTypeList)
                data["wechatAppTypeList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetWechatAppConfigForEditOutput {
        const json = this.toJSON();
        let result = new GetWechatAppConfigForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWechatAppConfigForEditOutput {
    wechatAppConfig: WechatAppConfigEditDto;
    wechatAppTypeList: KeyValuePairOfStringInt32[] | undefined;
}

export class PagedResultDtoOfWechatAppConfigListDto implements IPagedResultDtoOfWechatAppConfigListDto {
    totalCount: number;
    items: WechatAppConfigListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWechatAppConfigListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WechatAppConfigListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWechatAppConfigListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWechatAppConfigListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWechatAppConfigListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWechatAppConfigListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWechatAppConfigListDto {
    totalCount: number;
    items: WechatAppConfigListDto[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Common.WeChatHomePage */
export class WeChatHomePageEditDto implements IWeChatHomePageEditDto {
    /** Id */
    id: number | undefined;
    /** 主页介绍 */
    homePageIntro: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 购票须知 */
    ticketPolicy: string | undefined;
    /** 是否启用 */
    isEnable: boolean;

    constructor(data?: IWeChatHomePageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.homePageIntro = data["homePageIntro"];
            this.focusPicture = data["focusPicture"];
            this.ticketPolicy = data["ticketPolicy"];
            this.isEnable = data["isEnable"];
        }
    }

    static fromJS(data: any): WeChatHomePageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatHomePageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["homePageIntro"] = this.homePageIntro;
        data["focusPicture"] = this.focusPicture;
        data["ticketPolicy"] = this.ticketPolicy;
        data["isEnable"] = this.isEnable;
        return data; 
    }

    clone(): WeChatHomePageEditDto {
        const json = this.toJSON();
        let result = new WeChatHomePageEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Common.WeChatHomePage */
export interface IWeChatHomePageEditDto {
    /** Id */
    id: number | undefined;
    /** 主页介绍 */
    homePageIntro: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 购票须知 */
    ticketPolicy: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
}

export class CreateOrUpdateWeChatHomePageInput implements ICreateOrUpdateWeChatHomePageInput {
    weChatHomePage: WeChatHomePageEditDto;

    constructor(data?: ICreateOrUpdateWeChatHomePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.weChatHomePage = new WeChatHomePageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.weChatHomePage = data["weChatHomePage"] ? WeChatHomePageEditDto.fromJS(data["weChatHomePage"]) : new WeChatHomePageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateWeChatHomePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWeChatHomePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weChatHomePage"] = this.weChatHomePage ? this.weChatHomePage.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateWeChatHomePageInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWeChatHomePageInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWeChatHomePageInput {
    weChatHomePage: WeChatHomePageEditDto;
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.WeChatHomePage */
export class WeChatHomePageListDto implements IWeChatHomePageListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 主页介绍 */
    homePageIntro: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 购票须知 */
    ticketPolicy: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IWeChatHomePageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.homePageIntro = data["homePageIntro"];
            this.focusPicture = data["focusPicture"];
            this.ticketPolicy = data["ticketPolicy"];
            this.isEnable = data["isEnable"];
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WeChatHomePageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatHomePageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["homePageIntro"] = this.homePageIntro;
        data["focusPicture"] = this.focusPicture;
        data["ticketPolicy"] = this.ticketPolicy;
        data["isEnable"] = this.isEnable;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeChatHomePageListDto {
        const json = this.toJSON();
        let result = new WeChatHomePageListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.WeChatHomePage */
export interface IWeChatHomePageListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 主页介绍 */
    homePageIntro: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 购票须知 */
    ticketPolicy: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetWeChatHomePageForEditOutput implements IGetWeChatHomePageForEditOutput {
    weChatHomePage: WeChatHomePageEditDto;

    constructor(data?: IGetWeChatHomePageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.weChatHomePage = data["weChatHomePage"] ? WeChatHomePageEditDto.fromJS(data["weChatHomePage"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWeChatHomePageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWeChatHomePageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weChatHomePage"] = this.weChatHomePage ? this.weChatHomePage.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWeChatHomePageForEditOutput {
        const json = this.toJSON();
        let result = new GetWeChatHomePageForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetWeChatHomePageForEditOutput {
    weChatHomePage: WeChatHomePageEditDto;
}

export class PagedResultDtoOfWeChatHomePageListDto implements IPagedResultDtoOfWeChatHomePageListDto {
    totalCount: number;
    items: WeChatHomePageListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWeChatHomePageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WeChatHomePageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWeChatHomePageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWeChatHomePageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWeChatHomePageListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWeChatHomePageListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWeChatHomePageListDto {
    totalCount: number;
    items: WeChatHomePageListDto[] | undefined;
}

export class UploadWeChatPictureResultDto implements IUploadWeChatPictureResultDto {
    uri: string | undefined;

    constructor(data?: IUploadWeChatPictureResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uri = data["uri"];
        }
    }

    static fromJS(data: any): UploadWeChatPictureResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadWeChatPictureResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        return data; 
    }

    clone(): UploadWeChatPictureResultDto {
        const json = this.toJSON();
        let result = new UploadWeChatPictureResultDto();
        result.init(json);
        return result;
    }
}

export interface IUploadWeChatPictureResultDto {
    uri: string | undefined;
}

export class GetImageTextMaterialsInput implements IGetImageTextMaterialsInput {
    appId: string | undefined;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetImageTextMaterialsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetImageTextMaterialsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetImageTextMaterialsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetImageTextMaterialsInput {
        const json = this.toJSON();
        let result = new GetImageTextMaterialsInput();
        result.init(json);
        return result;
    }
}

export interface IGetImageTextMaterialsInput {
    appId: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class Media_News_Content_Item implements IMedia_News_Content_Item {
    url: string | undefined;
    thumb_url: string | undefined;
    thumb_media_id: string | undefined;
    author: string | undefined;
    title: string | undefined;
    content_source_url: string | undefined;
    content: string | undefined;
    digest: string | undefined;
    show_cover_pic: string | undefined;
    need_open_comment: number;
    only_fans_can_comment: number;

    constructor(data?: IMedia_News_Content_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.url = data["url"];
            this.thumb_url = data["thumb_url"];
            this.thumb_media_id = data["thumb_media_id"];
            this.author = data["author"];
            this.title = data["title"];
            this.content_source_url = data["content_source_url"];
            this.content = data["content"];
            this.digest = data["digest"];
            this.show_cover_pic = data["show_cover_pic"];
            this.need_open_comment = data["need_open_comment"];
            this.only_fans_can_comment = data["only_fans_can_comment"];
        }
    }

    static fromJS(data: any): Media_News_Content_Item {
        data = typeof data === 'object' ? data : {};
        let result = new Media_News_Content_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        data["thumb_url"] = this.thumb_url;
        data["thumb_media_id"] = this.thumb_media_id;
        data["author"] = this.author;
        data["title"] = this.title;
        data["content_source_url"] = this.content_source_url;
        data["content"] = this.content;
        data["digest"] = this.digest;
        data["show_cover_pic"] = this.show_cover_pic;
        data["need_open_comment"] = this.need_open_comment;
        data["only_fans_can_comment"] = this.only_fans_can_comment;
        return data; 
    }

    clone(): Media_News_Content_Item {
        const json = this.toJSON();
        let result = new Media_News_Content_Item();
        result.init(json);
        return result;
    }
}

export interface IMedia_News_Content_Item {
    url: string | undefined;
    thumb_url: string | undefined;
    thumb_media_id: string | undefined;
    author: string | undefined;
    title: string | undefined;
    content_source_url: string | undefined;
    content: string | undefined;
    digest: string | undefined;
    show_cover_pic: string | undefined;
    need_open_comment: number;
    only_fans_can_comment: number;
}

export class Media_News_Content implements IMedia_News_Content {
    news_item: Media_News_Content_Item[] | undefined;

    constructor(data?: IMedia_News_Content) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["news_item"] && data["news_item"].constructor === Array) {
                this.news_item = [] as any;
                for (let item of data["news_item"])
                    this.news_item.push(Media_News_Content_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Media_News_Content {
        data = typeof data === 'object' ? data : {};
        let result = new Media_News_Content();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.news_item && this.news_item.constructor === Array) {
            data["news_item"] = [];
            for (let item of this.news_item)
                data["news_item"].push(item.toJSON());
        }
        return data; 
    }

    clone(): Media_News_Content {
        const json = this.toJSON();
        let result = new Media_News_Content();
        result.init(json);
        return result;
    }
}

export interface IMedia_News_Content {
    news_item: Media_News_Content_Item[] | undefined;
}

export class MediaList_News_Item implements IMediaList_News_Item {
    media_id: string | undefined;
    content: Media_News_Content;
    update_time: number;

    constructor(data?: IMediaList_News_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.media_id = data["media_id"];
            this.content = data["content"] ? Media_News_Content.fromJS(data["content"]) : <any>undefined;
            this.update_time = data["update_time"];
        }
    }

    static fromJS(data: any): MediaList_News_Item {
        data = typeof data === 'object' ? data : {};
        let result = new MediaList_News_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["media_id"] = this.media_id;
        data["content"] = this.content ? this.content.toJSON() : <any>undefined;
        data["update_time"] = this.update_time;
        return data; 
    }

    clone(): MediaList_News_Item {
        const json = this.toJSON();
        let result = new MediaList_News_Item();
        result.init(json);
        return result;
    }
}

export interface IMediaList_News_Item {
    media_id: string | undefined;
    content: Media_News_Content;
    update_time: number;
}

export class PagedResultDtoOfMediaList_News_Item implements IPagedResultDtoOfMediaList_News_Item {
    totalCount: number;
    items: MediaList_News_Item[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaList_News_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MediaList_News_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaList_News_Item {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaList_News_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMediaList_News_Item {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMediaList_News_Item();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMediaList_News_Item {
    totalCount: number;
    items: MediaList_News_Item[] | undefined;
}

export enum UploadMediaFileType {
    Image = <any>"image", 
    Voice = <any>"voice", 
    Video = <any>"video", 
    Thumb = <any>"thumb", 
    News = <any>"news", 
}

export class GetOtherMaterialsInput implements IGetOtherMaterialsInput {
    appId: string | undefined;
    materialType: UploadMediaFileType;
    maxResultCount: number;
    skipCount: number;

    constructor(data?: IGetOtherMaterialsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            this.materialType = data["materialType"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
        }
    }

    static fromJS(data: any): GetOtherMaterialsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOtherMaterialsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["materialType"] = this.materialType;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data; 
    }

    clone(): GetOtherMaterialsInput {
        const json = this.toJSON();
        let result = new GetOtherMaterialsInput();
        result.init(json);
        return result;
    }
}

export interface IGetOtherMaterialsInput {
    appId: string | undefined;
    materialType: UploadMediaFileType;
    maxResultCount: number;
    skipCount: number;
}

export class MediaList_Others_Item implements IMediaList_Others_Item {
    media_id: string | undefined;
    name: string | undefined;
    update_time: number;
    url: string | undefined;

    constructor(data?: IMediaList_Others_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.media_id = data["media_id"];
            this.name = data["name"];
            this.update_time = data["update_time"];
            this.url = data["url"];
        }
    }

    static fromJS(data: any): MediaList_Others_Item {
        data = typeof data === 'object' ? data : {};
        let result = new MediaList_Others_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["media_id"] = this.media_id;
        data["name"] = this.name;
        data["update_time"] = this.update_time;
        data["url"] = this.url;
        return data; 
    }

    clone(): MediaList_Others_Item {
        const json = this.toJSON();
        let result = new MediaList_Others_Item();
        result.init(json);
        return result;
    }
}

export interface IMediaList_Others_Item {
    media_id: string | undefined;
    name: string | undefined;
    update_time: number;
    url: string | undefined;
}

export class PagedResultDtoOfMediaList_Others_Item implements IPagedResultDtoOfMediaList_Others_Item {
    totalCount: number;
    items: MediaList_Others_Item[] | undefined;

    constructor(data?: IPagedResultDtoOfMediaList_Others_Item) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(MediaList_Others_Item.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMediaList_Others_Item {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMediaList_Others_Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfMediaList_Others_Item {
        const json = this.toJSON();
        let result = new PagedResultDtoOfMediaList_Others_Item();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfMediaList_Others_Item {
    totalCount: number;
    items: MediaList_Others_Item[] | undefined;
}

export class NewsInfoItem implements INewsInfoItem {
    title: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    show_cover: number;
    cover_url: string | undefined;
    content_url: string | undefined;
    source_url: string | undefined;

    constructor(data?: INewsInfoItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.author = data["author"];
            this.digest = data["digest"];
            this.show_cover = data["show_cover"];
            this.cover_url = data["cover_url"];
            this.content_url = data["content_url"];
            this.source_url = data["source_url"];
        }
    }

    static fromJS(data: any): NewsInfoItem {
        data = typeof data === 'object' ? data : {};
        let result = new NewsInfoItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["author"] = this.author;
        data["digest"] = this.digest;
        data["show_cover"] = this.show_cover;
        data["cover_url"] = this.cover_url;
        data["content_url"] = this.content_url;
        data["source_url"] = this.source_url;
        return data; 
    }

    clone(): NewsInfoItem {
        const json = this.toJSON();
        let result = new NewsInfoItem();
        result.init(json);
        return result;
    }
}

export interface INewsInfoItem {
    title: string | undefined;
    author: string | undefined;
    digest: string | undefined;
    show_cover: number;
    cover_url: string | undefined;
    content_url: string | undefined;
    source_url: string | undefined;
}

export class NewsInfo implements INewsInfo {
    list: NewsInfoItem[] | undefined;

    constructor(data?: INewsInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["list"] && data["list"].constructor === Array) {
                this.list = [] as any;
                for (let item of data["list"])
                    this.list.push(NewsInfoItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewsInfo {
        data = typeof data === 'object' ? data : {};
        let result = new NewsInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.list && this.list.constructor === Array) {
            data["list"] = [];
            for (let item of this.list)
                data["list"].push(item.toJSON());
        }
        return data; 
    }

    clone(): NewsInfo {
        const json = this.toJSON();
        let result = new NewsInfo();
        result.init(json);
        return result;
    }
}

export interface INewsInfo {
    list: NewsInfoItem[] | undefined;
}

export class MenuFull_RootButton implements IMenuFull_RootButton {
    type: string | undefined;
    key: string | undefined;
    name: string | undefined;
    url: string | undefined;
    news_info: NewsInfo;
    appid: string | undefined;
    pagepath: string | undefined;
    media_id: string | undefined;
    sub_button: MenuFull_RootButton[] | undefined;

    constructor(data?: IMenuFull_RootButton) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.key = data["key"];
            this.name = data["name"];
            this.url = data["url"];
            this.news_info = data["news_info"] ? NewsInfo.fromJS(data["news_info"]) : <any>undefined;
            this.appid = data["appid"];
            this.pagepath = data["pagepath"];
            this.media_id = data["media_id"];
            if (data["sub_button"] && data["sub_button"].constructor === Array) {
                this.sub_button = [] as any;
                for (let item of data["sub_button"])
                    this.sub_button.push(MenuFull_RootButton.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MenuFull_RootButton {
        data = typeof data === 'object' ? data : {};
        let result = new MenuFull_RootButton();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["key"] = this.key;
        data["name"] = this.name;
        data["url"] = this.url;
        data["news_info"] = this.news_info ? this.news_info.toJSON() : <any>undefined;
        data["appid"] = this.appid;
        data["pagepath"] = this.pagepath;
        data["media_id"] = this.media_id;
        if (this.sub_button && this.sub_button.constructor === Array) {
            data["sub_button"] = [];
            for (let item of this.sub_button)
                data["sub_button"].push(item.toJSON());
        }
        return data; 
    }

    clone(): MenuFull_RootButton {
        const json = this.toJSON();
        let result = new MenuFull_RootButton();
        result.init(json);
        return result;
    }
}

export interface IMenuFull_RootButton {
    type: string | undefined;
    key: string | undefined;
    name: string | undefined;
    url: string | undefined;
    news_info: NewsInfo;
    appid: string | undefined;
    pagepath: string | undefined;
    media_id: string | undefined;
    sub_button: MenuFull_RootButton[] | undefined;
}

export class MenuMatchRule implements IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;

    constructor(data?: IMenuMatchRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tag_id = data["tag_id"];
            this.group_id = data["group_id"];
            this.sex = data["sex"];
            this.country = data["country"];
            this.province = data["province"];
            this.city = data["city"];
            this.client_platform_type = data["client_platform_type"];
            this.language = data["language"];
        }
    }

    static fromJS(data: any): MenuMatchRule {
        data = typeof data === 'object' ? data : {};
        let result = new MenuMatchRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tag_id"] = this.tag_id;
        data["group_id"] = this.group_id;
        data["sex"] = this.sex;
        data["country"] = this.country;
        data["province"] = this.province;
        data["city"] = this.city;
        data["client_platform_type"] = this.client_platform_type;
        data["language"] = this.language;
        return data; 
    }

    clone(): MenuMatchRule {
        const json = this.toJSON();
        let result = new MenuMatchRule();
        result.init(json);
        return result;
    }
}

export interface IMenuMatchRule {
    tag_id: string | undefined;
    group_id: string | undefined;
    sex: string | undefined;
    country: string | undefined;
    province: string | undefined;
    city: string | undefined;
    client_platform_type: string | undefined;
    language: string | undefined;
}

/** 创建或编辑菜单 */
export class CreateOrEditWechatMenuInput implements ICreateOrEditWechatMenuInput {
    /** 应用key */
    appId: string | undefined;
    /** 菜单数据结构 */
    menu: MenuFull_RootButton[] | undefined;
    matchRule: MenuMatchRule;

    constructor(data?: ICreateOrEditWechatMenuInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.appId = data["appId"];
            if (data["menu"] && data["menu"].constructor === Array) {
                this.menu = [] as any;
                for (let item of data["menu"])
                    this.menu.push(MenuFull_RootButton.fromJS(item));
            }
            this.matchRule = data["matchRule"] ? MenuMatchRule.fromJS(data["matchRule"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateOrEditWechatMenuInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWechatMenuInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        if (this.menu && this.menu.constructor === Array) {
            data["menu"] = [];
            for (let item of this.menu)
                data["menu"].push(item.toJSON());
        }
        data["matchRule"] = this.matchRule ? this.matchRule.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrEditWechatMenuInput {
        const json = this.toJSON();
        let result = new CreateOrEditWechatMenuInput();
        result.init(json);
        return result;
    }
}

/** 创建或编辑菜单 */
export interface ICreateOrEditWechatMenuInput {
    /** 应用key */
    appId: string | undefined;
    /** 菜单数据结构 */
    menu: MenuFull_RootButton[] | undefined;
    matchRule: MenuMatchRule;
}

export class GetWechatMenuForEditOutput implements IGetWechatMenuForEditOutput {
    /** 默认菜单
(单独对象,数据结构参照 MenuFull_ButtonGroup) */
    menu: Menu2 | undefined;
    /** 有个性化菜单时显示。最新的在最前。
(集合 数据结构参照 MenuFull_ConditionalButtonGroup) */
    conditionalmenu: Conditionalmenu | undefined;
    /** 菜单类型 */
    menuTypeList: KeyValuePairOfStringString[] | undefined;

    constructor(data?: IGetWechatMenuForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.menu = data["menu"] ? Menu2.fromJS(data["menu"]) : <any>undefined;
            this.conditionalmenu = data["conditionalmenu"] ? Conditionalmenu.fromJS(data["conditionalmenu"]) : <any>undefined;
            if (data["menuTypeList"] && data["menuTypeList"].constructor === Array) {
                this.menuTypeList = [] as any;
                for (let item of data["menuTypeList"])
                    this.menuTypeList.push(KeyValuePairOfStringString.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetWechatMenuForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWechatMenuForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["conditionalmenu"] = this.conditionalmenu ? this.conditionalmenu.toJSON() : <any>undefined;
        if (this.menuTypeList && this.menuTypeList.constructor === Array) {
            data["menuTypeList"] = [];
            for (let item of this.menuTypeList)
                data["menuTypeList"].push(item.toJSON());
        }
        return data; 
    }

    clone(): GetWechatMenuForEditOutput {
        const json = this.toJSON();
        let result = new GetWechatMenuForEditOutput();
        result.init(json);
        return result;
    }
}

export interface IGetWechatMenuForEditOutput {
    /** 默认菜单
(单独对象,数据结构参照 MenuFull_ButtonGroup) */
    menu: Menu2 | undefined;
    /** 有个性化菜单时显示。最新的在最前。
(集合 数据结构参照 MenuFull_ConditionalButtonGroup) */
    conditionalmenu: Conditionalmenu | undefined;
    /** 菜单类型 */
    menuTypeList: KeyValuePairOfStringString[] | undefined;
}

/** 的列表DTO Yozeev.BusinessLogic.Common.WeChatScenicSpot */
export class WeChatScenicSpotEditDto implements IWeChatScenicSpotEditDto {
    /** Id */
    id: number | undefined;
    /** 景点名称 */
    scenicSpotName: string | undefined;
    /** 景点封面图 */
    coverPicture: string | undefined;
    /** 景点地址 */
    scenicSpotAddr: string | undefined;
    /** 开放时间 */
    openTime: moment.Moment;
    /** 入团方式 */
    smokedWay: string | undefined;
    /** 预定时间 */
    scheduledTime: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 是否启用 */
    isEnable: boolean;

    constructor(data?: IWeChatScenicSpotEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.scenicSpotName = data["scenicSpotName"];
            this.coverPicture = data["coverPicture"];
            this.scenicSpotAddr = data["scenicSpotAddr"];
            this.openTime = data["openTime"] ? moment(data["openTime"].toString()) : <any>undefined;
            this.smokedWay = data["smokedWay"];
            this.scheduledTime = data["scheduledTime"];
            this.focusPicture = data["focusPicture"];
            this.isEnable = data["isEnable"];
        }
    }

    static fromJS(data: any): WeChatScenicSpotEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatScenicSpotEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["scenicSpotName"] = this.scenicSpotName;
        data["coverPicture"] = this.coverPicture;
        data["scenicSpotAddr"] = this.scenicSpotAddr;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>undefined;
        data["smokedWay"] = this.smokedWay;
        data["scheduledTime"] = this.scheduledTime;
        data["focusPicture"] = this.focusPicture;
        data["isEnable"] = this.isEnable;
        return data; 
    }

    clone(): WeChatScenicSpotEditDto {
        const json = this.toJSON();
        let result = new WeChatScenicSpotEditDto();
        result.init(json);
        return result;
    }
}

/** 的列表DTO Yozeev.BusinessLogic.Common.WeChatScenicSpot */
export interface IWeChatScenicSpotEditDto {
    /** Id */
    id: number | undefined;
    /** 景点名称 */
    scenicSpotName: string | undefined;
    /** 景点封面图 */
    coverPicture: string | undefined;
    /** 景点地址 */
    scenicSpotAddr: string | undefined;
    /** 开放时间 */
    openTime: moment.Moment;
    /** 入团方式 */
    smokedWay: string | undefined;
    /** 预定时间 */
    scheduledTime: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
}

export class CreateOrUpdateWeChatScenicSpotInput implements ICreateOrUpdateWeChatScenicSpotInput {
    weChatScenicSpot: WeChatScenicSpotEditDto;

    constructor(data?: ICreateOrUpdateWeChatScenicSpotInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.weChatScenicSpot = new WeChatScenicSpotEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.weChatScenicSpot = data["weChatScenicSpot"] ? WeChatScenicSpotEditDto.fromJS(data["weChatScenicSpot"]) : new WeChatScenicSpotEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateWeChatScenicSpotInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateWeChatScenicSpotInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weChatScenicSpot"] = this.weChatScenicSpot ? this.weChatScenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): CreateOrUpdateWeChatScenicSpotInput {
        const json = this.toJSON();
        let result = new CreateOrUpdateWeChatScenicSpotInput();
        result.init(json);
        return result;
    }
}

export interface ICreateOrUpdateWeChatScenicSpotInput {
    weChatScenicSpot: WeChatScenicSpotEditDto;
}

/** 关联的标价 */
export class WeChatTicketPrice implements IWeChatTicketPrice {
    /** 小程序景点票价ID */
    ticketPriceId: number | undefined;
    /** 小程序票名称 */
    ticketName: string | undefined;
    /** 小程序票价 */
    price: number;

    constructor(data?: IWeChatTicketPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ticketPriceId = data["ticketPriceId"];
            this.ticketName = data["ticketName"];
            this.price = data["price"];
        }
    }

    static fromJS(data: any): WeChatTicketPrice {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatTicketPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ticketPriceId"] = this.ticketPriceId;
        data["ticketName"] = this.ticketName;
        data["price"] = this.price;
        return data; 
    }

    clone(): WeChatTicketPrice {
        const json = this.toJSON();
        let result = new WeChatTicketPrice();
        result.init(json);
        return result;
    }
}

/** 关联的标价 */
export interface IWeChatTicketPrice {
    /** 小程序景点票价ID */
    ticketPriceId: number | undefined;
    /** 小程序票名称 */
    ticketName: string | undefined;
    /** 小程序票价 */
    price: number;
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.WeChatScenicSpot */
export class WeChatScenicSpotListDto implements IWeChatScenicSpotListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 景点名称 */
    scenicSpotName: string | undefined;
    /** 景点封面图 */
    coverPicture: string | undefined;
    /** 景点地址 */
    scenicSpotAddr: string | undefined;
    /** 开放时间 */
    openTime: moment.Moment;
    /** 入团方式 */
    smokedWay: string | undefined;
    /** 预定时间 */
    scheduledTime: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 上级景点标识 */
    parentId: number | undefined;
    parent: WeChatScenicSpot;
    /** 关联的票价 */
    ticketPrices: WeChatTicketPrice[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;

    constructor(data?: IWeChatScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.branchId = data["branchId"];
            this.scenicSpotName = data["scenicSpotName"];
            this.coverPicture = data["coverPicture"];
            this.scenicSpotAddr = data["scenicSpotAddr"];
            this.openTime = data["openTime"] ? moment(data["openTime"].toString()) : <any>undefined;
            this.smokedWay = data["smokedWay"];
            this.scheduledTime = data["scheduledTime"];
            this.focusPicture = data["focusPicture"];
            this.isEnable = data["isEnable"];
            this.parentId = data["parentId"];
            this.parent = data["parent"] ? WeChatScenicSpot.fromJS(data["parent"]) : <any>undefined;
            if (data["ticketPrices"] && data["ticketPrices"].constructor === Array) {
                this.ticketPrices = [] as any;
                for (let item of data["ticketPrices"])
                    this.ticketPrices.push(WeChatTicketPrice.fromJS(item));
            }
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.branch = data["branch"] ? Branch.fromJS(data["branch"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WeChatScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WeChatScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["branchId"] = this.branchId;
        data["scenicSpotName"] = this.scenicSpotName;
        data["coverPicture"] = this.coverPicture;
        data["scenicSpotAddr"] = this.scenicSpotAddr;
        data["openTime"] = this.openTime ? this.openTime.toISOString() : <any>undefined;
        data["smokedWay"] = this.smokedWay;
        data["scheduledTime"] = this.scheduledTime;
        data["focusPicture"] = this.focusPicture;
        data["isEnable"] = this.isEnable;
        data["parentId"] = this.parentId;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        if (this.ticketPrices && this.ticketPrices.constructor === Array) {
            data["ticketPrices"] = [];
            for (let item of this.ticketPrices)
                data["ticketPrices"].push(item.toJSON());
        }
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["branch"] = this.branch ? this.branch.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }

    clone(): WeChatScenicSpotListDto {
        const json = this.toJSON();
        let result = new WeChatScenicSpotListDto();
        result.init(json);
        return result;
    }
}

/** 的编辑DTO Yozeev.BusinessLogic.Common.WeChatScenicSpot */
export interface IWeChatScenicSpotListDto {
    /** BranchId */
    branchId: number | undefined;
    /** 景点名称 */
    scenicSpotName: string | undefined;
    /** 景点封面图 */
    coverPicture: string | undefined;
    /** 景点地址 */
    scenicSpotAddr: string | undefined;
    /** 开放时间 */
    openTime: moment.Moment;
    /** 入团方式 */
    smokedWay: string | undefined;
    /** 预定时间 */
    scheduledTime: string | undefined;
    /** 焦点图 */
    focusPicture: string | undefined;
    /** 是否启用 */
    isEnable: boolean;
    /** 上级景点标识 */
    parentId: number | undefined;
    parent: WeChatScenicSpot;
    /** 关联的票价 */
    ticketPrices: WeChatTicketPrice[] | undefined;
    creatorUser: User;
    branch: Branch;
    creationTime: moment.Moment;
    creatorUserId: number | undefined;
    id: number;
}

/** 读取可编辑的Dto */
export class GetWeChatScenicSpotForEditOutput implements IGetWeChatScenicSpotForEditOutput {
    weChatScenicSpot: WeChatScenicSpotEditDto;

    constructor(data?: IGetWeChatScenicSpotForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.weChatScenicSpot = data["weChatScenicSpot"] ? WeChatScenicSpotEditDto.fromJS(data["weChatScenicSpot"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWeChatScenicSpotForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWeChatScenicSpotForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["weChatScenicSpot"] = this.weChatScenicSpot ? this.weChatScenicSpot.toJSON() : <any>undefined;
        return data; 
    }

    clone(): GetWeChatScenicSpotForEditOutput {
        const json = this.toJSON();
        let result = new GetWeChatScenicSpotForEditOutput();
        result.init(json);
        return result;
    }
}

/** 读取可编辑的Dto */
export interface IGetWeChatScenicSpotForEditOutput {
    weChatScenicSpot: WeChatScenicSpotEditDto;
}

export class PagedResultDtoOfWeChatScenicSpotListDto implements IPagedResultDtoOfWeChatScenicSpotListDto {
    totalCount: number;
    items: WeChatScenicSpotListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWeChatScenicSpotListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(WeChatScenicSpotListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWeChatScenicSpotListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWeChatScenicSpotListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfWeChatScenicSpotListDto {
        const json = this.toJSON();
        let result = new PagedResultDtoOfWeChatScenicSpotListDto();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfWeChatScenicSpotListDto {
    totalCount: number;
    items: WeChatScenicSpotListDto[] | undefined;
}

/** 订单来源统计 */
export class SalesByOrderSourceResultDto implements ISalesByOrderSourceResultDto {
    source: Source;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;

    constructor(data?: ISalesByOrderSourceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.source = data["source"] ? Source.fromJS(data["source"]) : <any>undefined;
            this.saleQuantity = data["saleQuantity"];
            this.refundQuantity = data["refundQuantity"];
            this.subtotalQuantity = data["subtotalQuantity"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.subtotalAmount = data["subtotalAmount"];
        }
    }

    static fromJS(data: any): SalesByOrderSourceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesByOrderSourceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        data["saleQuantity"] = this.saleQuantity;
        data["refundQuantity"] = this.refundQuantity;
        data["subtotalQuantity"] = this.subtotalQuantity;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["subtotalAmount"] = this.subtotalAmount;
        return data; 
    }

    clone(): SalesByOrderSourceResultDto {
        const json = this.toJSON();
        let result = new SalesByOrderSourceResultDto();
        result.init(json);
        return result;
    }
}

/** 订单来源统计 */
export interface ISalesByOrderSourceResultDto {
    source: Source;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;
}

export class StatsPagedResultDtoOfSalesByOrderSourceResultDto implements IStatsPagedResultDtoOfSalesByOrderSourceResultDto {
    total: SalesByOrderSourceResultDto;
    filters: { [key: string] : Anonymous5[]; } | undefined;
    totalCount: number;
    items: SalesByOrderSourceResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesByOrderSourceResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesByOrderSourceResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous5.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesByOrderSourceResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesByOrderSourceResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesByOrderSourceResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesByOrderSourceResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesByOrderSourceResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesByOrderSourceResultDto {
    total: SalesByOrderSourceResultDto;
    filters: { [key: string] : Anonymous5[]; } | undefined;
    totalCount: number;
    items: SalesByOrderSourceResultDto[] | undefined;
}

/** 团体售票统计 */
export class SalesByOrganizationResultDto implements ISalesByOrganizationResultDto {
    organization: Organization;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;

    constructor(data?: ISalesByOrganizationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organization = data["organization"] ? Organization.fromJS(data["organization"]) : <any>undefined;
            this.saleQuantity = data["saleQuantity"];
            this.refundQuantity = data["refundQuantity"];
            this.subtotalQuantity = data["subtotalQuantity"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.subtotalAmount = data["subtotalAmount"];
        }
    }

    static fromJS(data: any): SalesByOrganizationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesByOrganizationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organization"] = this.organization ? this.organization.toJSON() : <any>undefined;
        data["saleQuantity"] = this.saleQuantity;
        data["refundQuantity"] = this.refundQuantity;
        data["subtotalQuantity"] = this.subtotalQuantity;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["subtotalAmount"] = this.subtotalAmount;
        return data; 
    }

    clone(): SalesByOrganizationResultDto {
        const json = this.toJSON();
        let result = new SalesByOrganizationResultDto();
        result.init(json);
        return result;
    }
}

/** 团体售票统计 */
export interface ISalesByOrganizationResultDto {
    organization: Organization;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;
}

export class StatsPagedResultDtoOfSalesByOrganizationResultDto implements IStatsPagedResultDtoOfSalesByOrganizationResultDto {
    total: SalesByOrganizationResultDto;
    filters: { [key: string] : Anonymous6[]; } | undefined;
    totalCount: number;
    items: SalesByOrganizationResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesByOrganizationResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesByOrganizationResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous6.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesByOrganizationResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesByOrganizationResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesByOrganizationResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesByOrganizationResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesByOrganizationResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesByOrganizationResultDto {
    total: SalesByOrganizationResultDto;
    filters: { [key: string] : Anonymous6[]; } | undefined;
    totalCount: number;
    items: SalesByOrganizationResultDto[] | undefined;
}

/** 支付方式统计 */
export class SalesByPayMethodResultDto implements ISalesByPayMethodResultDto {
    payMethod: PayMethod;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;

    constructor(data?: ISalesByPayMethodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.payMethod = data["payMethod"] ? PayMethod.fromJS(data["payMethod"]) : <any>undefined;
            this.saleQuantity = data["saleQuantity"];
            this.refundQuantity = data["refundQuantity"];
            this.subtotalQuantity = data["subtotalQuantity"];
            this.saleAmount = data["saleAmount"];
            this.refundAmount = data["refundAmount"];
            this.subtotalAmount = data["subtotalAmount"];
        }
    }

    static fromJS(data: any): SalesByPayMethodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesByPayMethodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["payMethod"] = this.payMethod ? this.payMethod.toJSON() : <any>undefined;
        data["saleQuantity"] = this.saleQuantity;
        data["refundQuantity"] = this.refundQuantity;
        data["subtotalQuantity"] = this.subtotalQuantity;
        data["saleAmount"] = this.saleAmount;
        data["refundAmount"] = this.refundAmount;
        data["subtotalAmount"] = this.subtotalAmount;
        return data; 
    }

    clone(): SalesByPayMethodResultDto {
        const json = this.toJSON();
        let result = new SalesByPayMethodResultDto();
        result.init(json);
        return result;
    }
}

/** 支付方式统计 */
export interface ISalesByPayMethodResultDto {
    payMethod: PayMethod;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 售票金额 */
    saleAmount: number;
    /** 退票金额 */
    refundAmount: number;
    /** 金额小计 */
    subtotalAmount: number;
}

export class StatsPagedResultDtoOfSalesByPayMethodResultDto implements IStatsPagedResultDtoOfSalesByPayMethodResultDto {
    total: SalesByPayMethodResultDto;
    filters: { [key: string] : Anonymous7[]; } | undefined;
    totalCount: number;
    items: SalesByPayMethodResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesByPayMethodResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesByPayMethodResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous7.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesByPayMethodResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesByPayMethodResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesByPayMethodResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesByPayMethodResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesByPayMethodResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesByPayMethodResultDto {
    total: SalesByPayMethodResultDto;
    filters: { [key: string] : Anonymous7[]; } | undefined;
    totalCount: number;
    items: SalesByPayMethodResultDto[] | undefined;
}

/** 售票员售票统计 */
export class SalesBySellerResultDto implements ISalesBySellerResultDto {
    seller: User;
    /** 现金售票数量 */
    cashSaleQuantity: number;
    /** 现金退票数量 */
    cashRefundQuantity: number;
    /** 现金数量小计 */
    cashSubtotalQuantity: number;
    /** 现金售票金额 */
    cashSaleAmount: number;
    /** 现金退票金额 */
    cashRefundAmount: number;
    /** 现金金额小计 */
    cashSubtotalAmount: number;
    /** 刷卡售票数量 */
    cardSaleQuantity: number;
    /** 刷卡退票数量 */
    cardRefundQuantity: number;
    /** 刷卡数量小计 */
    cardSubtotalQuantity: number;
    /** 刷卡售票金额 */
    cardSaleAmount: number;
    /** 刷卡退票金额 */
    cardRefundAmount: number;
    /** 刷卡金额小计 */
    cardSubtotalAmount: number;
    /** 微信售票数量 */
    weChatSaleQuantity: number;
    /** 微信退票数量 */
    weChatRefundQuantity: number;
    /** 微信数量小计 */
    weChatSubtotalQuantity: number;
    /** 微信售票金额 */
    weChatSaleAmount: number;
    /** 微信退票金额 */
    weChatRefundAmount: number;
    /** 微信金额小计 */
    weChatSubtotalAmount: number;
    /** 支付宝售票数量 */
    alipaySaleQuantity: number;
    /** 支付宝退票数量 */
    alipayRefundQuantity: number;
    /** 支付宝数量小计 */
    alipaySubtotalQuantity: number;
    /** 支付宝售票金额 */
    alipaySaleAmount: number;
    /** 支付宝退票金额 */
    alipayRefundAmount: number;
    /** 支付宝金额小计 */
    alipaySubtotalAmount: number;
    /** 总数量 */
    totalQuantity: number;
    /** 总金额 */
    totalAmount: number;

    constructor(data?: ISalesBySellerResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seller = data["seller"] ? User.fromJS(data["seller"]) : <any>undefined;
            this.cashSaleQuantity = data["cashSaleQuantity"];
            this.cashRefundQuantity = data["cashRefundQuantity"];
            this.cashSubtotalQuantity = data["cashSubtotalQuantity"];
            this.cashSaleAmount = data["cashSaleAmount"];
            this.cashRefundAmount = data["cashRefundAmount"];
            this.cashSubtotalAmount = data["cashSubtotalAmount"];
            this.cardSaleQuantity = data["cardSaleQuantity"];
            this.cardRefundQuantity = data["cardRefundQuantity"];
            this.cardSubtotalQuantity = data["cardSubtotalQuantity"];
            this.cardSaleAmount = data["cardSaleAmount"];
            this.cardRefundAmount = data["cardRefundAmount"];
            this.cardSubtotalAmount = data["cardSubtotalAmount"];
            this.weChatSaleQuantity = data["weChatSaleQuantity"];
            this.weChatRefundQuantity = data["weChatRefundQuantity"];
            this.weChatSubtotalQuantity = data["weChatSubtotalQuantity"];
            this.weChatSaleAmount = data["weChatSaleAmount"];
            this.weChatRefundAmount = data["weChatRefundAmount"];
            this.weChatSubtotalAmount = data["weChatSubtotalAmount"];
            this.alipaySaleQuantity = data["alipaySaleQuantity"];
            this.alipayRefundQuantity = data["alipayRefundQuantity"];
            this.alipaySubtotalQuantity = data["alipaySubtotalQuantity"];
            this.alipaySaleAmount = data["alipaySaleAmount"];
            this.alipayRefundAmount = data["alipayRefundAmount"];
            this.alipaySubtotalAmount = data["alipaySubtotalAmount"];
            this.totalQuantity = data["totalQuantity"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): SalesBySellerResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesBySellerResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["cashSaleQuantity"] = this.cashSaleQuantity;
        data["cashRefundQuantity"] = this.cashRefundQuantity;
        data["cashSubtotalQuantity"] = this.cashSubtotalQuantity;
        data["cashSaleAmount"] = this.cashSaleAmount;
        data["cashRefundAmount"] = this.cashRefundAmount;
        data["cashSubtotalAmount"] = this.cashSubtotalAmount;
        data["cardSaleQuantity"] = this.cardSaleQuantity;
        data["cardRefundQuantity"] = this.cardRefundQuantity;
        data["cardSubtotalQuantity"] = this.cardSubtotalQuantity;
        data["cardSaleAmount"] = this.cardSaleAmount;
        data["cardRefundAmount"] = this.cardRefundAmount;
        data["cardSubtotalAmount"] = this.cardSubtotalAmount;
        data["weChatSaleQuantity"] = this.weChatSaleQuantity;
        data["weChatRefundQuantity"] = this.weChatRefundQuantity;
        data["weChatSubtotalQuantity"] = this.weChatSubtotalQuantity;
        data["weChatSaleAmount"] = this.weChatSaleAmount;
        data["weChatRefundAmount"] = this.weChatRefundAmount;
        data["weChatSubtotalAmount"] = this.weChatSubtotalAmount;
        data["alipaySaleQuantity"] = this.alipaySaleQuantity;
        data["alipayRefundQuantity"] = this.alipayRefundQuantity;
        data["alipaySubtotalQuantity"] = this.alipaySubtotalQuantity;
        data["alipaySaleAmount"] = this.alipaySaleAmount;
        data["alipayRefundAmount"] = this.alipayRefundAmount;
        data["alipaySubtotalAmount"] = this.alipaySubtotalAmount;
        data["totalQuantity"] = this.totalQuantity;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): SalesBySellerResultDto {
        const json = this.toJSON();
        let result = new SalesBySellerResultDto();
        result.init(json);
        return result;
    }
}

/** 售票员售票统计 */
export interface ISalesBySellerResultDto {
    seller: User;
    /** 现金售票数量 */
    cashSaleQuantity: number;
    /** 现金退票数量 */
    cashRefundQuantity: number;
    /** 现金数量小计 */
    cashSubtotalQuantity: number;
    /** 现金售票金额 */
    cashSaleAmount: number;
    /** 现金退票金额 */
    cashRefundAmount: number;
    /** 现金金额小计 */
    cashSubtotalAmount: number;
    /** 刷卡售票数量 */
    cardSaleQuantity: number;
    /** 刷卡退票数量 */
    cardRefundQuantity: number;
    /** 刷卡数量小计 */
    cardSubtotalQuantity: number;
    /** 刷卡售票金额 */
    cardSaleAmount: number;
    /** 刷卡退票金额 */
    cardRefundAmount: number;
    /** 刷卡金额小计 */
    cardSubtotalAmount: number;
    /** 微信售票数量 */
    weChatSaleQuantity: number;
    /** 微信退票数量 */
    weChatRefundQuantity: number;
    /** 微信数量小计 */
    weChatSubtotalQuantity: number;
    /** 微信售票金额 */
    weChatSaleAmount: number;
    /** 微信退票金额 */
    weChatRefundAmount: number;
    /** 微信金额小计 */
    weChatSubtotalAmount: number;
    /** 支付宝售票数量 */
    alipaySaleQuantity: number;
    /** 支付宝退票数量 */
    alipayRefundQuantity: number;
    /** 支付宝数量小计 */
    alipaySubtotalQuantity: number;
    /** 支付宝售票金额 */
    alipaySaleAmount: number;
    /** 支付宝退票金额 */
    alipayRefundAmount: number;
    /** 支付宝金额小计 */
    alipaySubtotalAmount: number;
    /** 总数量 */
    totalQuantity: number;
    /** 总金额 */
    totalAmount: number;
}

export class StatsPagedResultDtoOfSalesBySellerResultDto implements IStatsPagedResultDtoOfSalesBySellerResultDto {
    total: SalesBySellerResultDto;
    filters: { [key: string] : Anonymous8[]; } | undefined;
    totalCount: number;
    items: SalesBySellerResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesBySellerResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesBySellerResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous8.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesBySellerResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesBySellerResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesBySellerResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesBySellerResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesBySellerResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesBySellerResultDto {
    total: SalesBySellerResultDto;
    filters: { [key: string] : Anonymous8[]; } | undefined;
    totalCount: number;
    items: SalesBySellerResultDto[] | undefined;
}

/** 售票员日结统计 */
export class SalesBySellerDailyResultDto implements ISalesBySellerDailyResultDto {
    seller: User;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 现金售票金额 */
    cashSaleAmount: number;
    /** 刷卡售票金额 */
    cardSaleAmount: number;
    /** 微信售票金额 */
    weChatSaleAmount: number;
    /** 支付宝售票金额 */
    alipaySaleAmount: number;
    /** 销售金额小计 */
    saleSubtotalAmount: number;
    /** 现金退票金额 */
    cashRefundAmount: number;
    /** 刷卡退票金额 */
    cardRefundAmount: number;
    /** 微信退票金额 */
    weChatRefundAmount: number;
    /** 支付宝退票金额 */
    alipayRefundAmount: number;
    /** 退票金额小计 */
    refundSubtotalAmount: number;
    /** 应收总金额 */
    totalAmount: number;

    constructor(data?: ISalesBySellerDailyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.seller = data["seller"] ? User.fromJS(data["seller"]) : <any>undefined;
            this.saleQuantity = data["saleQuantity"];
            this.refundQuantity = data["refundQuantity"];
            this.subtotalQuantity = data["subtotalQuantity"];
            this.cashSaleAmount = data["cashSaleAmount"];
            this.cardSaleAmount = data["cardSaleAmount"];
            this.weChatSaleAmount = data["weChatSaleAmount"];
            this.alipaySaleAmount = data["alipaySaleAmount"];
            this.saleSubtotalAmount = data["saleSubtotalAmount"];
            this.cashRefundAmount = data["cashRefundAmount"];
            this.cardRefundAmount = data["cardRefundAmount"];
            this.weChatRefundAmount = data["weChatRefundAmount"];
            this.alipayRefundAmount = data["alipayRefundAmount"];
            this.refundSubtotalAmount = data["refundSubtotalAmount"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): SalesBySellerDailyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesBySellerDailyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seller"] = this.seller ? this.seller.toJSON() : <any>undefined;
        data["saleQuantity"] = this.saleQuantity;
        data["refundQuantity"] = this.refundQuantity;
        data["subtotalQuantity"] = this.subtotalQuantity;
        data["cashSaleAmount"] = this.cashSaleAmount;
        data["cardSaleAmount"] = this.cardSaleAmount;
        data["weChatSaleAmount"] = this.weChatSaleAmount;
        data["alipaySaleAmount"] = this.alipaySaleAmount;
        data["saleSubtotalAmount"] = this.saleSubtotalAmount;
        data["cashRefundAmount"] = this.cashRefundAmount;
        data["cardRefundAmount"] = this.cardRefundAmount;
        data["weChatRefundAmount"] = this.weChatRefundAmount;
        data["alipayRefundAmount"] = this.alipayRefundAmount;
        data["refundSubtotalAmount"] = this.refundSubtotalAmount;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }

    clone(): SalesBySellerDailyResultDto {
        const json = this.toJSON();
        let result = new SalesBySellerDailyResultDto();
        result.init(json);
        return result;
    }
}

/** 售票员日结统计 */
export interface ISalesBySellerDailyResultDto {
    seller: User;
    /** 售票数量 */
    saleQuantity: number;
    /** 退票数量 */
    refundQuantity: number;
    /** 数量小计 */
    subtotalQuantity: number;
    /** 现金售票金额 */
    cashSaleAmount: number;
    /** 刷卡售票金额 */
    cardSaleAmount: number;
    /** 微信售票金额 */
    weChatSaleAmount: number;
    /** 支付宝售票金额 */
    alipaySaleAmount: number;
    /** 销售金额小计 */
    saleSubtotalAmount: number;
    /** 现金退票金额 */
    cashRefundAmount: number;
    /** 刷卡退票金额 */
    cardRefundAmount: number;
    /** 微信退票金额 */
    weChatRefundAmount: number;
    /** 支付宝退票金额 */
    alipayRefundAmount: number;
    /** 退票金额小计 */
    refundSubtotalAmount: number;
    /** 应收总金额 */
    totalAmount: number;
}

export class StatsPagedResultDtoOfSalesBySellerDailyResultDto implements IStatsPagedResultDtoOfSalesBySellerDailyResultDto {
    total: SalesBySellerDailyResultDto;
    filters: { [key: string] : Anonymous9[]; } | undefined;
    totalCount: number;
    items: SalesBySellerDailyResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesBySellerDailyResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesBySellerDailyResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous9.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesBySellerDailyResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesBySellerDailyResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesBySellerDailyResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesBySellerDailyResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesBySellerDailyResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesBySellerDailyResultDto {
    total: SalesBySellerDailyResultDto;
    filters: { [key: string] : Anonymous9[]; } | undefined;
    totalCount: number;
    items: SalesBySellerDailyResultDto[] | undefined;
}

/** 订单信息 */
export class SalesActivityResultDto implements ISalesActivityResultDto {
    /** Id */
    id: number;
    /** 是否结账 */
    closed: boolean;
    /** 单据号 */
    activityNo: string | undefined;
    /** 订单来源 */
    sourceName: string | undefined;
    orderType: OrderTypeEnum;
    /** 订单金额 */
    totalAmount: number;
    payStatus: PayStatusEnum;
    /** 支付方式 */
    payName: string | undefined;
    /** 数量 */
    totalQuantity: number;
    /** 购票人 */
    buyer: string | undefined;
    /** 购票凭证 */
    voucherNo: string | undefined;
    /** 日期 */
    activityDate: moment.Moment;
    /** 制单人 */
    creatorUserName: string | undefined;
    /** 原单号 */
    orgActivityNo: string | undefined;

    constructor(data?: ISalesActivityResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.closed = data["closed"];
            this.activityNo = data["activityNo"];
            this.sourceName = data["sourceName"];
            this.orderType = data["orderType"];
            this.totalAmount = data["totalAmount"];
            this.payStatus = data["payStatus"];
            this.payName = data["payName"];
            this.totalQuantity = data["totalQuantity"];
            this.buyer = data["buyer"];
            this.voucherNo = data["voucherNo"];
            this.activityDate = data["activityDate"] ? moment(data["activityDate"].toString()) : <any>undefined;
            this.creatorUserName = data["creatorUserName"];
            this.orgActivityNo = data["orgActivityNo"];
        }
    }

    static fromJS(data: any): SalesActivityResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesActivityResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["closed"] = this.closed;
        data["activityNo"] = this.activityNo;
        data["sourceName"] = this.sourceName;
        data["orderType"] = this.orderType;
        data["totalAmount"] = this.totalAmount;
        data["payStatus"] = this.payStatus;
        data["payName"] = this.payName;
        data["totalQuantity"] = this.totalQuantity;
        data["buyer"] = this.buyer;
        data["voucherNo"] = this.voucherNo;
        data["activityDate"] = this.activityDate ? this.activityDate.toISOString() : <any>undefined;
        data["creatorUserName"] = this.creatorUserName;
        data["orgActivityNo"] = this.orgActivityNo;
        return data; 
    }

    clone(): SalesActivityResultDto {
        const json = this.toJSON();
        let result = new SalesActivityResultDto();
        result.init(json);
        return result;
    }
}

/** 订单信息 */
export interface ISalesActivityResultDto {
    /** Id */
    id: number;
    /** 是否结账 */
    closed: boolean;
    /** 单据号 */
    activityNo: string | undefined;
    /** 订单来源 */
    sourceName: string | undefined;
    orderType: OrderTypeEnum;
    /** 订单金额 */
    totalAmount: number;
    payStatus: PayStatusEnum;
    /** 支付方式 */
    payName: string | undefined;
    /** 数量 */
    totalQuantity: number;
    /** 购票人 */
    buyer: string | undefined;
    /** 购票凭证 */
    voucherNo: string | undefined;
    /** 日期 */
    activityDate: moment.Moment;
    /** 制单人 */
    creatorUserName: string | undefined;
    /** 原单号 */
    orgActivityNo: string | undefined;
}

export class StatsPagedResultDtoOfSalesActivityResultDto implements IStatsPagedResultDtoOfSalesActivityResultDto {
    total: SalesActivityResultDto;
    filters: { [key: string] : Anonymous10[]; } | undefined;
    totalCount: number;
    items: SalesActivityResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesActivityResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesActivityResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous10.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesActivityResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesActivityResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesActivityResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesActivityResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesActivityResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesActivityResultDto {
    total: SalesActivityResultDto;
    filters: { [key: string] : Anonymous10[]; } | undefined;
    totalCount: number;
    items: SalesActivityResultDto[] | undefined;
}

/** 订单明细 */
export class SalesActivityDetailResultDto implements ISalesActivityDetailResultDto {
    /** Id */
    id: number;
    /** 票码 */
    ticketNo: string | undefined;
    /** 票型名称 */
    ticketName: string | undefined;
    /** 可验票数 */
    checkingQuantity: number;
    /** 已验票数 */
    checkedQuantity: number;
    ticketStatus: TicketStatusEnum;
    /** 开始有效期 */
    startDateTime: moment.Moment;
    /** 结束有效期 */
    endDateTime: moment.Moment;
    /** 最后一次使用时间（检票日期） */
    checkDate: moment.Moment;

    constructor(data?: ISalesActivityDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.ticketNo = data["ticketNo"];
            this.ticketName = data["ticketName"];
            this.checkingQuantity = data["checkingQuantity"];
            this.checkedQuantity = data["checkedQuantity"];
            this.ticketStatus = data["ticketStatus"];
            this.startDateTime = data["startDateTime"] ? moment(data["startDateTime"].toString()) : <any>undefined;
            this.endDateTime = data["endDateTime"] ? moment(data["endDateTime"].toString()) : <any>undefined;
            this.checkDate = data["checkDate"] ? moment(data["checkDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SalesActivityDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesActivityDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["ticketNo"] = this.ticketNo;
        data["ticketName"] = this.ticketName;
        data["checkingQuantity"] = this.checkingQuantity;
        data["checkedQuantity"] = this.checkedQuantity;
        data["ticketStatus"] = this.ticketStatus;
        data["startDateTime"] = this.startDateTime ? this.startDateTime.toISOString() : <any>undefined;
        data["endDateTime"] = this.endDateTime ? this.endDateTime.toISOString() : <any>undefined;
        data["checkDate"] = this.checkDate ? this.checkDate.toISOString() : <any>undefined;
        return data; 
    }

    clone(): SalesActivityDetailResultDto {
        const json = this.toJSON();
        let result = new SalesActivityDetailResultDto();
        result.init(json);
        return result;
    }
}

/** 订单明细 */
export interface ISalesActivityDetailResultDto {
    /** Id */
    id: number;
    /** 票码 */
    ticketNo: string | undefined;
    /** 票型名称 */
    ticketName: string | undefined;
    /** 可验票数 */
    checkingQuantity: number;
    /** 已验票数 */
    checkedQuantity: number;
    ticketStatus: TicketStatusEnum;
    /** 开始有效期 */
    startDateTime: moment.Moment;
    /** 结束有效期 */
    endDateTime: moment.Moment;
    /** 最后一次使用时间（检票日期） */
    checkDate: moment.Moment;
}

export class StatsPagedResultDtoOfSalesActivityDetailResultDto implements IStatsPagedResultDtoOfSalesActivityDetailResultDto {
    total: SalesActivityDetailResultDto;
    filters: { [key: string] : Anonymous11[]; } | undefined;
    totalCount: number;
    items: SalesActivityDetailResultDto[] | undefined;

    constructor(data?: IStatsPagedResultDtoOfSalesActivityDetailResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"] ? SalesActivityDetailResultDto.fromJS(data["total"]) : <any>undefined;
            if (data["filters"]) {
                this.filters = {} as any;
                for (let key in data["filters"]) {
                    if (data["filters"].hasOwnProperty(key))
                        this.filters[key] = data["filters"][key] ? data["filters"][key].map((i: any) => Anonymous11.fromJS(i)) : [];
                }
            }
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(SalesActivityDetailResultDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatsPagedResultDtoOfSalesActivityDetailResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatsPagedResultDtoOfSalesActivityDetailResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total ? this.total.toJSON() : <any>undefined;
        if (this.filters) {
            data["filters"] = {};
            for (let key in this.filters) {
                if (this.filters.hasOwnProperty(key))
                    data["filters"][key] = this.filters[key];
            }
        }
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): StatsPagedResultDtoOfSalesActivityDetailResultDto {
        const json = this.toJSON();
        let result = new StatsPagedResultDtoOfSalesActivityDetailResultDto();
        result.init(json);
        return result;
    }
}

export interface IStatsPagedResultDtoOfSalesActivityDetailResultDto {
    total: SalesActivityDetailResultDto;
    filters: { [key: string] : Anonymous11[]; } | undefined;
    totalCount: number;
    items: SalesActivityDetailResultDto[] | undefined;
}

export enum ActivateType {
    NewAccount = <any>"NewAccount", 
    BindExistAccount = <any>"BindExistAccount", 
}

export class ActivateAccountModel implements IActivateAccountModel {
    emailAddress: string | undefined;
    password: string | undefined;
    userId: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    activateType: ActivateType;

    constructor(data?: IActivateAccountModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.userId = data["userId"];
            this.verificationCode = data["verificationCode"];
            this.activateType = data["activateType"];
        }
    }

    static fromJS(data: any): ActivateAccountModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["userId"] = this.userId;
        data["verificationCode"] = this.verificationCode;
        data["activateType"] = this.activateType;
        return data; 
    }

    clone(): ActivateAccountModel {
        const json = this.toJSON();
        let result = new ActivateAccountModel();
        result.init(json);
        return result;
    }
}

export interface IActivateAccountModel {
    emailAddress: string | undefined;
    password: string | undefined;
    userId: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    activateType: ActivateType;
}

export class ActivateAccountResultModel implements IActivateAccountResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;

    constructor(data?: IActivateAccountResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ActivateAccountResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateAccountResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ActivateAccountResultModel {
        const json = this.toJSON();
        let result = new ActivateAccountResultModel();
        result.init(json);
        return result;
    }
}

export interface IActivateAccountResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.verificationCode = data["verificationCode"];
            this.rememberClient = data["rememberClient"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["verificationCode"] = this.verificationCode;
        data["rememberClient"] = this.rememberClient;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }

    clone(): AuthenticateModel {
        const json = this.toJSON();
        let result = new AuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string | undefined;
    password: string | undefined;
    /** 验证码 */
    verificationCode: string | undefined;
    rememberClient: boolean;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    /** 需要进行账号绑定激活 */
    waitingForActivation: boolean;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.userId = data["userId"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.returnUrl = data["returnUrl"];
            this.waitingForActivation = data["waitingForActivation"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["userId"] = this.userId;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["returnUrl"] = this.returnUrl;
        data["waitingForActivation"] = this.waitingForActivation;
        return data; 
    }

    clone(): AuthenticateResultModel {
        const json = this.toJSON();
        let result = new AuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    userId: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    returnUrl: string | undefined;
    /** 需要进行账号绑定激活 */
    waitingForActivation: boolean;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        return data; 
    }

    clone(): ExternalAuthenticateModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string | undefined;
    providerKey: string | undefined;
    providerAccessCode: string | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    userId: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["userId"] = this.userId;
        return data; 
    }

    clone(): ExternalAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ExternalAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    userId: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams[key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }

    clone(): ExternalLoginProviderInfoModel {
        const json = this.toJSON();
        let result = new ExternalLoginProviderInfoModel();
        result.init(json);
        return result;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string] : string; } | undefined;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): ImpersonatedAuthenticateResultModel {
        const json = this.toJSON();
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }

    clone(): SwitchedAccountAuthenticateResultModel {
        const json = this.toJSON();
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(json);
        return result;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export enum CaptchaType {
    Defulat = <any>"Defulat", 
    HostTenantRegister = <any>"HostTenantRegister", 
    HostUserLogin = <any>"HostUserLogin", 
    TenantUserRegister = <any>"TenantUserRegister", 
    TenantUserLogin = <any>"TenantUserLogin", 
}

export class PagedResultDtoOfCustomer implements IPagedResultDtoOfCustomer {
    totalCount: number;
    items: Customer[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(Customer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomer {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfCustomer {
        const json = this.toJSON();
        let result = new PagedResultDtoOfCustomer();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfCustomer {
    totalCount: number;
    items: Customer[] | undefined;
}

export class PagedResultDtoOfActivity implements IPagedResultDtoOfActivity {
    totalCount: number;
    items: Activity[] | undefined;

    constructor(data?: IPagedResultDtoOfActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items.push(Activity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfActivity {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }

    clone(): PagedResultDtoOfActivity {
        const json = this.toJSON();
        let result = new PagedResultDtoOfActivity();
        result.init(json);
        return result;
    }
}

export interface IPagedResultDtoOfActivity {
    totalCount: number;
    items: Activity[] | undefined;
}

export class AjaxResult implements IAjaxResult {
    isSuccess: boolean;
    message: string | undefined;
    absoluteUri: string | undefined;
    isException: boolean;
    primaryId: PrimaryId | undefined;
    data: Data2 | undefined;

    constructor(data?: IAjaxResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isSuccess = data["isSuccess"];
            this.message = data["message"];
            this.absoluteUri = data["absoluteUri"];
            this.isException = data["isException"];
            this.primaryId = data["primaryId"] ? PrimaryId.fromJS(data["primaryId"]) : <any>undefined;
            this.data = data["data"] ? Data2.fromJS(data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AjaxResult {
        data = typeof data === 'object' ? data : {};
        let result = new AjaxResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["message"] = this.message;
        data["absoluteUri"] = this.absoluteUri;
        data["isException"] = this.isException;
        data["primaryId"] = this.primaryId ? this.primaryId.toJSON() : <any>undefined;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AjaxResult {
        const json = this.toJSON();
        let result = new AjaxResult();
        result.init(json);
        return result;
    }
}

export interface IAjaxResult {
    isSuccess: boolean;
    message: string | undefined;
    absoluteUri: string | undefined;
    isException: boolean;
    primaryId: PrimaryId | undefined;
    data: Data2 | undefined;
}

export enum ReturnCode {
    请求成功 = <any>"系统繁忙此时请开发者稍候再试", 
    工商数据返回_企业已注销 = <any>"请求成功", 
    工商数据返回_企业不存在或企业信息未更新 = <any>"获取access_token时AppSecret错误或者access_token无效", 
    工商数据返回_企业法定代表人姓名不一致 = <any>"不合法的凭证类型", 
    工商数据返回_企业法定代表人身份证号码不一致 = <any>"不合法的OpenID", 
    法定代表人身份证号码_工商数据未更新_请5_15个工作日之后尝试 = <any>"不合法的媒体文件类型", 
    工商数据返回_企业信息或法定代表人信息不一致 = <any>"不合法的文件类型", 
    对方不是粉丝 = <any>"不合法的文件大小", 
    发送消息失败_对方关闭了接收消息 = <any>"不合法的媒体文件id", 
    发送消息失败_48小时内用户未互动 = <any>"不合法的消息类型_40008", 
    POST参数非法 = <any>"不合法的图片文件大小", 
    获取access_token时AppSecret错误或者access_token无效 = <any>"不合法的语音文件大小", 
    不合法的凭证类型 = <any>"不合法的视频文件大小", 
    不合法的OpenID = <any>"不合法的缩略图文件大小", 
    不合法的媒体文件类型 = <any>"不合法的APPID", 
    不合法的文件类型 = <any>"不合法的access_token", 
    不合法的文件大小 = <any>"不合法的菜单类型", 
    不合法的媒体文件id = <any>"不合法的按钮个数1", 
    不合法的消息类型_40008 = <any>"不合法的按钮个数2", 
    不合法的图片文件大小 = <any>"不合法的按钮名字长度", 
    不合法的语音文件大小 = <any>"不合法的按钮KEY长度", 
    不合法的视频文件大小 = <any>"不合法的按钮URL长度", 
    不合法的缩略图文件大小 = <any>"不合法的菜单版本号", 
    不合法的APPID = <any>"不合法的子菜单级数", 
    不合法的access_token = <any>"不合法的子菜单按钮个数", 
    不合法的菜单类型 = <any>"不合法的子菜单按钮类型", 
    不合法的按钮个数1 = <any>"不合法的子菜单按钮名字长度", 
    不合法的按钮个数2 = <any>"不合法的子菜单按钮KEY长度", 
    不合法的按钮名字长度 = <any>"不合法的子菜单按钮URL长度", 
    不合法的按钮KEY长度 = <any>"不合法的自定义菜单使用用户", 
    不合法的按钮URL长度 = <any>"不合法的oauth_code", 
    不合法的菜单版本号 = <any>"不合法的refresh_token", 
    不合法的子菜单级数 = <any>"不合法的openid列表", 
    不合法的子菜单按钮个数 = <any>"不合法的openid列表长度", 
    不合法的子菜单按钮类型 = <any>"不合法的请求字符不能包含uxxxx格式的字符", 
    不合法的子菜单按钮名字长度 = <any>"不合法的参数", 
    不合法的子菜单按钮KEY长度 = <any>"template_id不正确", 
    不合法的子菜单按钮URL长度 = <any>"不合法的请求格式", 
    不合法的自定义菜单使用用户 = <any>"不合法的URL长度", 
    不合法的oauth_code = <any>"不合法的分组id", 
    不合法的refresh_token = <any>"分组名字不合法", 
    不合法的openid列表 = <any>"appsecret不正确", 
    不合法的openid列表长度 = <any>"小程序Appid不存在", 
    不合法的请求字符不能包含uxxxx格式的字符 = <any>"缺少access_token参数", 
    不合法的参数 = <any>"缺少appid参数", 
    Template_id不正确 = <any>"缺少refresh_token参数", 
    不合法的请求格式 = <any>"缺少secret参数", 
    不合法的URL长度 = <any>"缺少多媒体文件数据", 
    不合法的分组id = <any>"缺少media_id参数", 
    分组名字不合法 = <any>"缺少子菜单数据", 
    输入参数有误 = <any>"缺少oauth_code", 
    Appsecret不正确 = <any>"缺少openid", 
    小程序Appid不存在 = <any>"form_id不正确_或者过期", 
    缺少access_token参数 = <any>"form_id已被使用", 
    缺少appid参数 = <any>"page不正确", 
    缺少refresh_token参数 = <any>"access_token超时", 
    缺少secret参数 = <any>"refresh_token超时", 
    缺少多媒体文件数据 = <any>"oauth_code超时", 
    缺少media_id参数 = <any>"需要GET请求", 
    缺少子菜单数据 = <any>"需要POST请求", 
    缺少oauth_code = <any>"需要HTTPS请求", 
    缺少openid = <any>"需要接收者关注", 
    Form_id不正确_或者过期 = <any>"需要好友关系", 
    Form_id已被使用 = <any>"多媒体文件为空", 
    Page不正确 = <any>"POST的数据包为空", 
    Access_token超时 = <any>"图文消息内容为空", 
    Refresh_token超时 = <any>"文本消息内容为空", 
    Oauth_code超时 = <any>"多媒体文件大小超过限制", 
    需要GET请求 = <any>"消息内容超过限制", 
    需要POST请求 = <any>"标题字段超过限制", 
    需要HTTPS请求 = <any>"描述字段超过限制", 
    需要接收者关注 = <any>"链接字段超过限制", 
    需要好友关系 = <any>"图片链接字段超过限制", 
    没有权限 = <any>"语音播放时间超过限制", 
    多媒体文件为空 = <any>"图文消息超过限制", 
    POST的数据包为空 = <any>"接口调用超过限制", 
    图文消息内容为空 = <any>"创建菜单个数超过限制", 
    文本消息内容为空 = <any>"回复时间超过限制", 
    多媒体文件大小超过限制 = <any>"系统分组不允许修改", 
    消息内容超过限制 = <any>"分组名字过长", 
    标题字段超过限制 = <any>"分组数量超过上限", 
    描述字段超过限制 = <any>"不存在媒体数据", 
    链接字段超过限制 = <any>"不存在的菜单版本", 
    图片链接字段超过限制 = <any>"不存在的菜单数据", 
    语音播放时间超过限制 = <any>"解析JSON_XML内容错误", 
    图文消息超过限制 = <any>"api功能未授权", 
    接口调用超过限制 = <any>"用户未授权该api", 
    创建菜单个数超过限制 = <any>"参数错误invalid_parameter", 
    回复时间超过限制 = <any>"无效客服账号invalid_kf_account", 
    系统分组不允许修改 = <any>"客服帐号已存在kf_account_exsited", 
    分组名字过长 = <any>"客服帐号名长度超过限制", 
    分组数量超过上限 = <any>"客服帐号名包含非法字符", 
    不存在媒体数据 = <any>"客服帐号个数超过限制", 
    不存在的菜单版本 = <any>"无效头像文件类型invalid_file_type", 
    不存在的菜单数据 = <any>"系统错误system_error", 
    解析JSON_XML内容错误 = <any>"日期格式错误", 
    Api功能未授权 = <any>"日期范围错误", 
    用户未授权该api = <any>"发送消息失败_48小时内用户未互动", 
    法人姓名与微信号不一致 = <any>"发送消息失败_该用户已被加入黑名单_无法向此发送消息", 
    系统错误system_error = <any>"发送消息失败_对方关闭了接收消息", 
    参数错误invalid_parameter = <any>"对方不是粉丝", 
    无效客服账号invalid_kf_account = <any>"没有留言权限", 
    客服帐号已存在kf_account_exsited = <any>"该图文不存在", 
    客服帐号名长度超过限制 = <any>"文章存在敏感信息", 
    客服帐号名包含非法字符 = <any>"精选评论数已达上限", 
    客服帐号个数超过限制 = <any>"已被用户删除_无法精选", 
    无效头像文件类型invalid_file_type = <any>"已经回复过了", 
    日期格式错误 = <any>"回复超过长度限制或为0", 
    日期范围错误 = <any>"该评论不存在", 
    发送消息失败_该用户已被加入黑名单_无法向此发送消息 = <any>"获取评论数目不合法", 
    门店不存在 = <any>"该公众号_小程序已经绑定了开放平台帐号", 
    该门店状态不允许更新 = <any>"该主体已有任务执行中_距上次任务24h后再试", 
    标签格式错误 = <any>"内部错误", 
    页面路径错误 = <any>"无效微信号", 
    类目填写错误 = <any>"法人姓名与微信号不一致", 
    已经有正在审核的版本 = <any>"企业代码类型无效_请选择正确类型填写", 
    Item_list有项目为空 = <any>"未找到该任务", 
    标题填写错误 = <any>"待法人人脸核身校验", 
    无效的审核id = <any>"法人_企业信息一致性校验中", 
    没有审核版本 = <any>"缺少参数", 
    审核状态未满足发布 = <any>"第三方权限集不全_补全权限集全网发布后生效", 
    状态不可变 = <any>"已下发的模板消息法人并未确认且已超时_24h_未进行身份证校验", 
    Action非法 = <any>"已下发的模板消息法人并未确认且已超时_24h_未进行人脸识别校验", 
    审核列表填写的项目数不在1到5以内 = <any>"已下发的模板消息法人并未确认且已超时_24h", 
    需要补充相应资料_填写org_code和other_files参数 = <any>"工商数据返回_企业已注销", 
    管理员手机登记数量已超过上限 = <any>"工商数据返回_企业不存在或企业信息未更新", 
    该微信号已绑定5个管理员 = <any>"工商数据返回_企业法定代表人姓名不一致", 
    管理员身份证已登记过5次 = <any>"工商数据返回_企业法定代表人身份证号码不一致", 
    该主体登记数量已超过上限 = <any>"法定代表人身份证号码_工商数据未更新_请5_15个工作日之后尝试", 
    商家名称已被占用 = <any>"工商数据返回_企业信息或法定代表人信息不一致", 
    不能使用该名称 = <any>"不是由第三方代小程序进行调用", 
    该名称在侵权投诉保护期 = <any>"不存在第三方的已经提交的代码", 
    名称包含违规内容或微信等保留字 = <any>"标签格式错误", 
    商家名称在改名15天保护期内 = <any>"页面路径错误", 
    需与该帐号相同主体才可申请 = <any>"类目填写错误", 
    介绍中含有虚假混淆内容 = <any>"已经有正在审核的版本", 
    头像或者简介修改达到每个月上限 = <any>"item_list有项目为空", 
    正在审核中_请勿重复提交 = <any>"标题填写错误", 
    请先成功创建门店后再调用 = <any>"无效的审核id", 
    临时mediaid无效 = <any>"没有审核版本", 
    不是由第三方代小程序进行调用 = <any>"审核状态未满足发布", 
    不存在第三方的已经提交的代码 = <any>"状态不可变", 
    小程序还未设置昵称_头像_简介_请先设置完后再重新提交 = <any>"action非法", 
    无效微信号 = <any>"审核列表填写的项目数不在1到5以内", 
    签名错误 = <any>"小程序还未设置昵称_头像_简介_请先设置完后再重新提交", 
    内容含有违法违规内容 = <any>"签名错误", 
    没有留言权限 = <any>"内容含有违法违规内容", 
    该图文不存在 = <any>"POST参数非法", 
    文章存在敏感信息 = <any>"该经营资质已添加_请勿重复添加", 
    精选评论数已达上限 = <any>"附近地点添加数量达到上线_无法继续添加", 
    已被用户删除_无法精选 = <any>"地点已被其它小程序占用", 
    已经回复过了 = <any>"附近功能被封禁", 
    回复超过长度限制或为0 = <any>"地点正在审核中", 
    该评论不存在 = <any>"地点正在展示小程序", 
    获取评论数目不合法 = <any>"地点审核失败", 
    该公众号_小程序已经绑定了开放平台帐号 = <any>"程序未展示在该地点", 
    内部错误 = <any>"小程序未上架或不可见", 
    企业代码类型无效_请选择正确类型填写 = <any>"地点不存在", 
    该主体已有任务执行中_距上次任务24h后再试 = <any>"个人类型小程序不可用", 
    未找到该任务 = <any>"需要补充相应资料_填写org_code和other_files参数", 
    待法人人脸核身校验 = <any>"管理员手机登记数量已超过上限", 
    法人_企业信息一致性校验中 = <any>"该微信号已绑定5个管理员", 
    缺少参数 = <any>"管理员身份证已登记过5次", 
    第三方权限集不全_补全权限集全网发布后生效 = <any>"该主体登记数量已超过上限", 
    该经营资质已添加_请勿重复添加 = <any>"商家名称已被占用", 
    附近地点添加数量达到上线_无法继续添加 = <any>"不能使用该名称", 
    地点已被其它小程序占用 = <any>"该名称在侵权投诉保护期", 
    附近功能被封禁 = <any>"名称包含违规内容或微信等保留字", 
    地点正在审核中 = <any>"商家名称在改名15天保护期内", 
    地点正在展示小程序 = <any>"需与该帐号相同主体才可申请", 
    地点审核失败 = <any>"介绍中含有虚假混淆内容", 
    程序未展示在该地点 = <any>"头像或者简介修改达到每个月上限", 
    小程序未上架或不可见 = <any>"没有权限", 
    地点不存在 = <any>"正在审核中_请勿重复提交", 
    个人类型小程序不可用 = <any>"请先成功创建门店后再调用", 
    已下发的模板消息法人并未确认且已超时_24h_未进行身份证校验 = <any>"临时mediaid无效", 
    已下发的模板消息法人并未确认且已超时_24h_未进行人脸识别校验 = <any>"输入参数有误", 
    已下发的模板消息法人并未确认且已超时_24h = <any>"门店不存在", 
    系统繁忙此时请开发者稍候再试 = <any>"该门店状态不允许更新", 
}

export class AccessTokenResult implements IAccessTokenResult {
    access_token: string | undefined;
    expires_in: number;
    errcode: ReturnCode;
    readonly errorCodeValue: number;
    errmsg: string | undefined;
    p2PData: P2PData | undefined;

    constructor(data?: IAccessTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.access_token = data["access_token"];
            this.expires_in = data["expires_in"];
            this.errcode = data["errcode"];
            (<any>this).errorCodeValue = data["errorCodeValue"];
            this.errmsg = data["errmsg"];
            this.p2PData = data["p2PData"] ? P2PData.fromJS(data["p2PData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AccessTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new AccessTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["access_token"] = this.access_token;
        data["expires_in"] = this.expires_in;
        data["errcode"] = this.errcode;
        data["errorCodeValue"] = this.errorCodeValue;
        data["errmsg"] = this.errmsg;
        data["p2PData"] = this.p2PData ? this.p2PData.toJSON() : <any>undefined;
        return data; 
    }

    clone(): AccessTokenResult {
        const json = this.toJSON();
        let result = new AccessTokenResult();
        result.init(json);
        return result;
    }
}

export interface IAccessTokenResult {
    access_token: string | undefined;
    expires_in: number;
    errcode: ReturnCode;
    errorCodeValue: number;
    errmsg: string | undefined;
    p2PData: P2PData | undefined;
}

export class Data implements IData {

    constructor(data?: IData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Data {
        data = typeof data === 'object' ? data : {};
        let result = new Data();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Data {
        const json = this.toJSON();
        let result = new Data();
        result.init(json);
        return result;
    }
}

export interface IData {
}

export class Anonymous implements IAnonymous {

    constructor(data?: IAnonymous) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous {
        const json = this.toJSON();
        let result = new Anonymous();
        result.init(json);
        return result;
    }
}

export interface IAnonymous {
}

export class Anonymous2 implements IAnonymous2 {

    constructor(data?: IAnonymous2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous2 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous2 {
        const json = this.toJSON();
        let result = new Anonymous2();
        result.init(json);
        return result;
    }
}

export interface IAnonymous2 {
}

export class Anonymous3 implements IAnonymous3 {

    constructor(data?: IAnonymous3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous3 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous3 {
        const json = this.toJSON();
        let result = new Anonymous3();
        result.init(json);
        return result;
    }
}

export interface IAnonymous3 {
}

export class EntityId implements IEntityId {

    constructor(data?: IEntityId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): EntityId {
        data = typeof data === 'object' ? data : {};
        let result = new EntityId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): EntityId {
        const json = this.toJSON();
        let result = new EntityId();
        result.init(json);
        return result;
    }
}

export interface IEntityId {
}

export class CustomData implements ICustomData {

    constructor(data?: ICustomData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): CustomData {
        data = typeof data === 'object' ? data : {};
        let result = new CustomData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): CustomData {
        const json = this.toJSON();
        let result = new CustomData();
        result.init(json);
        return result;
    }
}

export interface ICustomData {
}

export class CustomData2 implements ICustomData2 {

    constructor(data?: ICustomData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): CustomData2 {
        data = typeof data === 'object' ? data : {};
        let result = new CustomData2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): CustomData2 {
        const json = this.toJSON();
        let result = new CustomData2();
        result.init(json);
        return result;
    }
}

export interface ICustomData2 {
}

export class Anonymous4 implements IAnonymous4 {

    constructor(data?: IAnonymous4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous4 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous4 {
        const json = this.toJSON();
        let result = new Anonymous4();
        result.init(json);
        return result;
    }
}

export interface IAnonymous4 {
}

export class Menu2 implements IMenu2 {

    constructor(data?: IMenu2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Menu2 {
        data = typeof data === 'object' ? data : {};
        let result = new Menu2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Menu2 {
        const json = this.toJSON();
        let result = new Menu2();
        result.init(json);
        return result;
    }
}

export interface IMenu2 {
}

export class Conditionalmenu implements IConditionalmenu {

    constructor(data?: IConditionalmenu) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Conditionalmenu {
        data = typeof data === 'object' ? data : {};
        let result = new Conditionalmenu();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Conditionalmenu {
        const json = this.toJSON();
        let result = new Conditionalmenu();
        result.init(json);
        return result;
    }
}

export interface IConditionalmenu {
}

export class Anonymous5 implements IAnonymous5 {

    constructor(data?: IAnonymous5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous5 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous5 {
        const json = this.toJSON();
        let result = new Anonymous5();
        result.init(json);
        return result;
    }
}

export interface IAnonymous5 {
}

export class Anonymous6 implements IAnonymous6 {

    constructor(data?: IAnonymous6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous6 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous6 {
        const json = this.toJSON();
        let result = new Anonymous6();
        result.init(json);
        return result;
    }
}

export interface IAnonymous6 {
}

export class Anonymous7 implements IAnonymous7 {

    constructor(data?: IAnonymous7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous7 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous7 {
        const json = this.toJSON();
        let result = new Anonymous7();
        result.init(json);
        return result;
    }
}

export interface IAnonymous7 {
}

export class Anonymous8 implements IAnonymous8 {

    constructor(data?: IAnonymous8) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous8 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous8();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous8 {
        const json = this.toJSON();
        let result = new Anonymous8();
        result.init(json);
        return result;
    }
}

export interface IAnonymous8 {
}

export class Anonymous9 implements IAnonymous9 {

    constructor(data?: IAnonymous9) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous9 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous9();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous9 {
        const json = this.toJSON();
        let result = new Anonymous9();
        result.init(json);
        return result;
    }
}

export interface IAnonymous9 {
}

export class Anonymous10 implements IAnonymous10 {

    constructor(data?: IAnonymous10) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous10 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous10();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous10 {
        const json = this.toJSON();
        let result = new Anonymous10();
        result.init(json);
        return result;
    }
}

export interface IAnonymous10 {
}

export class Anonymous11 implements IAnonymous11 {

    constructor(data?: IAnonymous11) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Anonymous11 {
        data = typeof data === 'object' ? data : {};
        let result = new Anonymous11();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Anonymous11 {
        const json = this.toJSON();
        let result = new Anonymous11();
        result.init(json);
        return result;
    }
}

export interface IAnonymous11 {
}

export class PrimaryId implements IPrimaryId {

    constructor(data?: IPrimaryId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): PrimaryId {
        data = typeof data === 'object' ? data : {};
        let result = new PrimaryId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): PrimaryId {
        const json = this.toJSON();
        let result = new PrimaryId();
        result.init(json);
        return result;
    }
}

export interface IPrimaryId {
}

export class Data2 implements IData2 {

    constructor(data?: IData2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): Data2 {
        data = typeof data === 'object' ? data : {};
        let result = new Data2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): Data2 {
        const json = this.toJSON();
        let result = new Data2();
        result.init(json);
        return result;
    }
}

export interface IData2 {
}

export class P2PData implements IP2PData {

    constructor(data?: IP2PData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
    }

    static fromJS(data: any): P2PData {
        data = typeof data === 'object' ? data : {};
        let result = new P2PData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }

    clone(): P2PData {
        const json = this.toJSON();
        let result = new P2PData();
        result.init(json);
        return result;
    }
}

export interface IP2PData {
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}